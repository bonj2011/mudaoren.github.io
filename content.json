[{"title":"mysql自增序列","date":"2019-03-16T13:13:16.623Z","path":"2019/03/16/mysql自增序列/","text":"一 变量类型mysql系统参数分为：全局变量和会话变量。这两类设置在设置后立刻生效，但mysql重启后就会失效，如果希望一直有效需要修改Mysql配置文件并重启。 二 重要的命令1. 查看系统级自增序列种子值和间隔值SHOW GLOBAL VARIABLES LIKE ‘auto_incre%’; – 全局变量 MySQL设置表字段属性AUTO_INCREMENT时，默认初始值为1，默认增长间隔为1。 2. 设置增长初始值为nSET @@auto_increment_offset = n;取值范围是1-65535 3. 设置增长幅度为2SET @@auto_increment_increment = 2;取值范围是1-65535 做数据库的主从同步时需要在参数文件中设置自增长的两个相关配置：auto_increment_offset和auto_increment_increment。 在主主同步配置时，需要将两台服务器的auto_increment_increment增长量都配置为2，而要把auto_increment_offset分别配置为1和2.这样才可以避免两台服务器同时做更新时自增长字段的值之间发生冲突。 4. 查看序列下一个值SELECT AUTO_INCREMENT FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = &apos;table_name&apos;； 三 自增序列使用方法1. 创建表时指定CREATE TABLE t_userinfo ( id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, username VARCHAR(30) NOT NULL ) AUTO_INCREMENT = 100; 可在建表时用“AUTO_INCREMENT=n”选项来指定自增序列的初始值。也可以通过脚本 alter table t_userinfo auto_increment = n ;设置表的唯一auto_increment字段起始值从n开始，此表数据量很大时，这样方式执行很慢。 2. 通过alter设置alter table t_userinfo modify id int auto_increment; 四 AUTO_INCREMENT说明 把NULL插入到一个AUTO_INCREMENT数据列时，MySQL将自动生成下一个序列编号。 把0插入AUTO_INCREMENT数据列的效果与插入NULL值一样。建议使用null。 当插入记录时，没有为AUTO_INCREMENT明确指定值，则等同插入NULL值。 当插入记录时，如果为AUTO_INCREMENT数据列明确指定了一个数值，则会出现两种情况，情况一，如果插入的值与已有的编号重复，则会出现出错信息，因为AUTO_INCREMENT数据列的值必须是唯一的；情况二，如果插入的值大于已编号的值，则会把该插入到数据列中，而下一个编号将从这个新值开始递增。 如果用UPDATE命令更新自增列，如果列值与已有的值重复，则会出错。如果大于已有值，则下一个编号从该值开始递增。 如果一张表里有个字段为id的自增主键，向表里面插入了5条数据，删除id为3、4、5的数据，再把mysql重启，之后再插入一条数据，那么这条数据的id值存在两种情况：情况一，如果表的类型为MyISAM，那么是6。情况二，如果表的类型为InnoDB，则id为3。因为两种类型的存储引擎所存储的最大ID记录的方式不同，MyISAM表将最大的ID记录到了数据文件里，重启mysql自增主键的最大ID值也不会丢失； 而InnoDB则是把最大的ID值记录到了内存中，所以重启mysql或者对表进行了OPTIMIZE操作后，最大ID值将会丢失。 参考：https://www.cnblogs.com/wade-lt/p/9008058.html","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"自增序列","slug":"自增序列","permalink":"http://yoursite.com/tags/自增序列/"},{"name":"AUTO_INCREMENT","slug":"AUTO-INCREMENT","permalink":"http://yoursite.com/tags/AUTO-INCREMENT/"}]},{"title":"DNS","date":"2019-03-12T23:25:16.196Z","path":"2019/03/13/DNS/","text":"DNS概念 DNS，即域名服务器，用完成域名和IP间的转换。用户访问网站时，通常会使用域名，比如www.google.com， 而不是直接通过Ip:port的方式，因为域名更容易记忆，更方便使用。而如果通过域名找到真正的网站服务器？这就是DNS做的事。 DNS通常有多级，起始的节点是根节点，在IP转换时会从根节点逐级查找具体的DNS。通常客户端会对DNS做缓存，而不需要从根节点逐级查找。 网站与DNS 对于单一架构小流量网站而言，只需要最简单的能力，向域名供应商注册一个域名，再向DNS服务商购买一个DNS服务，在DNS上完成域名与IP配置即可。 现在的互联网网站，比如华为商城，需要频繁应对大流量冲击，用户来自全国各地。如果让全国各地使用不同网络运营商服务的用户都去访问处于北京或上海的网站服务器，访问过程的网络跳转次数会很多，由此造成的网络时延也会很明显。 为应对上述的情况，网站运营商不得不在全国各地的不同通信运营商的网络中建立站点，这样用户网络可以就近选择网站服务器进行访问，减少跳转次数和网络时延。如同www.vmall.com的域名，域名只有一个，如何根据不同用户IP指向不同的网站服务器？ 这可以由DNS来完成。 DNS可以支持： 根据网站访问者所在的网络类型，判断给用户提供最佳的访问解析地址，使访问用户获得最快捷、最流畅的体验。 可以根据服务器IP所在的运营商省份，来选择不同的细分线路，包括移动、联通、电信、教育网的国内31个省份线路。 可以根据IP范围细分线路。 对于有海外部署服务器的用户，支持非洲、亚洲、欧洲、大洋洲、南美洲、北美洲6大洲设置解析线路，为海外用户提供访问解析地址。每个大洲中，可以细化到国家地区。 支持多级域名配置。 可以分别对实时性内容服务和静态内容服务通过子域名完成差异配置。 支持服务器集合，通过集合中设置的服务器优先级来指定访问顺序，避免服务关闭后用户无法继续访问网站。 有了DNS的域名解析，还可以在域名映射中挂在负载均衡的IP地址，再通过在负载均衡后挂载服务集群的方式有效分散流量冲击。 DNS服务商 这里主要是国内的DNS服务商，中国联通、中国电信、阿里云、114、南方电信、百度、360、中国万网等。","tags":[{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"},{"name":"域名服务器","slug":"域名服务器","permalink":"http://yoursite.com/tags/域名服务器/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"图解HTTP——（十一）Web的攻击技术","date":"2019-01-15T15:54:04.369Z","path":"2019/01/15/图解HTTP——（十一）Web的攻击技术/","text":"点击查看原图","tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"}]},{"title":"图解HTTP——（十）构建Web内容的技术","date":"2019-01-15T14:49:42.807Z","path":"2019/01/15/图解HTTP——（十）构建Web内容的技术/","text":"点击查看原图","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"图解HTTP——（九）基于HTTP的功能追加协议","date":"2019-01-14T23:46:52.966Z","path":"2019/01/15/图解HTTP——（九）基于HTTP的功能追加协议/","text":"点击查看原图","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"spdy","slug":"spdy","permalink":"http://yoursite.com/tags/spdy/"},{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/tags/websocket/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"comet","slug":"comet","permalink":"http://yoursite.com/tags/comet/"}]},{"title":"图解HTTP——（八）确认访问用户身份的认证","date":"2019-01-13T15:41:20.209Z","path":"2019/01/13/图解HTTP——（八）确认访问用户身份的认证/","text":"点击查看原图","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"认证","slug":"认证","permalink":"http://yoursite.com/tags/认证/"}]},{"title":"图解HTTP——（七）确保Web安全的HTTPS","date":"2019-01-13T13:34:51.042Z","path":"2019/01/13/图解HTTP——（七）确保Web安全的HTTPS/","text":"点击查看原图 从仅使用服务器端的公开密钥证书（服务器证书）建立HTTPS通信的过程: CBC模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做XOR运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initialvector，IV）。","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"ssl","slug":"ssl","permalink":"http://yoursite.com/tags/ssl/"}]},{"title":"图解HTTP——（六）HTTP首部","date":"2019-01-10T15:27:25.270Z","path":"2019/01/10/图解HTTP——（六）HTTP首部/","text":"点击查看原图 参考：https://my.oschina.net/u/588516/blog/621569https://www.jianshu.com/p/ff5ff6f3c353https://imququ.com/post/x-forwarded-for-header-in-http.htmlhttps://www.freebuf.com/articles/web/140669.html","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"header","slug":"header","permalink":"http://yoursite.com/tags/header/"}]},{"title":"图解HTTP——（五）与HTTP协作的Web服务器","date":"2019-01-09T15:16:13.841Z","path":"2019/01/09/图解HTTP——（五）与HTTP协作的Web服务器/","text":"点击查看原图","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"图解HTTP——（四）返回结果的HTTP状态码","date":"2019-01-09T14:42:27.908Z","path":"2019/01/09/图解HTTP——（四）返回结果的HTTP状态码/","text":"","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"},{"name":"状态码","slug":"状态码","permalink":"http://yoursite.com/tags/状态码/"}]},{"title":"图解HTTP——（三）HTTP报文内的HTTP信息","date":"2019-01-08T15:19:01.399Z","path":"2019/01/08/图解HTTP——（三）HTTP报文内的HTTP信息/","text":"点击查看原图 multipart/form-data multipart/byteranges","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"}]},{"title":"图解HTTP——（二）简单的HTTP协议","date":"2019-01-07T23:25:15.478Z","path":"2019/01/08/图解HTTP——（二）简单的HTTP协议/","text":"请求报文 响应报文","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"}]},{"title":"图解HTTP——（一）Web及网络协议基础","date":"2019-01-07T15:21:43.197Z","path":"2019/01/07/图解HTTP——（一）Web及网络协议基础/","text":"HTTP参考文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP《图解HTTP》RFC2616 点击查看原图","tags":[{"name":"http协议","slug":"http协议","permalink":"http://yoursite.com/tags/http协议/"}]},{"title":"Java代理模式","date":"2019-01-06T11:51:28.705Z","path":"2019/01/06/Java代理模式/","text":"一、什么是代理模式？ 代理模式也叫做委托模式，为其他对象提供一种代理以控制对这个对象的访问。 举一个例子，你希望假期出国旅游，但是又不想自己处理诸如签证、行程、交通、食宿等麻烦事，就可以找个旅游公司代办，你只需要按照旅游公司的安排出行。生活中的经纪人、中介、律师所的律师、会计事务所会计、甚至超市等都是现实中代理模式应用。 二、常用的代理模式 常用的代理模式分为静态代理和动态代理。 2.1 静态代理 静态代理是在程序编译阶段就已经确定代理类和被代理类，他们的关系已经存在于编译后的字节码文件中。简单讲就是程序员手写的代理就是静态代理。 2.1.1 使用场景 类型（接口/继承）单一，接口功能相对单一，实现类明确且数量较少的情况。 2.1.2 实现方式 继承 接口 2.1.3 实现示例定义一个抽象的被代理者Subject /** * 被代理对象 * 航空公司 */ public interface AirlineCompany { // 订票方法 boolean booking(); } 定义一个具体的被代理者RealSubject /** * 南方航空 */ public class SouthernAirlines implements AirlineCompany { @Override public boolean booking() { System.out.println(&quot;订票成功, 欢迎乘坐南方航空！&quot;); return true; } } 定义一个代理proxy /** * 机票代理公司，可以代理多家航空公司的机票 */ public class AirlineProxy implements AirlineCompany { private AirlineCompany airlineCompany; public AirlineProxy(AirlineCompany airlineCompany) { this.airlineCompany = airlineCompany; } @Override public boolean booking() { System.out.println(&quot;通过代理订购机票！&quot;); return airlineCompany.booking(); } } 测试方法，即消费者 /** * 消费者 */ public class Customer { // 消费者预订机票 public static void main(String[] args) { // 定义一家航空公司，比如南方航空 AirlineCompany southernAir = new SouthernAirlines(); // 定义一家机票代理商 AirlineCompany proxy = new AirlineProxy(southernAir); boolean result = proxy.booking(); System.out.println(&quot;消费者订购机票结果：&quot;+ result); } } 2.1.4 小结 业务类只需要关注业务逻辑本身，保证了业务类的重用性和可扩展性。尽管继承和接口都可以实现静态代理模式，但是使用继承大大限制了代理的范围，因而常用的代理实现方式是接口。比如一个票务公司通常会同时代理机票、火车票、汽车票、轮船票、景点门票甚至演出门票等，这种情况下明显使用接口更加合适。 2.2 动态代理 动态代理是在程序运行阶段才能确定被代理类，被代理类通常是在使用时才会被通过反射机制创建。 2.2.1 使用场景 被代理的实现类不确定，比如对第三方开放。 对象创建开销很大，在使用时才需要创建。 调用其他进程的接口。 动态代理已经被广泛使用，常见的面向切面编程AOP、Hibernate、RPC、JDBC驱动、OSGI、java注解等。 2.2.2 实现方式 jdk原生动态代理 Cglib动态代理 2.2.3 jdk原生动态代理实现步骤创建被代理的接口 /** * 被代理对象 * 航空公司 */ public interface AirlineCompany { // 订票方法 boolean booking(); // 返回公司名称 String company(); } 创建一个被代理接口的具体实现 /** * 南方航空 */ public class SouthernAirlines implements AirlineCompany { @Override public boolean booking() { System.out.println(&quot;订票成功，欢迎乘坐南方航空！&quot;); return true; } @Override public String company() { return &quot;南方航空&quot;; } } 创建一个实现接口InvocationHandler的类，它必须实现invoke方法 /** * 机票代理公司，可以代理多家航空公司的机票 */ public class AirlineProxy implements InvocationHandler { private Object target; /** * @param object 该参数为要代理的实例对象，目的是用于执行method.invoke()方法（也就是执行目标方法） * @return Object 返回被代理类实例 * / public Object getInstance(Object object) { this.target = object; Class clazz = object.getClass(); System.out.println(MessageFormat.format(&quot;创建{0}的代理！&quot;, target.getClass())); // 这里要调用Proxy的newProxyInstance静态方法，创建一个代理类。如果这里不创建，那么需要在顾客订票时创建。newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。 return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); } /** * 在invoke()方法里我们可以加入任何逻辑。 * @param proxy 动态生成的代理对象 * @param method 目标方法的实例 * @param args 目标方法的参数 * @return 该方法的返回值就是代理对象执行目标方法的返回值 * / @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { return method.invoke(target, args); } } 通过代理对象调用目标方法 /** * 定义一个顾客 */ public class Customer { // 顾客通过代理订票 public static void main(String[] args) { // 南方航空 SouthernAirlines southernAir = new SouthernAirlines(); // 定义一家机票代理商 SouthernAirlines proxy = (SouthernAirlines)new AirlineProxy().getInstance(southernAir); boolean result = proxy.booking(); String companyName = proxy.company(); System.out.println(MessageFormat.format(&quot;顾客通过代理[ {0}]，订购[{1}]机票结果[{2}]&quot;, proxy.getClass(), companyName, result)); // 打印代理类的二进制文件 writeProxyByte(proxy); } // 输出代理类的二进制文件 private static void writeProxyByte(Object object) { try { byte[] $Proxy0s = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, new Class[] {object.getClass()}); FileOutputStream fileOutputStream = new FileOutputStream(&quot;$Proxy0.class&quot;); fileOutputStream.write($Proxy0s); fileOutputStream.close(); } catch(IOException ex) { } } } 测试结果： 创建class designPaterns.proxyPaterns.dynamicProxy.jdkRealize.SouthernAirlines的代理！ 订票成功，欢迎乘坐南方航空！ 消费者通过代理[ class com.sun.proxy.$Proxy0]，订购[南方航空]机票结果[true] 小结： JDK原生动态代理只能代理实现了接口的类， 没有实现接口的类不能实现动态代理。 2.2.4 Cglib动态代理实现步骤 Cglib动态代理的实现原理和jdk基本相同，都是生成新的代理类。但具体实现有所不同，cglib动态代理生成的代理类是被代理者的子类，且会重写父类除private和final修饰的所有方法，要求该父类必须有空的构造方法。 创建一个被代理类型的具体实现 /** * 南方航空 */ public class SouthernAirlines { public boolean booking() { System.out.println(&quot;订票成功，欢迎乘坐南方航空！&quot;); return true; } public String company() { return &quot;南方航空&quot;; } } 创建一个代理，需要实现cglib包的MethodInterceptor接口，以保证可以调用方法intercept /** * 定义一个代理 */ public class AirlineProxy implements MethodInterceptor { private Object target; // 返回代理对象 public Object getInstance(Object object) { this.target = object; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); System.out.println(MessageFormat.format(&quot;创建{0}的代理对象！&quot;, target.getClass())); return enhancer.create(); } /** * 实现MethodInterceptor接口的intercept方法后，所有生成的代理方法都调用这个方法 * @param obj 目标类的实例 * @param method 目标方法实例（通过反射获取的目标方法实例） * @param args 目标方法的参数 * @param proxy 代理类的实例 * @return Object 目标方法的返回值。 */ public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { return method.invoke(target, args); } } 通过代理对象调用目标方法 /** * 定义一个顾客 */ public class Customer { // 顾客通过代理订票 public static void main(String[] args) { // 南方航空 SouthernAirlines southernAir = new SouthernAirlines(); // 定义一家机票代理商 SouthernAirlines proxy = (SouthernAirlines)new AirlineProxy().getInstance(southernAir); boolean result = proxy.booking(); String companyName = proxy.company(); System.out.println(MessageFormat.format(&quot;顾客通过代理[ {0}]，订购[{1}]机票结果[{2}]&quot;, proxy.getClass(), companyName, result)); // 打印代理类的二进制文件 writeProxyByte(proxy); } // 输出代理类的二进制文件 private static void writeProxyByte(Object object) { try { byte[] $Proxy0s = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, new Class[] {object.getClass()}); FileOutputStream fileOutputStream = new FileOutputStream(&quot;$Proxy0.class&quot;); fileOutputStream.write($Proxy0s); fileOutputStream.close(); } catch(IOException ex) { } } } 测试结果： 创建class com.mudaoren.designPaterns.proxyPaterns.dynamicProxy.cblibrealize.SouthernAirlines的代理对象！ 订票成功，欢迎乘坐南方航空！ 顾客通过代理[ class com.mudaoren.designPaterns.proxyPaterns.dynamicProxy.cblibrealize.SouthernAirlines$$EnhancerByCGLIB$$f6637d97]，订购[南方航空]机票结果[true] 小结： cglib的动态代理是针对类来实现代理。对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用。因为通过继承实现，所以final类无法使用。 参考：https://dzone.com/articles/cglib-missing-manual","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]},{"title":"PDCA循环","date":"2019-01-02T15:31:09.657Z","path":"2019/01/02/PDCA循环/","text":"PDCA循环也叫戴明循环，是一个持续改进模型，包括持续改进和不断学习的四个循环反复步骤。分别是计划（Plan）、执行（Do）、检查（Check）、处理（Action）。 PDCA的典型适用场景 个人管理和提升 项目管理 人力资源管理 供应商管理 流程管理 持续改进 PDCA循环步骤 计划（Plan）。制定行动方案和目标，可以使用5W1H。 执行（Do）。依据计划具体执行。 检查（Check）。检查计划执行的过程和结果是否符合预期方案或目标，出现哪些问题和偏差。检查点的选择就是执行过程中的“控制点”、“管理点”。 效果（Action）。对检查结果进行处理，好的经验进行固化推广，失败的经验要总结改进措施，以便应用到下一个循环。Action如同导演拍电影时使用的Action，由演员按照剧本进行表演，导演对表演效果进行评判。 PDCA循环的重点 持续改进，不断上升。多个PDCA环是持续上升的过程，预示着效果、质量和水平不断提升。 相关理论 Plan的过程建议使用5W1H的方式进行，即why、what、where、who、when、how。 Check的过程如果能结合AAR（After Action Review）方法进行，效果会更好。AAR是美国陆军的一种任务检视方法，主要有4个方面：当初的目标是什么？ 实际发生了什么？ 从中学到了什么？ 以后该怎么做？","tags":[{"name":"PDCA循环","slug":"PDCA循环","permalink":"http://yoursite.com/tags/PDCA循环/"},{"name":"戴明循环","slug":"戴明循环","permalink":"http://yoursite.com/tags/戴明循环/"}]},{"title":"高效能认识的七个习惯读书笔记","date":"2018-12-24T15:44:22.185Z","path":"2018/12/24/高效能认识的七个习惯读书笔记/","text":"成长过程依赖期——&gt;独立期——&gt;互赖期 独立生理独立：自由行动心智独立：自主思考情感独立：肯定自我精神独立：价值观清晰（合作与奉献） 互赖合作、双赢","tags":[{"name":"高效能认识的七个习惯","slug":"高效能认识的七个习惯","permalink":"http://yoursite.com/tags/高效能认识的七个习惯/"}]},{"title":"CSRF 攻击与防范","date":"2018-12-23T11:16:30.079Z","path":"2018/12/23/CSRF 攻击与防范/","text":"CSRF（Cross Site Request Forgery），跨站点请求伪造，是一种常见的Web攻击方式。 1. CSRF如何攻击？ CSRF攻击之所以会成功是由于请求操作的所有参数都能被攻击者所预知。 1） 一个普通的银行用户A，通过银行网站http://huixfeng.bank.com/transfer?account=A&amp;amount=20000&amp;to=B， 向B用户账户转账20000。正常情况，服务端会对用户A的请求进行验证，假设是通过session完成。 2） 攻击者X也了解到该银行的转账链接http://huixfeng.bank.com/transfer?account=A&amp;amount=10000&amp;to=X，希望从A的账户向自己的账户X，转账10000元。但是因为服务端会通过session验证，他无法成功完成转账。 3） X想到了CSRF攻击，他自己做了一个木马网站，通过某些手段诱导了A用户点击这个木马网站。并且木马网站中植入代码http://huixfeng.bank.com/transfer?account=A&amp;amount=10000&amp;to=X,这时，如果A用户点击了木马链接，就会向银行服务发起转账请求。 4） 尽管X成功的诱导了A向银行发起了转账请求，但是由于银行端需要session验证，所以此时转账并不会成功。 假设用户A在点击木马链接前，恰好登陆过银行的网站，那么A的浏览器cookie中可能还存有认证信息，如果A用户在银行服务器的session此时没有过期，那么这个攻击就成功了。 2. CSRF 攻击的目标 浏览器具有同源策略，攻击者无法解析浏览器返回的结果。因此CSRF攻击主要是通过请求连接来触发Web端的某些操作，常见的操作是服务器端数据的增删改，如同上例中的银行账户数据的变化。Google的Gmail邮箱曾经出现过一个CSRF漏洞，攻击者诱导用户点击木马链接后，向服务端发送了一个为用户设置邮件自动转发规则，将用户的邮件自动转发到攻击者指定的邮箱。 3. 如何防范CSRF 目前常用的防御措施： 验证码 增加HTTP Referer验证 增加token验证 3.1 验证码 重要操作增加验证码校验，强制用户完成互动。比如银行转账或消费时，当超过10000时自动触发验证码验证，当用户输入正确验证码后才能继续操作。但是这种方式严重影响用户体验，并不适合所有场景。 3.2 增加HTTP Referer验证 HTTP Referer是HTTP Header中的字段叫Referer，它记录了该HTTP请求的来源地址。 通常情况下，当用户登录一个网站后，在Web页面上的任何操作都是来源于这个网站，这个页面上的所有操作请求的Referer值就是操作所在的页面url。因此服务端可以通过对HTTP Referer进行验证，即可判断该请求是否合法。 还是以文章开头的例子，用户A在银行界面上发起的所有操作的HTTP Referer值都会带有该网站的域名。而攻击者通过木马网站触发的转账请求的HTTP Referer值是木马网站的url。银行服务端只需要增加对Referer的验证就可以判断该转账操作是否合法。 优点： 简单方便。只需要在服务端增加拦截器对请求的HTTP Referer统一校验，没有侵入性。 缺点： 1） Referer的值是浏览器提供，尽管你理论上HTTP协议和浏览器可以共同保证。但浏览器并不是完全可信的，有些浏览器比如IE6有方法可以篡改Referer值。 2） Referer记录下用户的访问来源，涉及到用户隐私保护，在某些地区如欧洲北美等地区用户保护组织并不认可通过Referer发送来源信息，用户可以自己在浏览器中设置禁止发送Referer信息。 3.3 增加token验证 CSRF的攻击者通过完整伪造用户请求，诱导用户在自己的浏览器发起了操作请求，而此时请求的验证信息完全来源于用户浏览器的cookie。 基于上述事实使用token验证时，token必须是不可预测的，并且不能存储在cookie中。惯用的做法是在HTTP请求中增加一个token参数，如CSRFToken，参数值是由服务端随机产生并返回给浏览器的数值，在服务端增加拦截器进行验证。 具体操作中，Web服务端增加两个拦截器，一个token赋值拦截器，一个token验证拦截器。 1） 用户在登陆网站时，token赋值拦截器会产生一个随机token并将token置于javascript中返回给浏览器。浏览器在接收到返回消息中的javascript时会立即执行该脚本，该脚本的作用是通知浏览器将CSRFToken设置到下次请求的hander中。 2） 用户再次发起请求时，hander中会携带CSRFToken到服务端，服务端的token验证拦截器会对该CSRFToken进行验证。 为了实现方便，一般用户的一次会话会产生一个Token，并保存到session中用于token的验证（注意，分布式系统中需要存在session中）。当然也可以每次请求使用一个token，但是这种方式会造成一个问题：当用户在浏览器中同时打开多个页面同时操作时，一个页面消耗掉token，另外一个页面就不能再使用该token了，此时需要服务端一次产生多个token供多个页面使用，这种方式复杂性就增加了。 一般实现是为javaScript制作一个钩子返回给浏览器以监控浏览器的JS动作，当浏览器下一次操作时，钩子就会生效向Header中添加token（当然脚本中也可以同时向from中写入token），非IE浏览器可以使用XMLHttpRequest，IE浏览器使用window.XMLHttpRequest，关于XMLHttpRequest可参考http://www.w3school.com.cn/xmldom/dom_http.asp。 优点： 安全性高，无侵入性。实现原理也并不复杂。 缺点： 1） 返回消息中需要携带JavaScript片段，增加了网络传输负担。 2） 如果网站支持跳转到用户指定个人网站，那么这种方式会造成token泄露，因此这种情况还需要做特殊处理。 3.4 开源工具 OWASP-CSRFGuard是一个拥有BSD许可的友好开源软件，通过简单配置即可使用。 4. CSRF测试 开源测试工具CSRFTester工具可以进行测试。 5. 总结 CSRF的Token防御仅能对抗CSRF攻击，如果网站还存在XSS漏洞，攻击者可以通过模拟客户端浏览器执行任意操作，攻击者可以获取到Token，并构造出合法请求而绕过CSRF防御。因此安全防御必须成体系建设。 参考 https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)《白帽子讲Web安全》https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html?mhq=token%20%20%E6%94%BB%E5%87%BB&amp;mhsrc=ibmsearch_dhttp://www.yihaomen.com//article//java//408.htmhttps://my.oschina.net/langxSpirit/blog/678901https://blog.csdn.net/u013711961/article/details/70237515","tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"CSRF","slug":"CSRF","permalink":"http://yoursite.com/tags/CSRF/"},{"name":"Token","slug":"Token","permalink":"http://yoursite.com/tags/Token/"}]},{"title":"中国惠普前总裁孙振耀谈工作与生活","date":"2018-12-18T15:05:47.366Z","path":"2018/12/18/中国惠普前总裁孙振耀谈工作与生活/","text":"偶然拜读孙振耀先生的退休感言，字字真切，多有同感，深受启发，然知易行难，故收藏在此，以便时常翻阅以激励自己。 文/中国惠普前总裁 孙振耀 我有个有趣的观察，外企公司多的是25-35岁的白领，40岁以上的员工很少，二三十岁的外企员工是意气风发的，但外企公司40岁附近的经理人是很尴尬的。我见过的40岁附近的外企经理人大多在一直跳槽，最后大多跳到民企，比方说，唐骏。外企员工的成功很大程度上是公司的成功，并非个人的成功，西门子的确比国美大，但并不代表西门子中国经理比国美的老板强，甚至可以说差得很远。而进外企的人往往并不能很早理解这一点，把自己的成功90%归功于自己的能力，实际上，外企公司随便换个中国区总经理并不会给业绩带来什么了不起的影响。好了问题来了，当这些经理人40多岁了，他们的薪资要求变得很高，而他们的才能其实又不是那么出众，作为外企公司的老板，你会怎么选择？有的是只要不高薪水的，要出位的精明强干精力冲沛的年轻人，有的是，为什么还要用你？ 从上面这个例子，其实可以看到我们的工作轨迹，二三十岁的时候，生活的压力还比较小，身体还比较好，上面的父母身体还好，下面又没有孩子，不用还房贷，也没有孩子要上大学，当个外企小白领还是很光鲜的，挣得不多也够花了。但是人终归要结婚生子，终归会老，到了40岁，父母老了，要看病要吃药，要有人看护，自己要还房贷，要过基本体面的生活，要养小孩……那个时候需要挣多少钱才够花才重要。所以，看待工作，眼光要放远一点，一时的谁高谁低并不能说明什么。 从这个角度上来说，我不太赞成过于关注第一份工作的薪水，更没有必要攀比第一份工作的薪水，这在刚刚出校园的学生中间是很常见的。正常人大概要工作35年，这好比是一场马拉松比赛，和真正的马拉松比赛不同的是，这次比赛没有职业选手，每个人都只有一次机会。要知到，有很多人甚至坚持不到终点，大多数人最后是走到终点的，只有少数人是跑过终点的，因此在刚开始的时候，去抢领先的位置并没有太大的意义。刚进社会的时候如果进500强公司，大概能拿到3k-6k/月的工资，有些特别技术的人才可能可以到8k/月，可问题是，5年以后拿多少？估计5k-10k了不起了。起点虽然高，但增幅有限，而且，后面的年轻人追赶的压力越来越大。 我前两天问我的一个销售，你会的这些东西一个新人2年就都学会了，但新人所要求的薪水却只是你的一半，到时候，你怎么办？ 职业生涯就像一场体育比赛，有初赛、复赛、决赛。初赛的时候大家都刚刚进社会，大多数都是实力一般的人，这时候努力一点认真一点很快就能让人脱颖而出，于是有的人二十多岁做了经理，有的人迟些也终于赢得了初赛，三十多岁成了经理。然后是复赛，能参加复赛的都是赢得初赛的，每个人都有些能耐，在聪明才智上都不成问题，这个时候再想要胜出就不那么容易了，单靠一点点努力和认真还不够，要有很强的坚忍精神，要懂得靠团队的力量，要懂得收服人心，要有长远的眼光…… 看上去赢得复赛并不容易，但，还不是那么难。因为这个世界的规律就是给人一点成功的同时让人骄傲自满，刚刚赢得初赛的人往往不知道自己赢得的仅仅是初赛，有了一点小小的成绩大多数人都会骄傲自满起来，认为自己已经懂得了全部，不需要再努力再学习了，他们会认为之所以不能再进一步已经不是自己的原因了。虽然他们仍然不好对付，但是他们没有耐性，没有容人的度量，更没有清晰长远的目光。就像一只愤怒的斗牛，虽然猛烈，最终是会败的，而赢得复赛的人则象斗牛士一样，不急不躁，跟随着自己的节拍，慢慢耗尽对手的耐心和体力。赢得了复赛以后，大约已经是一位很了不起的职业经理人了，当上了中小公司的总经理，大公司的副总经理，主管着每年几千万乃至几亿的生意。 最终的决赛来了，说实话我自己都还没有赢得决赛，因此对于决赛的决胜因素也只能凭自己的猜测而已，这个时候的输赢或许就像武侠小说里写得那样，大家都是高手，只能等待对方犯错了，要想轻易击败对手是不可能的，除了使上浑身解数，还需要一点运气和时间。世界的规律依然发挥着作用，赢得复赛的人已经不只是骄傲自满了，他们往往刚愎自用，听不进去别人的话，有些人的脾气变得暴躁，心情变得浮躁，身体变得糟糕，他们最大的敌人就是他们自己，在决赛中要做的只是不被自己击败，等着别人被自己击败。这和体育比赛是一样的，最后高手之间的比赛，就看谁失误少谁就赢得了决赛。 根源 你工作快乐么？你的工作好么？ 有没有觉得干了一段时间以后工作很不开心？有没有觉得自己入错了行？有没有觉得自己没有得到应有的待遇？有没有觉得工作像一团乱麻每天上班都是一种痛苦？有没有很想换个工作？有没有觉得其实现在的公司并没有当初想象得那么好？有没有觉得这份工作是当初因为生存压力而找的，实在不适合自己？你从工作中得到你想要得到的了么？你每天开心么？ 天涯上愤怒的人很多，你有没有想过，你为什么不快乐？你为什么愤怒？ 其实，你不快乐的根源，是因为你不知道要什么！你不知道要什么，所以你不知道去追求什么，你不知道追求什么，所以你什么也得不到。 我总觉得，职业生涯首先要关注的是自己，自己想要什么？大多数人大概没想过这个问题，唯一的想法只是——我想要一份工作，我想要一份不错的薪水，我知道所有人对于薪水的渴望，可是，你想每隔几年重来一次找工作的过程么？你想每年都在这种对于工作和薪水的焦急不安中度过么？不想的话，就好好想清楚。饮鸩止渴，不能因为口渴就拼命喝毒药。越是焦急，越是觉得自己需要一份工作，越饥不择食，越想不清楚，越容易失败，你的经历越来越差，下一份工作的人看着你的简历就皱眉头。于是你越喝越渴，越渴越喝，陷入恶性循环。最终只能哀叹世事不公或者生不逢时，只能到天涯上来发泄一把，在失败者的共鸣当中寻求一点心理平衡罢了。大多数人都有生存压力，我也是，有生存压力就会有很多焦虑，积极的人会从焦虑中得到动力，而消极的人则会因为焦虑而迷失方向。所有人都必须在压力下做出选择，这就是世道，你喜欢也罢不喜欢也罢。 一般我们处理的事情分为重要的事情和紧急的事情，如果不做重要的事情就会常常去做紧急的事情。比如锻炼身体保持健康是重要的事情，而看病则是紧急的事情。如果不锻炼身体保持健康，就会常常为了病痛烦恼。又比如防火是重要的事情，而救火是紧急的事情，如果不注意防火，就要常常救火。找工作也是如此，想好自己究竟要什么是重要的事情，找工作是紧急的事情，如果不想好，就会常常要找工作。往往紧急的事情给人的压力比较大，迫使人们去赶紧做，相对来说重要的事情反而没有那么大的压力，大多数人做事情都是以压力为导向的，压力之下，总觉得非要先做紧急的事情，结果就是永远到处救火，永远没有停歇的时候。(很多人的工作也像是救火队一样忙碌痛苦，也是因为工作中没有做好重要的事情。)那些说自己活在水深火热为了生存顾不上那么多的朋友，今天找工作困难是当初你们没有做重要的事情，是结果不是原因。如果今天你们还是因为急于要找一份工作而不去思考，那么或许将来要继续承受痛苦找工作的结果。 我始终觉得我要说的话题，沉重了点，需要很多思考，远比唐笑打武警的话题来的枯燥乏味，但是，天下没有轻松的成功，成功，要付代价。请先忘记一切的生存压力，想想这辈子你最想要的是什么？所以，最要紧的事情，先想好自己想要什么。 什么是好工作 当初微软有个唐骏，很多大学里的年轻人觉得这才是他们向往的职业生涯，我在清华bbs里发的帖子被这些学子们所不屑，那个时候学生们只想出国或者去外企，不过如今看来，我还是对的，唐骏去了盛大，陈天桥创立的盛大，一家民营公司。一个高学历的海归在500强的公司里拿高薪水，这大约是很多年轻人的梦想，问题是，每年毕业的大学生都在做这个梦，好的职位却只有500个。 人都是要面子的，也是喜欢攀比的，即使在工作上也喜欢攀比，不管那是不是自己想要的。大家认为外企公司很好，可是好在哪里呢？好吧，他们在比较好的写字楼，这是你想要的么？他们出差住比较好的酒店，这是你想要的么？别人会羡慕一份外企公司的工作，这是你想要的么？那一切都是给别人看的，你干吗要活得那么辛苦给别人看？另一方面，他们薪水福利一般，并没有特别了不起，他们的晋升机会比较少，很难做到很高阶的主管，他们虽然厌恶常常加班，却不敢不加班，因为“你不干有得是人干”，大部分情况下会找个台湾人香港人新加坡人来管你，而这些人又往往有些莫名其妙的优越感。你想清楚了么？500强一定好么？找工作究竟是考虑你想要什么，还是考虑别人想看什么？ 我的大学同学们大多数都到美国了，甚至毕业这么多年了，还有人最近到国外去了。出国真的有那么好么？我的大学同学们，大多数还是在博士、博士后、访问学者地挣扎着，至今只有一个正经在一个美国大学里拿到个正式的教职。国内的教授很难当么？我有几个表亲也去了国外了，他们的父母独自在国内，没有人照顾，有好几次人在家里昏倒都没人知道，出国，真的这么光彩么？就像有人说的“很多事情就像看A片，看的人觉得很爽，做的人未必。” 人总想找到那个最好的，可是，什么是最好的？你觉得是最好的那个，是因为你的确了解，还是因为别人说他是最好的？即使他对于别人是最好的，对于你也一定是最好的么？ 对于自己想要什么，自己要最清楚，别人的意见并不是那么重要。很多人总是常常被别人的意见所影响，亲戚的意见，朋友的意见，同事的意见……问题是，你究竟是要过谁的一生？人的一生不是父母一生的续集，也不是儿女一生的前传，更不是朋友一生的外篇，只有你自己对自己的一生负责，别人无法也负不起这个责任。自己做的决定，至少到最后，自己没什么可后悔。对于大多数正常智力的人来说，所做的决定没有大的对错，无论怎么样的选择，都是可以尝试的。比如你没有考自己上的那个学校，没有入现在这个行业，这辈子就过不下去了？就会很失败？不见得。 我想，好工作，应该是适合你的工作，具体点说，应该是能给你带来你想要的东西的工作，你或许应该以此来衡量你的工作究竟好不好，而不是拿公司的大小，规模，外企还是国企，是不是有名，是不是上市公司来衡量。小公司，未必不是好公司，赚钱多的工作，也未必是好工作。你还是要先弄清楚你想要什么，如果你不清楚你想要什么，你就永远也不会找到好工作，因为你永远只看到你得不到的东西，你得到的，都是你不想要的。 可能，最好的，已经在你的身边，只是，你还没有学会珍惜。人们总是盯着得不到的东西，而忽视了那些已经得到的东西。 普通人 我发现中国人的励志和国外的励志存在非常大的不同，中国的励志比较鼓励人立下大志愿，卧薪尝胆，有朝一日成富成贵。而国外的励志比较鼓励人勇敢面对现实生活，面对普通人的困境，虽然结果也是成富成贵，但起点不一样，相对来说，我觉得后者在操作上更现实，而前者则需要用999个失败者来堆砌一个成功者的故事。 我们都是普通人，普通人的意思就是，概率这件事是很准的。因此，我们不会买彩票中500万，我们不会成为比尔盖茨或者李嘉诚，我们不会坐飞机掉下来，我们当中很少的人会创业成功，我们之中有30%的人会离婚，我们之中大部分人会活过65岁…… 所以请你在想自己要什么的时候，要得“现实”一点，你说我想要做李嘉诚，抱歉，我帮不上你。成为比尔盖茨或者李嘉诚这种人，是靠命的，看我写的这篇文章绝对不会让你成为他们，即使你成为了他们，也绝对不是我这篇文章的功劳。“王侯将相宁有种乎”但真正当皇帝的只有一个人，王侯将相，人也不多。目标定得高些对于喜欢挑战的人来说有好处，但对于大多数普通人来说，反而比较容易灰心沮丧，很容易就放弃了。 回过头来说，李嘉诚比你有钱大致50万倍，他比你更快乐么？或许。有没有比你快乐50万倍，一定没有。他比你最多也就快乐一两倍，甚至有可能还不如你快乐。寻找自己想要的东西不是和别人比赛，比谁要得更多更高，比谁的目标更远大。虽然成为李嘉诚这个目标很宏大，但你并不见得会从这个目标以及追求目标的过程当中获得快乐，而且基本上你也做不到。你必须听听你内心的声音，寻找真正能够使你获得快乐的东西，那才是你想要的东西。 你想要的东西，或者我们把它称之为目标，目标其实并没有高低之分，你不需要因为自己的目标没有别人远大而不好意思，达到自己的目标其实就是成功，成功有大有小，快乐却是一样的。我们追逐成功，其实追逐的是成功带来的快乐，而非成功本身。职业生涯的道路上，我们常常会被攀比的心态蒙住眼睛，忘记了追求的究竟是什么，忘记了是什么能使我们更快乐。 社会上一夜暴富的新闻很多，这些消息，总会在我们的心里面掀起很多涟漪，涟漪多了就变成惊涛骇浪，心里的惊涛骇浪除了打翻承载你目标的小船，并不会使得你也一夜暴富。“只见贼吃肉，不见贼挨揍。”我们这些普通人既没有当贼的勇气，又缺乏当贼的狠辣绝决，虽然羡慕吃肉，却更害怕挨揍，偶尔看到几个没挨揍的贼就按奈不住，或者心思活动，或者大感不公，真要叫去做贼，却也不敢。 我还是过普通人的日子，要普通人的快乐，至少，晚上睡得着觉。 跳槽与积累 首先要说明，工作是一件需要理智的事情，所以不要在工作上耍个性，天涯上或许会有人觉得你很有个性而叫好，煤气公司电话公司不会因为觉得你很有个性而免了你的帐单。当你很帅地炒掉了你的老板，当你很酷地挖苦了一番招聘的HR，账单还是要照付，只是你赚钱的时间更少了，除了你自己，没人受损失。 我并不反对跳槽，但跳槽决不是解决问题的办法，而且频繁跳槽的后果是让人觉得没有忠诚度可言，而且不能安心工作。现在很多人从网上找工作，很多找工作的网站常常给人出些馊主意，要知道他们是盈利性企业，当然要从自身盈利的角度来考虑，大家越是频繁跳槽频繁找工作他们越是生意兴隆，所以鼓动人们跳槽是他们的工作。所以他们会常常告诉你，你拿的薪水少了，你享受的福利待遇差了，又是“薪情快报”又是“赞叹自由奔放的灵魂”。至于是否会因此让你不能安心，你跳了槽是否解决问题，是否更加开心，那个，他们管不着。 要跳槽肯定是有问题，一般来说问题发生了，躲是躲不开的，很多人跳槽是因为这样或者那样的不开心，如果这种不开心，在现在这个公司不能解决，那么在下一个公司多半也解决不掉。你必须相信，90%的情况下，你所在的公司并没有那么烂，你认为不错的公司也没有那么好。就像围城里说的，“城里的人拼命想冲出来，而城外的人拼命想冲进去。”每个公司都有每个公司的问题，没有问题的公司是不存在的。换个环境你都不知道会碰到什么问题，与其如此，不如就在当下把问题解决掉。很多问题当你真的想要去解决的时候，或许并没有那么难。有的时候你觉得问题无法解决，事实上，那只是“你觉得”。 人生的曲线应该是曲折向上的，偶尔会遇到低谷但大趋势总归是曲折向上的，而不是象脉冲波一样每每回到起点，我见过不少面试者，30多岁了，四五份工作经历，每次多则3年，少则1年，30多岁的时候回到起点从一个初级职位开始干起，拿基本初级的薪水，和20多岁的年轻人一起竞争，不觉得有点辛苦么？这种日子好过么？ 资本靠的就是积累，这种积累包括人际关系，经验，人脉，口碑……如果常常更换行业，代表几年的积累付之东流，一切从头开始，如果换了两次行业，35岁的时候大概只有5年以下的积累，而一个没有换过行业的人至少有了10年的积累，谁会占优势？工作到2-3年的时候，很多人觉得工作不顺利，好像到了一个瓶颈，心情烦闷，就想辞职，乃至换一个行业，觉得这样所有一切烦恼都可以抛开，会好很多。其实这样做只是让你从头开始，到了时候还是会发生和原来行业一样的困难，熬过去就向上跨了一大步，要知道每个人都会经历这个过程，每个人的职业生涯中都会碰到几个瓶颈，你熬过去了而别人没有熬过去你就领先了。跑长跑的人会知道，开始的时候很轻松，但是很快会有第一次的难受，但过了这一段又能跑很长一段，接下来会碰到第二次的难受，坚持过了以后又能跑一段，如此往复，难受一次比一次厉害，直到坚持不下去了。大多数人第一次就坚持不了了，一些人能坚持到第二次，第三次虽然大家都坚持不住了，可是跑到这里的人也没几个了，这点资本足够你安稳活这一辈子了。 一份工作到两三年的时候，大部分人都会变成熟手，这个时候往往会陷入不断的重复，有很多人会觉得厌倦，有些人会觉得自己已经搞懂了一切，从而懒得去寻求进步了。很多时候的跳槽是因为觉得失去兴趣了，觉得自己已经完成比赛了。其实这个时候比赛才刚刚开始，工作两三年的人，无论是客户关系，人脉，手下，和领导的关系，在业内的名气……还都是远远不够的，但稍有成绩的人总是会自我感觉良好的，每个人都觉得自己跟客户关系铁得要命，觉得自己在业界的口碑好得很。其实可以肯定地说，一定不是，这个时候，还是要拿出前两年的干劲来，稳扎稳打，积累才刚刚开始。 你足够了解你的客户吗？你知道他最大的烦恼是什么吗？你足够了解你的老板么？你知道他最大的烦恼是什么吗？你足够了解你的手下么？你知道他最大的烦恼是什么吗？如果你不知道，你凭什么觉得自己已经积累够了？如果你都不了解，你怎么能让他们帮你的忙，做你想让他们做的事情？如果他们不做你想让他们做的事情，你又何来的成功？ 等待 这是个浮躁的人们最不喜欢的话题，本来不想说这个话题，因为会引起太多的争论，而我又无意和人争论这些，但是考虑到对于职业生涯的长久规划，这是一个躲避不了的话题，还是决定写一写，不爱看的请离开吧。 并不是每次穿红灯都会被汽车撞，并不是每个罪犯都会被抓到，并不是每个错误都会被惩罚，并不是每个贪官都会被枪毙，并不是你的每一份努力都会得到回报，并不是你的每一次坚持都会有人看到，并不是你每一点付出都能得到公正的回报，并不是你的每一个善意都能被理解……这个，就是世道。好吧，世道不够好，可是，你有推翻世道的勇气么？如果没有，你有更好的解决办法么？有很多时候，人需要一点耐心，一点信心。每个人总会轮到几次不公平的事情，而通常，安心等待是最好的办法。 有很多时候我们需要等待，需要耐得住寂寞，等待属于你的那一刻。周润发等待过，刘德华等待过，周星驰等待过，王菲等待过，张艺谋也等待过……看到了他们如今的功成名就的人，你可曾看到当初他们的等待和耐心？你可曾看到金马奖影帝在街边摆地摊？你可曾看到德云社一群人在剧场里给一位观众说相声？你可曾看到周星驰的角色甚至连一句台词都没有？每一个成功者都有一段低沉苦闷的日子，我几乎能想象得出来他们借酒浇愁的样子，我也能想象得出他们为了生存而挣扎的窘迫。在他们一生最中灿烂美好的日子里，他们渴望成功，但却两手空空，一如现在的你。没有人保证他们将来一定会成功，而他们的选择是耐住寂寞。如果当时的他们总念叨着“成功只是属于特权阶级的”，你觉得他们今天会怎样？ 曾经我也不明白有些人为什么并不比我有能力却要坐在我的头上，年纪比我大就一定要当我的领导么？为什么有些烂人不需要努力就能赚钱？为什么刚刚改革开放的时候的人能那么容易赚钱，而轮到我们的时候，什么事情都要正规化了？有一天我突然想，我还在上学的时候他们就在社会里挣扎奋斗了，他们在社会上奋斗积累了十几二十年，我们新人来了，他们有的我都想要，我这不是在要公平，我这是在要抢劫。因为我要得太急，因为我忍不住寂寞。二十多岁的男人，没有钱，没有事业，却有蓬勃的欲望。 人总是会遇到挫折的，人总是会有低潮的，人总是会有不被人理解的时候的，人总是有要低声下气的时候，这些时候恰恰是人生最关键的时候，因为大家都会碰到挫折，而大多数人过不了这个门槛，你能过，你就成功了。在这样的时刻，我们需要耐心等待，满怀信心地去等待，相信，生活不会放弃你，机会总会来的。至少，你还年轻，你没有坐牢，没有生治不了的病，没有欠还不起的债。比你不幸的人远远多过比你幸运的人，你还怕什么？路要一步步走，虽然到达终点的那一步很激动人心，但大部分的脚步是平凡甚至枯燥的，但没有这些脚步，或者耐不住这些平凡枯燥，你终归是无法迎来最后的那些激动人心。 逆境，是上帝帮你淘汰竞争者的地方。要知道，你不好受，别人也不好受，你坚持不下去了，别人也一样，千万不要告诉别人你坚持不住了，那只能让别人获得坚持的信心，让竞争者看着你微笑的面孔，失去信心，退出比赛。胜利属于那些有耐心的人。 在最绝望的时候，我会去看电影《The Pursuit of Happyness》《Jerry Maguire》，让自己重新鼓起勇气，因为，无论什么时候，我们总还是有希望。当所有的人离开的时候，我不失去希望，我不放弃。每天下班坐在车里，我喜欢哼着《隐形的翅膀》看着窗外，我知道，我在静静等待，等待属于我的那一刻。 原贴里伊吉网友的话我很喜欢，抄录在这里： 每个人都希望，自己是独一无二的特殊者 含着金匙出生、投胎到好家庭、工作安排到电力局拿1w月薪这样的小概率事件，当然最好轮到自己 红军长征两万五、打成右派反革命、胼手胝足牺牲尊严去奋斗，最好留给祖辈父辈和别人 自然，不是每个吃过苦的人都会得到回报 但是，任何时代，每一个既得利益者身后，都有他的祖辈父辈奋斗挣扎乃至流血付出生命的身影 羡慕别人有个好爸爸，没什么不可以 问题是，你的下一代，会有一个好爸爸吗？ 至于问到为什么不能有同样的赢面概率？我只能问：为什么物种竞争中，人和猴子不能有同样的赢面概率？ 物竞天择。猴子的灵魂不一定比你卑微，但你身后有几十万年的类人猿进化积淀。 入对行跟对人 在中国，大概很少有人是一份职业做到底的，虽然如此，第一份工作还是有些需要注意的地方，有两件事情格外重要，第一件是入行，第二件事情是跟人。第一份工作对人最大的影响就是入行，现代的职业分工已经很细，我们基本上只能在一个行业里成为专家，不可能在多个行业里成为专家。很多案例也证明即使一个人在一个行业非常成功，到另外一个行业，往往完全不是那么回事情，“你想改变世界，还是想卖一辈子汽水？”是乔布斯邀请百事可乐总裁约翰·斯考利加盟苹果时所说的话，结果这位在百事非常成功的约翰，到了苹果表现平平。其实没有哪个行业特别好，也没有哪个行业特别差，或许有报道说哪个行业的平均薪资比较高，但是他们没说的是，那个行业的平均压力也比较大。看上去很美的行业一旦进入才发现很多地方其实并不那么完美，只是外人看不见。 说实话，我自己都没有发大财，所以我的建议只是让人快乐工作的建议，不是如何发大财的建议，我们只讨论一般普通打工者的情况。我认为选择什么行业并没有太大关系，看问题不能只看眼前。比如，从前年开始，国家开始整顿医疗行业，很多医药公司开不下去，很多医药行业的销售开始转行。其实医药行业的不景气是针对所有公司的，并非针对一家公司，大家的日子都不好过，这个时候跑掉是非常不划算的，大多数正规的医药公司即使不做新生意撑个两三年总是能撑的，大多数医药销售靠工资撑个两三年也是可以撑的，国家不可能永远捏着医药行业不放的，两三年以后光景总归还会好起来的，那个时候别人都跑了而你没跑，那时的日子应该会好过很多。有的时候觉得自己这个行业不行了，问题是，再不行的行业，做得人少了也变成了好行业，当大家都觉得不好的时候，往往却是最好的时候。大家都觉得金融行业好，金融行业门槛高不说，有多少人削尖脑袋要钻进去，竞争激励，进去以后还要时时提防，一个疏忽，就被后来的人给挤掉了，压力巨大，又如何谈得上快乐？也就未必是“好”工作了。 太阳能这个东西至今还不能进入实际应用的阶段，但是中国已经有7家和太阳能有关的公司在纽交所上市了，国美苏宁永乐其实是贸易型企业，也能上市，鲁泰纺织连续10年利润增长超过50%，卖茶的一茶一座，卖衣服的海澜之家都能上市……其实选什么行业真的不重要，关键是怎么做。事情都是人做出来的，关键是人。 有一点是需要记住的，这个世界上，有史以来直到我们能够预见得到的未来，成功的人总是少数，有钱的人总是少数，大多数人是一般的，普通的，不太成功的。因此，大多数人的做法和看法，往往都不是距离成功最近的做法和看法。因此大多数人说好的东西不见得好，大多数人说不好的东西不见得不好。大多数人都去炒股的时候说明跌只是时间问题，大家越是热情高涨的时候，跌的日子越近。大多数人买房子的时候，房价不会涨，而房价涨的差不多的时候，大多数人才开始买房子。不会有这样一件事情让大家都变成功，发了财，历史上不曾有过，将来也不会发生。有些东西即使一时运气好得到了，还是会在别的时候别的地方失去的。 年轻人在职业生涯的刚开始，尤其要注意的是，要做对的事情，不要让自己今后几十年的人生总是提心吊胆，更不值得为了一份工作赔上自己的青春年华。我的公司是个不行贿的公司，以前很多人不理解，甚至自己的员工也不理解，不过如今，我们是同行中最大的企业，客户乐意和我们打交道，尤其是在国家打击腐败的时候，每个人都知道我们做生意不给钱的名声，都敢于和我们做生意。而勇于给钱的公司，不是倒了，就是跑了，要不就是每天睡不好觉，人还是要看长远一点。很多时候，看起来最近的路，其实是最远的路，看起来最远的路，其实是最近的路。 跟对人是说，入行后要跟个好领导好老师，刚进社会的人做事情往往没有经验，需要有人言传身教。对于一个人的发展来说，一个好领导是非常重要的。所谓“好”的标准，不是他让你少干活多拿钱，而是以下三个。 首先，好领导要有宽广的心胸，如果一个领导每天都会发脾气，那几乎可以肯定他不是个心胸宽广的人，能发脾气的时候却不发脾气的领导，多半是非常厉害的领导。中国人当领导最大的毛病是容忍不了能力比自己强的人，所以常常可以看到的一个现象是，领导很有能力，手下一群庸才或者手下一群闲人。如果看到这样的环境，还是不要去的好。 其次，领导要愿意从下属的角度来思考问题，这一点其实是从面试的时候就能发现的，如果这位领导总是从自己的角度来考虑问题，几乎不听你说什么，这就危险了。从下属的角度来考虑问题并不代表同意下属的说法，但他必须了解下属的立场，下属为什么要这么想，然后他才有办法说服你，只关心自己怎么想的领导往往难以获得下属的信服。 第三，领导敢于承担责任，如果出了问题就把责任往下推，有了功劳就往自己身上揽，这样的领导不跟也罢。选择领导，要选择关键时刻能抗得住的领导，能够为下属的错误买单的领导，因为这是他作为领导的责任。 有可能，你碰不到好领导，因为，中国的领导往往是屁股决定脑袋的领导，因为他坐领导的位置，所以他的话就比较有道理，这是传统观念官本位的误区，可能有大量的这种无知无能的领导，只是，这对于你其实是好事，如果将来有一天你要超过他，你希望他比较聪明还是比较笨？相对来说这样的领导其实不难搞定，只是你要把自己的身段放下来而已。多认识一些人，多和比自己强的人打交道，同样能找到好的老师，不要和一群同样郁闷的人一起控诉社会，控诉老板，这帮不上你，只会让你更消极。和那些比你强的人打交道，看他们是怎么想的，怎么做的，学习他们，然后跟更强的人打交道。 选择 我们每天做的最多的事情，其实是选择，因此在谈职业生涯的时候不得不提到这个话题。 我始终认为，在很大的范围内，我们究竟会成为一个什么样的人，决定权在我们自己，每天我们都在做各种各样的选择，我可以不去写这篇文章，去别人的帖子拍拍砖头，也可以写下这些文字，帮助别人的同时也整理自己的思路，我可以多注意下格式让别人易于阅读，也可以写成一堆，我可以就这样发上来，也可以在发以前再看几遍，你可以选择不刮胡子就去面试，也可以选择出门前照照镜子……每天，每一刻我们都在做这样那样的决定，我们可以漫不经心，也可以多花些心思，成千上万的小选择累计起来，就决定了最终我们是个什么样的人。 从某种意义上来说我们的未来不是别人给的，是我们自己选择的，很多人会说我命苦啊，没得选择阿，如果你认为“去微软还是去IBM”“上清华还是上北大”“当销售副总还是当厂长”这种才叫选择的话，的确你没有什么选择，大多数人都没有什么选择。但每天你都可以选择是否为客户服务更周到一些，是否对同事更耐心一些，是否把工作做得更细致一些，是否把情况了解得更清楚一些，是否把不清楚的问题再弄清楚一些……你也可以选择在是否在痛苦中继续坚持，是否抛弃掉自己的那些负面的想法，是否原谅一个人的错误，是否相信我在这里写下的这些话，是否不要再犯同样的错误……生活每天都在给你选择的机会，每天都在给你改变自己人生的机会，你可以选择赖在地上撒泼打滚，也可以选择咬牙站起来。你永远都有选择。有些选择不是立杆见影的，需要累积，比如农民可以选择自己常常去浇地，也可以选择让老天去浇地，诚然你今天浇水下去苗不见得今天马上就长出来，但常常浇水，大部分苗终究会长出来的，如果你不浇，收成一定很糟糕。 每天生活都在给你机会，他不会给你一叠现金也不会拱手送你个好工作，但实际上，他还是在给你机会。我的家庭是一个普通的家庭，没有任何了不起的社会关系，我的父亲在大学毕业以后就被分配到了边疆，那个小县城只有一条马路，他们那一代人其实比我们更有理由抱怨，他们什么也没得到，年轻的时候文化大革命，书都没得读，支援边疆插队落户，等到老了，却要给年轻人机会了。他有足够的理由象成千上万那样的青年一样坐在那里抱怨生不逢时，怨气冲天。然而在分配到边疆的十年之后，国家恢复招研究生，他考回了原来的学校。研究生毕业，他被分配到了安徽一家小单位里，又是3年以后，国家第一届招收博士生，他又考回了原来的学校，成为中国第一代博士，那时的他比现在的我年纪还大。生活并没有放弃他，他也没有放弃生活。10年的等待，他做了他自己的选择，他没有放弃，他没有破罐子破摔，所以时机到来的时候，他改变了自己的人生。你最终会成为什么样的人，就决定在你的每个小小的选择之间。 你选择相信什么？你选择和谁交朋友？你选择做什么？你选择怎么做？……我们面临太多的选择，而这些选择当中，意识形态层面的选择又远比客观条件的选择来得重要得多，比如选择做什么产品其实并不那么重要，而选择怎么做才重要。选择用什么人并不重要，而选择怎么带这些人才重要。大多数时候选择客观条件并不要紧，大多数关于客观条件的选择并没有对错之分，要紧的是选择怎么做。一个大学生毕业了，他要去微软也好，他要卖猪肉也好，他要创业也好，他要做游戏代练也好，只要不犯法，不害人，都没有什么关系，要紧的是，选择了以后，怎么把事情做好。 除了这些，你还可以选择时间和环境，比如，你可以选择把这辈子最大的困难放在最有体力最有精力的时候，也可以走一步看一步，等到了40岁再说，只是到了40多岁，那正是一辈子最脆弱的时候，上有老下有小，如果在那个时候碰上了职业危机，实在是一件很苦恼的事情。与其如此不如在20多岁30多岁的时候吃点苦，好让自己脆弱的时候活得从容一些。你可以选择在温室里成长，也可以选择到野外磨砺，你可以选择在办公室吹冷气的工作，也可以选择40度的酷热下，去见你的客户，只是，这一切最终会累积起来，引导你到你应得的未来。 我不敢说所有的事情你都有得选择，但是绝大部分事情你有选择，只是往往你不把这当作一种选择。认真对待每一次选择，才会有比较好的未来。 选择职业 职业的选择，总的来说，无非就是销售、市场、客服、物流、行政、人事、财务、技术、管理几个大类，有个有趣的现象就是，500强的CEO当中最多的是销售出身，第二多的人是财务出身，这两者加起来大概超过95%。现代IT行业也有技术出身成为老板的，但实际上，后来他们还是从事了很多销售和市场的工作，并且表现出色，公司才获得了成功，完全靠技术能力成为公司老板的，几乎没有。这是有原因的，因为销售就是一门跟人打交道的学问，而管理其实也是跟人打交道的学问，这两者之中有很多相通的东西，他们的共同目标就是“让别人去做某件特定的事情。”而财务则是从数字的层面了解生意的本质，从宏观上看待生意的本质，对于一个生意是否挣钱，是否可以正常运作有着最深刻的认识。 公司小的时候是销售主导公司，而公司大的时候是财务主导公司，销售的局限性在于只看人情不看数字，财务的局限性在于只看数字不看人情。公司初期，运营成本低，有订单就活得下去，跟客户也没有什么谈判的条件，别人肯给生意做已经谢天谢地了，这个时候订单压倒一切，客户的要求压倒一切，所以当然要顾人情。公司大了以后，一切都要规范化，免得因为不规范引起一些不必要的风险，同时运营成本也变高，必须提高利润率，把有限的资金放到最有产出的地方。对于上市公司来说，股东才不管你客户是不是最近出国，最近是不是那个省又在搞严打，到了时候就要把业绩拿出来，拿不出来就抛股票，这个时候就是数字压倒一切。 前两天听到有人说一句话觉得很有道理，开始的时候我们想“能做什么？”，等到公司做大了有规模了，我们想“不能做什么。”很多人在工作中觉得为什么领导这么保守，这也不行那也不行，错过很多机会。很多时候是因为，你还年轻，你想的是“能做什么”，而作为公司领导要考虑的方面很多，他比较关心“不能做什么”。 我并非鼓吹大家都去做销售或者财务，究竟选择什么样的职业，和你究竟要选择什么样的人生有关系，有些人就喜欢下班按时回家，看看书听听音乐，那也挺好，但就不适合找个销售的工作了，否则会是折磨自己。有些人就喜欢出风头，喜欢成为一群人的中心，如果选择做财务工作，大概也干不久，因为一般老板不喜欢财务太积极，也不喜欢财务话太多。先想好自己要过怎样的人生，再决定要找什么样的职业。有很多的不快乐，其实是源自不满足，而不满足，很多时候是源自于心不定，而心不定则是因为不清楚究竟自己要什么，不清楚要什么的结果就是什么都想要，结果什么都没得到。 我想，我们还是因为生活而工作，不是因为工作而生活，生活是最要紧的，工作只是生活中的一部分。我总是觉得生活的各方方面都是相互影响的，如果生活本身一团乱麻，工作也不会顺利。所以要有娱乐、要有社交、要锻炼身体，要有和睦的家庭……最要紧的，要开心，我的两个销售找我聊天，一肚子苦水，我问他们，2年以前，你什么都没有，工资不高，没有客户关系，没有业绩，处于被开的边缘，现在的你比那时条件好了很多，为什么现在却更加不开心了？如果你做得越好越不开心，那你为什么还要工作？首先的首先，人还是要让自己高兴起来，让自己心态好起来，这种发自内心的改变会让你更有耐心，更有信心，更有气质，更能包容……否则，看看镜子里的你，你满意么？ 有人会说，你说得容易，我每天加班，不加班老板就会把我炒掉，每天累得要死，哪有时间娱乐、社交、锻炼？那是人们把目标设定太高的缘故，如果你还在动不动就会被老板炒掉的边缘，那么你当然不能设立太高的目标，难道你还想每天去打高尔夫？你没时间去健身房锻炼身体，但是上下班的时候多走几步可以吧，有楼梯的时候走走楼梯不走电梯可以吧？办公的间隙扭扭脖子拉拉肩膀做做俯卧撑可以吧？谁规定锻炼就一定要拿出每天2个小时去健身房？你没时间社交，每月参加郊游一次可以吧，周末去参加个什么音乐班，绘画班之类的可以吧，去尝试认识一些同行，和他们找机会交流交流可以吧？开始的时候总是有些难的，但迈出这一步就会向良性循环的方向发展。而每天工作得很苦闷，剩下的时间用来咀嚼苦闷，只会陷入恶性循环，让生活更加糟糕。 孙振耀撰文谈退休并畅谈人生 虽然离开惠普仅有十五天，但感觉上惠普已经离我很远。我的心思更多放在规划自己第二阶段的人生，这并非代表我对惠普没有任何眷恋，主要还是想以此驱动自己往前走。 万科王石登珠穆朗玛峰的体验给我很多启发，虽然在出发时携带大量的物资，但是登顶的过程中，必须不断减轻负荷，最终只有一个氧气瓶和他登上峰顶。登山如此，漫长的人生又何尝不是。 我宣布退休后，接到同事朋友同学的祝贺。大部分人都认为我能够在这样的职位上及年龄选择退休，是一种勇气，也是一种福气。 还有一部分人怀疑我只是借此机会换个工作，当然还有一些人说我在HP做不下去了，趁此机会离开。 我多年来已经习惯别人对我的说三道四，但对于好友，我还是挺关心大家是否真正理解我的想法，这也是写这篇文章的目的。 由于受我父亲早逝的影响，我很早就下定决心，要在有生之年实现自己的愿望，我不要像我父亲一样，为家庭生活忙碌一辈子，临终前感伤，懊恼自己有很多没有实现的理想。 一本杂志的文章提到我们在生前就应该思考自己的墓志铭，因为那代表你自己对完美人生的定义，我们应该尽可能在有生之年去实现它。 我希望我的墓志铭上除了与家人及好友有关的内容外，是这样写着： 1.这个人曾经服务于一家全球最大的IT公司(HP)25年，和她一起经历过数次重大的变革，看着她从以电子仪表为主要的业务变革成全球最大的IT公司。 2.这个人曾经在全球发展最快的国家(中国)工作16年，并担任HP中国区总裁7年，见证及经历过中国改革开放的关键 最新突破阶段，与中国一起成长。 3.这个人热爱飞行，曾经是一个有执照的飞行员，累积飞行时数超过X小时，曾经在X个机场起降过。 4. 这个人曾经获得管理硕士学位，在领导管理上特别关注中国企业的组织行为及绩效，并且在这个领域上获得中国企业界的认可。 我费时25年才总结1和2两项成果，我不知还要费时多久才能达成3和4的愿望，特别是第4个愿望需要经历学术的训练，才能将我的经验总结成知识。 否则我的经验将无法有效影响及传授他人。因此重新进入学校学习，拿一个管理学位是有必要的，更何况这是我一个非常重要的愿望。 另一方面，我25年的时间都花在运营(operation) 的领域，兢兢业业的做好职业人士的工作，它是一份好工作，特别是在HP，这份工作也帮助我建立财务的基础，支持家庭的发展。 但是我不想终其一生，都陷入在运营的领域，我想象企业家一样，有机会靠一些点子 (ideas)赚钱，虽然风险很高，但是值得一试，即使失败，也不枉走一回，这也是第4个愿望其中的一部份。 Carly Fiorina 曾经对我说过“这个世界上有好想法的人很多，但有能力去实现的人很少”，2007 年5月21日在北大演讲时，有人问起那些书对我影响较大，我想对我人生观有影响的其中一本书叫“Trigger Point”，它的主要观点是：人生最需要的不是规划，而是在适当的时机掌握机会，采取行动。 我这些愿望在我心中已经酝酿一段很长的时间，开始的时候，也许一年想个一两次，过了也就忘掉，但逐渐的，这个心中的声音，愈来愈大，出现的频率也愈来愈高，当它几乎每一个星期都会来与我对话时，我知道时机已经成熟。 但和任何人一样，要丢掉自己现在所拥有的，所熟悉的环境及稳定的收入，转到一条自己未曾经历过，存在未知风险的道路，需要绝大的勇气，家人的支持和好友的鼓励。有舍才有得，真是知易行难，我很高兴自己终于跨出了第一步。 我要感谢HP的EER提前退休优惠政策，它是其中一个关键的Trigger Points,另一个关键因素是在去年五六月发生的事。 当时我家老大从大学毕业，老二从高中毕业，在他们继续工作及求学前，这是一个黄金时段，让我们全家可以相聚一段较长的时间，我为此很早就计划休一个长假，带着他们到各地游玩。 但这个计划因为工作上一件重要的事情(Mark Hurd 访华)不得不取消。这个事件刺激了我必须严肃的去对待那心中的声音，我会不会继续不断的错失很多关键的机会? 我已经年过50，我会不会走向和我父亲一样的道路？人事部老总Charles跟我说，很多人在所有对他有利的星星都排成一列时，还是错失时机。 我知道原因，因为割舍及改变对人是多么的困难，我相信大部分的人都有自己人生的理想，但我也相信很多人最终只是把这些理想当成是 幻想，然后不断的为自己寻找不能实现的藉口，南非前总统曼德拉曾经说过，“与改变世界相比，改变自己更困难”，真是一针见血。 什么是快乐及有意义的人生？我相信每一个人的定义都不一样，对我来说，能实现我墓志铭上的内容就是我的定义。 在中国惠普总裁的位置上固然可以吸引很多的关注及眼球，但是我太太及较亲近的好友，都知道那不是我追求的，那只是为扮演好这个角色必须尽力做好的地方。 做一个没有名片的人士，虽然只有十多天的时间，但我发现我的脑袋里已经空出很多空间及能量，让我可以静心的为我Chapter II的新生活做细致的调研及规划。 我预订以两年的时间来完成转轨的准备工作，并且花多点时间与家人共处。这两年的时间我希望拿到飞行执照，拿到管理有关的硕士学位，提升英文的水平，建立新的网络，多认识不同行业的人，保持与大陆的联系。希望两年后，我可以顺利回到大陆去实现我第四个愿望。 毫不意外，在生活上，我发现很多需要调整的地方。 二十多年来，我生活的步调及节奏，几乎完全被公司及工作所左右，不断涌出的deadline及任务驱动我每天的安排，一旦离开这样的环境，第一个需要调整的就是要依靠自己的自律及意志力来驱动每天的活动，睡觉睡到自然醒的态度绝对不正确，放松自己，不给事情设定目标及时间表，或者对错失时间目标无所谓，也不正确，没有年度，季度，月及周计划也不正确。 担任高层经理多年，已经养成交待事情的习惯，自己的时间主要花在思考，决策及追踪项目的进展情况，更多是依靠一个庞大的团队来执行具体的事项及秘书来处理很多协调及繁琐的事情。 到美国后，很多事情需要打800号电话联系，但这些电话很忙，常让你在waiting line上等待很长的时间，当我在等待时，我可以体会以前秘书工作辛苦的地方，但同时也提醒我自己，在这个阶段要改变态度，培养更大的耐性及自己动手做的能力。 生活的内容也要做出很大的调整，多出时间锻炼身体，多出时间关注家人，多出时间关注朋友，多出时间体验不同的休闲活动及飞行，一步步的，希望生活逐步调整到我所期望的轨道上，期待这两年的生活既充实又充满乐趣及意义。 第一个快乐的体验就是准备及参加大儿子的订婚礼，那种全心投入，不需担忧工作数字的感觉真好。同时我也租好了公寓，买好了家具及车子，陪家人在周末的时候到Reno 及Lake Tahoe玩了一趟，Lake Tahoe我去了多次，但这次的体验有所不同，我从心里欣赏到它的美丽。 但同时我也在加紧调研的工作，为申请大学及飞行学校做准备，这段时间也和在硅谷的朋友及一些风险投资公司见面，了解不同的产业。 我的人生观是“完美的演出来自充分的准备”，“勇于改变自己，适应不断变化的环境，机会将不断出现”，“快乐及有意义的人生来自于实现自己心中的愿望，而非外在的掌声”。 我离开时，有两位好朋友送给我两个不同的祝语，Baron的是“多年功过化烟尘”，杨华的是“莫春者，风乎舞雩，咏而归”，它们分别代表了我离开惠普及走向未来的心情。 我总结人生有三个阶段，一个阶段是为现实找一份工作，一个阶段是为现实，但可以选择一份自己愿意投入的工作，一个阶段是为理想去做一些事情。 我珍惜我的福气，感激HP及同事、好朋友给我的支持，鼓励及协助，这篇文字化我心声的文章与好友分享。","tags":[{"name":"孙振耀","slug":"孙振耀","permalink":"http://yoursite.com/tags/孙振耀/"},{"name":"工作与生活","slug":"工作与生活","permalink":"http://yoursite.com/tags/工作与生活/"}]},{"title":"大型网站中常用的缓存类型","date":"2018-12-17T15:53:13.312Z","path":"2018/12/17/大型网站中常用的缓存类型/","text":"网站性能优化第一定律：首选使用缓存优化性能。 1. 为什么要用缓存？ 使用缓存的目的有两种：提高响应速度和降低后端压力。缓存可有效缩短数据传输，降低带宽要求，显著提高响应速度。对于后端服务和存储层而言，可以有效隔离热点流量，防止流量并发造成的冲击。 鉴于缓存的两个目的，缓存层通常置于离需求方最近的位置，当终端用户是需求方时，缓存要尽量接近终端用户；当应用程序是需求方时，缓存要接近应用程序。 2. 什么样的内容可以缓存？ 既然是缓存，那一定是不能每次都获取实时计算的结果，即变动不频繁的资源。Web网站中通常使用缓存的有静态文件（图片、css、js、HTML、文档）、接口计算结果、数据库中的热点数据。 这些缓存数据的共同特点是更新不频繁，访问频繁。 3. 缓存有哪几类？适用于什么场景？ 上图是一个请求从浏览器到服务端的访问简图。图上的每个环节都可能设置缓存。按照请求的访问顺序，缓存可以分为： 浏览器缓存 CDN缓存 反向代理缓存 应用缓存 本地缓存 分布式缓存 数据库缓存 数据库中间件缓存 数据库缓存 3.1 浏览器缓存 应用场景：图片、css、文档、js等更新较少、体积较大、访问频繁的静态资源文件。 这些资源每次页面访问都需要获取，如果每次都从服务器获取，势必会占用大量带宽且响应缓慢。可以将这些资源存放到用户浏览器缓存中，通过在HTTP头中设置Cache-Control和Expires来开启缓存和缓存有效期。 需要更新某些资源时，通过修改资源名称的方法。建议不要一次性更新所有资源，而是逐步更新，避免造成拥堵，影响体验。 3.2 CDN 应用场景：图片、css、文档、js、html等更新较少、体积较大、访问频繁的静态资源文件。 CDN通常部署在各运营商的机房，在请求路由中是距离用户最近的服务，而且由于它部署在各地运营商的机房，用户可以直接从距离自己最近的运营商机房中获取资源，因此访问速度非常快。它由专门的网络服务提供商运营。 3.3 反向代理 应用场景：体积较小的静态资源，比如css、js、图片、html。还有变动不频繁的接口返回的数据类响应消息，比如某些词条、帖子内容等。 反向代理属于服务端设备，通常位于应用服务的机房内，属于应用的第一层服务。它可以将内部服务与外部进行隔离，保护服务安全，同时可以提供一部分缓存服务。 反向代理中的缓存资源可以通过消息通知机制进行更新，也可以与redis等缓存数据库配合通过缓存数据库的数据过期机制进行清理。 常用的反向代理软件有：Nginx、Varnish、Squid 3.4 应用缓存 应用缓存分为本地缓存和分布式缓存。 本地缓存 应用场景：占用空间小的少量数据，比如系统运行参数、全局统一配置等。 本地缓存就是在应用进行的内存中存放的数据，比如使用MAP、List等java容器存放数据或者使用开源中间件。特点是数据量小，占空间不大，不需要共享。 本地缓存可以直接通过编码实现或者采用中间件。常用的中间件有：Guava Cache、Ehcache。 分布式缓存 应用场景：数据量大、占用空间大、变动不频繁、访问频繁，需要共享的资源，比如电商系统中的购物车数据、库存数据。 分布式缓存主要针对读写频繁，并发量大的资源，一般采用KV的方式存储。业界的使用方式基本遵循二八定律，也多是用于存放20%的热点数据。分布式缓存涉及到数据的共享、同步、并发、持久化等问题，因此基本采用成熟专业的中间件。常用的中间件有：redis、Memcached及企业级的Jboss cache、OSCache等。 3.5 数据库缓存 数据库缓存包括数据库自身缓存和数据库中间件缓存。 数据库自身缓存 应用场景：数据库自带技能，用于高速查询，默认开启。 业界常用的mysql、oracle等数据库的存储引擎自身都带有缓存特性，对查询条件固定、查询频繁的检索结果进行缓存。如mysql的一二级缓存机制和Oracle的高速缓存机制。 数据库中间件缓存 应用场景：数据库中间件自带技能，缓存查询结果。 业界常用的mybatis、ibatis等数据库中间件自身也带有缓存功能，可以将数据库的查询结果保存到内存中，当相同条件的查询时，不需要再访问数据库。","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"大型网站","slug":"大型网站","permalink":"http://yoursite.com/tags/大型网站/"},{"name":"高性能","slug":"高性能","permalink":"http://yoursite.com/tags/高性能/"}]},{"title":"Web安全之ReDOS攻击","date":"2018-12-16T10:31:55.491Z","path":"2018/12/16/Web安全之ReDOS攻击/","text":"正则表达式 正则表达式（regular expression）又称为规则表达式，就是用一个“字符串”来描述一个特征，然后去检索、替换另一个符合这个特征“字符串”。 正则表达式引擎分类 正则表达式引擎分为两类：NFA和DFA。 NFA：匹配过程面临很多的岔路，需要做出选择，一旦某条岔路失败，就需要回朔。类似于回溯法。执行复杂度最大为O（2^n)。 DFA：匹配过程是确定的，每个字母需要匹配一次。长度为n的正则表达式执行复杂度为O（2^n),长度为n的字符串，执行复杂度为O（n） 构造DFA的代价远大于NFA，假设NFA的状态数为K，那么等价DFA的状态数目理论上可达2的k次方，不过实际上几乎不会出现这么极端的情况，可以肯定的是构造DFA会消耗更多的时间和内存。 但是DFA一旦构造好了之后，执行效率就非常理想，如果一个串的长度是n，那么匹配算法的执行复杂度是O(n);而NFA在匹配过程中，存在大量的分支和回朔，假设NFA的状态数为s，因为每输入一个字符可能达到的状态数做多为s，那么匹配算法的复杂度及时输入串的长度乘以状态数O(ns)。NFA所支持的高级特性比DFA要多，所以NFA常被使用。 Redos攻击 ReDoS(Regular expression Denial of Service) 正则表达式拒绝服务攻击。应用程序使用正则表达式对用户输入的数据进行有效性校验, 当正则表达式存在缺陷或者不严谨时, 攻击者可以通过构造特殊的字符串大量消耗服务器的系统资源，造成服务器的服务中断或停止。 不论是DFA还是NFA引擎，极端情况下执行复杂度可能达到O(2^n),这就会导致执行正则教研的线程执行缓慢并占用大量CPU资源，有时可能会将CPU耗尽。 实例 正则表达式^(a+)+$的回溯匹配算法： 对于aaaab，存在16种可能的路径（2^4），但是对于aaaaaaaaaaaaaaaab，则存在65536种可能的路径（2^16）。 通过https://regex101.com/ 网站进行测试： 1) 测试字符串aaaab 经过54步，耗时1ms。 2) 测试字符串aaaaab 经过103步，耗时1ms 3) 测试字符串aaaaaaaaaaaaaab 经过49168步，耗时114ms。 什么样的正则表达式易受攻击 重复分组 重复分组内存在: 重复 交叉重叠 样例： (a+)+ ([a-zA-Z]+)* (a|aa)+ (a|a?)+ (.*a){x} | for x &gt; 10 哪些环节易受攻击 理论上网络系统的每一个环节都有正则表达式的存在，因此都有可能受到ReDos攻击。但实际上，黑客攻击自己的浏览器是没有意义的，因此除浏览器外使用正则表达式验证用户输入的其他设备上都应该经过准确的验证。 如何测试 使用微软测试工具Microsoft SDL Regex Fuzzer，测试^(a+)+$，测试结果是Failed。点击下载。 如何防范 Redos攻击很难完全消除，只能尽可能降低这种风险。常用的措施有： 尽量明确不可信输入的字符串长度。 避免使用分组、重复等。 充分的测试。 完善的性能监控工具。 参考资料： 《精通正则表达式》《编译原理龙书第二版》https://xz.aliyun.com/t/2723#toc-9https://www.regular-expressions.info/catastrophic.htmlhttps://www.andseclab.com/2018/04/19/owasp%E6%B1%89%E5%8C%96%E6%94%BB%E5%87%BB%E7%B3%BB%E5%88%97%E5%A4%A7%E5%85%A8%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1/https://www.freebuf.com/articles/network/124422.html","tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/网络安全/"},{"name":"ReDOS","slug":"ReDOS","permalink":"http://yoursite.com/tags/ReDOS/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"教育培养","date":"2018-12-10T23:32:19.848Z","path":"2018/12/11/教育培养/","text":"最近思考孩子的教育培养，俗话讲“3岁看大，10岁看老”，孩子从小2-3岁开始就需要投入精力培养。 父母是对孩子一生影响最大的人，也是孩子教育的首要责任人。“子不教，父之过”，作为父母，首先要从自身做起，讲十遍不如做一遍，孩子的行为习惯大部分是从父母身上学来的。据我观察，孩子的言行、举止、姿态、表情、性格等与自己的父母神似，这是家庭行为的遗传，当然这个遗传是后天形成的。 对孩子的培养应该从哪几方面入手呢？通过阅读大量的教育、心理、管理学书籍和培训机构的课程内容，总结了最总要的四个方面。 1.树立正确的三观 社会观、人生观、价值观，这三观是人一生的行为指导，会由内而外对人的一生产生影响。具有正确的三观，就有了做人做事的原则，有了自主性，不会随波逐流，遇到挫折和困难时不容易气馁，遇到人生辉煌时，不会骄傲。 什么才是正确的三观？ 首先肯定不是钱和权。不可否认当前社会风气受部分舆论和事件的影响，拜金主义横行，动辄就3个亿的小目标，网红、贪官层出不穷，其实这恰是写反例，出现这些问题的原因就是没有正确的三观。曾遇到一个7岁的小女孩，别人夸她学习成绩好，结果她回了一句“学习成绩好有什么用，不如长得漂亮，以后嫁个好老公”，真的让人瞠目结舌。 中国传统上的正确三观在《论语》、《大学》等著作中都有涉及。《论语》一书中书提到“弟子入则孝，出则悌”、“敏于事而慎于言”、“人而无信，不知其可也。大车无輗，小车无軏，其何以行之哉？”、“礼之用，和为贵”。《大学》强调修身治国平家平天下，“生财有大道。生之者众，食之者寡，为之者疾，用之者舒，则财恒足矣。仁者以财发身，不仁者以身发财。未有上好仁而下不好义者也，未有好义其事不终者也，未有府库财非其财者也。”。这些都是古人对人生价值观的总结，也是中国传统上的价值观，总结一下就是做人要正直诚信、胸怀家国、济世助人。 西方的教育学、心理学著作中对于三观的认识往往最终都归于《圣经》中关于基督信仰的教义，以基督为中心的“爱人如己”、“感恩”、“宽容”、“忍耐”、“万事尽心”等。 2.设定正确的人生目标和理想 具有正确的人生目标和理想，就容易做决断、不会受短期得失的影响。《追梦赤子心》中有句经典台词“有梦想的人才会忍受现实的生活”，有梦想的人会积极向上、受挫力强。马云曾讲过“人是要有理想的，万一实现了呢”，其实有理想的人，即使失败了，在追逐理想的路上所收获的也比旁人要多。当前社会不少大学生，包括名牌大学的学生痴迷游戏、荒废学业或者整日无所事事，这样的学生基本是没有人生理想和目标的孩子，或者只是以考上大学为理想的孩子，进入大学后迷失了方向。 什么是正确的人生目标和理想呢？ 这当然是因人而异，投身教育事业成为一名优秀的老师、研究基础数学成为有贡献的数学家、成为一名画家、投身一个产业做一名对社会有帮助的企业家等等都是正确的理想和目标。 孩子在3-6岁间兴趣爱好往往会不断的变化，父母要随着孩子的兴趣点做好引导，一般在7-12岁就会确立自己的人生目标。 人生目标一旦确立就要向着目标持续不断的努力。目标是可以调整的，但是如果频繁调整目标，那很难在一个领域持续积累取得成就。 3.为人生目标制定实施计划 生于七八十年代的人，在孩童时代绝大部分都有被问到，你长大以后想做什么？那时的回答不外乎科学家、警察、医生、飞行员等等，但是长大后发现，很少有人实现自己的目标。原因有二，一是当时的目标定的很随意，自己对这个目标根本没有概念和正确的认知；二是缺乏实现目标的计划和路标。 有了目标以后需要制定实施的计划，有了计划才能落实。比如最近意外去世的著名华裔物理科学家张首晟，他在初中阶段就对物理特别痴迷，对探究物理世界充满着渴望，内心的目标是希望以后能进入物理研究的最高机构去探究未知的物理世界。所以在后期的学习上，他对物理学知识特别用心，通过进入大学，出国深造等方式最终师从杨振宁，进入物理学研究的最高机构，距自己的目标越来越近。 一个12岁的孩子很难独立制定出自己的计划和路标，这时候就需要父母的帮助。大部分父母可能并没有对应领域的经验，这时候如果有相关领域的朋友，可以向他们寻求帮助，父母先对这个领域有一定的认知。如果没有相关领域的朋友，那可以通过阅读该领域的名人传记，参加该领域的社会活动，参加相关讲座培训等方式。假如孩子喜欢画画，父母可以通过多带孩子参观一些画展、参观博物馆里的名人画作让孩子认识到真正的画作，通过阅读达芬奇等画家传记了解画家的成长经历，通过参加相应级别的书画大赛结识具有相同爱好的群体等方式逐渐使目标清晰。然后针对个人能力和年龄段制定对应的阶段性计划，比如考入知名艺术学院进修、师从当代的著名画家学习等。 计划是需要调整的，不同的人不同的阶段都会遇到不同的情况，需要根据情况及时调整。 4.基于正确的三观，提供常规训练（情商、思维、技能） 正确的三观是基础，人生目标是灯塔，还需要具备一定的常规技能才能逐步接近并实现目标。这当中最重要的当属情商、思维方式，其次才是技能知识。 情商。好的情商一定是建立在正确的三观之上的，一个人是钱本位的，很难有高的情商，短期内可能表现很好，但是当他的目的一旦达成或者长期相处，必定会暴露出本性，因为他的表现是利益驱动。可以说一个具有正确三观的人，情商也不会差。情商的培养和形成同样来源于父母，孩子从小到大一直受父母的言传身教，父母的一言一行就是孩子日后的行为模板。所以父母首先要清楚什么是高情商，高情商的人的行为反应是什么样子的，然后在孩子面前表演出来，甚至刻意设置一些场景去不断地训练孩子。所谓的遗传，不过就是家庭行为的遗传。 思维方式。思维方式是一个人遇到问题时的应对思路，人做事的能力差距就体现在思维方式。思维方式形成从3-6岁开始，中学阶段逐步成型，如果能进入大学，在大学阶段往往会有一次飞跃。但是优秀的思维并不是自己形成的，也需要学习和训练。优秀思维方式的来源于周边的人和自我学习。社会中有一个现象，一个企业或者政府部门的接班人基本来自负责人身边，比如秘书、顾问、助理等群体，因为这些人往往与领导者相处更多，学到了领导者的思维方式，可以站的高看得更远。想做什么样的事，就要用什么样的思维。如果没有这样的机会，就需要多都一些有关思维的经典著作。另外一个很有效的方面是数学，很多企业的高管在总结自己的人生经历时，不约而同的会提到数据对个人思维能力的重要作用，这里的数学指的是高等数学，这也是为什么大学阶段会是思维方式的一个飞跃阶段。这里给小学初中的孩子们推荐几本书《名人集》、《少年大学生的足迹》可以激发孩子们对科学的热情和奋斗的激情，数学家和教育家波利亚的《怎样解题》可以极大提升逻辑思维能力。孩子们多读一些理论性的书籍可以及早的提高思维层次。 技能。技能就是以后用来在社会上立足的工具。这个工具当然是跟人生的目标相关，也应该是跟兴趣相关。接着前面的例子，爱好是画画，人生的目标是成为一名优秀的画家，那么画功和对艺术的认知就是技能了。这里不得不提一个跨时代的名人——史蒂夫·乔布斯，乔布斯因为贫苦和兴趣问题大学并没有毕业，但是他爱好书法，常常去大学旁听这门课程，也正是这么课程激发了他的艺术细胞，在最初的Apple公司的微机上，他设计出漂亮的界面风格，再后来，Apple公司的所有产品都具有强烈的时尚感和艺术感，也因此受到高端消费者的青睐。 除了专业上的技能，再次不得不强调数学的重要性，对数学的学习能使人形成更高层次的逻辑思维能力。其次是语言文字能力，语言文字能力体现在写作和表达上，如果想成为一个有影响力的人，必须能用语言和文字正确的表达自己的思想。 性格决定命运，有人觉得很空洞，性格实际上是做事风格和习惯，决定命运的是习惯。勤奋、努力、吃苦耐劳、永不气馁是品格，也是一个人长期形成的行为习惯，好习惯能支撑人的一生，同样坏习惯也会影响人的一生。孩子在成长过程中，父母一定要对孩子的好习惯加以肯定和引导，避免坏习惯。","tags":[{"name":"教育","slug":"教育","permalink":"http://yoursite.com/tags/教育/"}]},{"title":"分布式缓存策略","date":"2018-12-09T15:52:23.740Z","path":"2018/12/09/分布式缓存策略/","text":"互联网技术的发展遵循的一个基本原则：时间换空间或者空间换时间。 缓存就是将数据存放在距离计算最快的地方，以加快处理速度。缓存也能有效隔离前端请求压力的传递，降低后端负载。然而事物都具有两面性，缓存层的加入往往会增加系统复杂性，增大系统维护的难度。因此是否设置缓存层往往需要权衡利弊，考虑缓存层会带来问题，如： 更新策略 缓存粒度控制 缓存击穿 缓存雪崩 无底洞问题 热点数据优化 1. 缓存的利与弊1.1 利： 提高响应速度。缓存通常会更靠近需求端（CDN、反向代理）或者完全基于内存（redis、memcache）以加速读写性能，优化用户体验。 降低后端负载。比如在数据库Mysql、Oracle前设置一层本地缓存或者redis缓存，可以有效减少对数据库的压力。 1.2 弊 提高代码维护成本。增加缓存后，需要同时维护缓存与持久层的业务逻辑。 数据一致性弱化。仅能保证最终一致性，无法实现强一致性。 增加运维成本。增加了CDN、Memcache、redis等缓存中间件后不可避免的会增加系统复杂度。 2. 缓存使用的前提与场景2.1 使用前提 数据访问不均衡，存在热点数据，热点数据可以存放在缓存中。 数据具有一定的有效时长，不会很快失效。 2.2 使用场景 需要快速响应的场景：比如涉及到大量图片的访问时，因为图片占用带宽，往往会选用CDN。对数据访问速度有要求的场景可以选用redis等缓存中间件或者本地缓存。 并发高的场景。抢购、促销等活动时，往往瞬间请求量很大，为了降低后端压力，可以将库存等热点数据放到缓存中，降低流量对后端数据库的冲击。 3. 更新策略 缓存中的数据一般是由生效时间的，除非把具有持久化功能的缓存当做数据库使用。常用的缓存更新策略主要有几种，具体选用哪种策略，需要根据业务场景对一致性的要求进行选择。 3.1 LRU/LFU/FIFO算法剔除。 这些剔除算法执行自动更新策略，认为干预少，数据一致性差。 3.2 超时剔除。 缓存中的数据都设置一个过期时间，使用缓存中的数据时，每次都判断数据是否过期，如果过期，重新从数据源获取。如果数据源数据被更改而缓存数据未过期，此时会存在不一致的问题。 3.3 主动更新。 数据源的数据被改动时，主动推送到缓存来更新数据。这种方式数据一致性会非常好。为了保证可靠性，这种方式往往也会设置过期时间，如果过期后未被更新，则需要主动从数据源获取。 4.缓存粒度控制 缓存粒度就是在做缓存层时，需要考虑缓存的数据范围。缓存全部数据？缓存部分数据的部分字段？一般缓存层是用来缓存热点数据。 为何要考虑缓存粒度？因为做缓存的过程是会占用空间和时间的，缓存数据量大时，会占用大量内存，缓存更新的过程也会更频繁，缓存过程更耗时。而如果仅仅缓存部分数据的部分字段，如果数据字段有变动，代码就需要及时更新。因此要根据具体使用情况来确定粒度。 在实践中商城的购物车往往对数据的准确性并不敏感，此时可选用具有持久化功能的全缓存数据库替代mysql等数据源。 5.缓存穿透 缓存穿透是指查询一个根本不存在的数据（一般为非热点数据），在缓存层和数据持久层都不会被命中。这种请求的特点是每次都会经过缓存层再到数据源，这会导致流量直接冲击到后端数据源。 如果出现大量的缓存穿透也会造成很大的问题，比如数据源并发量过大响应超时、宕机等。 如何避免？ 5.1 将空对象缓存。 将空对象做缓存会将请求隔离到缓存层，避免对后端的冲击，但是如果缓存失效前，存储层数据被添加，此时会存在数据不一致的问题。建议超时时间设置短一点。 5.2 布隆过滤器 将持久层拥有的数据的逐渐集合存设置到缓存中，如果在缓存中获取数据失败，则先查询缓存中的主键集合，如果集合中不存在该数据主键，则不需要再到持久层查询数据。这种方式代码会比较复杂。 布隆过滤器相关知识布隆过滤器开源代码 6. 无底洞问题 分布式缓存架构中，当缓存数据过多时，被划分成多个缓存节点。当缓存节点达到一定的数量时，如果继续增加节点可能会导致一次业务需要请求多个节点的缓存数据（典型的如批量数据操作），反而导致性能降低。也就是节点多，不一定性能好。 出现这个现象的原因是键值数据一般会采用哈希函数将key置于不同的节点上，这种哈希分配与业务无关，当一个业务需要批量操作数据时，可能要跨多个节点，这就涉及到多个网络操作，造成耗时增多。 如何避免无底洞问题？当数据量庞大时，必然会造成节点数增多，这种情况无法避免，但是可以采取措施，降低无底洞问题造成的影响。 并行操作。在批量处理数据时采用多线程并行，虽然网络访问次数未改变，但总耗时降低。 分业务存放数据。使用缓存中间件的现有功能，比如redis的hashtag功能，将业务相关的数据放到一个节点下。但是这种方法会造成业务数据分布不均，另外数据分布与业务强相关会造成维护成本提高。 7. 缓存雪崩 缓存层宕掉后，流量会集中涌向后端存储层，导致存储层调用量暴增。如何避免出现缓存雪崩？ 提高缓存层可用性。比如主从缓存架构，灾备部署等，redis的Sentinel和Cluster功能等。 缓存降级或者隔离。当缓存层出现故障时，做降级处理或者对不同的重要数据做好依赖隔离，避免一种数据出现问题影响到整个存储层。常用的降级和依赖隔离工具Hystrix。 8. 热点数据更新策略 一般缓存都会设置过期时间，当某一条热点数据失效瞬间，可能会有大量请求来访问，造成否段瞬间负载过大。比如微博系统，宝强事件、小璐事件、丽颖结婚官宣等都造成了微博的瞬间不可用，除此之外还有电商网站的抢购活动，比如淘宝双十一、小米抢购等都可能出现这种问题。 系统该如何避免这种情况的出现呢？ 重建线程互斥。当热点数据失效时，只允许一个请求线程去后端存储层获取数据，其他线程等待（设定等待超时时间）或直接返回（一般会采用后者），避免所有请求都到后端 过期前主动更新。这种方式可以完全避免数据失效对后端带来的冲击，实现简单，但处理不好可能会出现线程间的调度问题。 永不过期的缓存数据。设立单独的线程，主动检查过期数据，在数据过期前主动进行刷新。这种方式并不能完全避免热点数据失效，因为在刷新线程执行前恰好一条数据出现失效且恰好属于热点数据，这就会出现问题，并且这种方法也会增加维护工作量。 除此之外，缓存数据还有一些优秀实践，比如数据预热、不用数据过期时间不同。 数据预热。为防止数据失效，电商抢购等活动开始前可以提前对缓存系统进行预热，通过自动化手段提前发起可控的大量业务请求，刷新缓存中的数据。 设置不同的过期时间。将缓存数据的过期时间打散，避免集中失效时大量请求同时访问后端存储层。","tags":[{"name":"缓存，分布式，高性能","slug":"缓存，分布式，高性能","permalink":"http://yoursite.com/tags/缓存，分布式，高性能/"}]},{"title":"Spring的profile实现多国、多环境打包","date":"2018-12-08T10:28:41.275Z","path":"2018/12/08/Spring的profile实现多国、多环境打包/","text":"全球电商平台因为涉及到用户数据，因此需要在不同地区的机房或者不同区域的公有云上部署。另外还有开发环境、测试环境的区别。都存在不同的配置问题。 解决方法有两种：1）不同的环境打不同的安装包。2）不同的环境打相同的安装包，但不同的环境所加载的配置不同。 这两种方式我们都有使用，因为需要支撑全球，如果按照第一种方式，同一个版本需要打十几个包，造成安装包泛滥，后期容器化后又要出不同的镜像。后来改用第二种方式，所有国家和环境使用同一个安装包，不同的国家激活不同的profile，激活方式使用系统环境变量的方法，同时将配置文件提取出来使用配置中心管理，安装包归一化。 Spring profile的配置方式可参考https://www.baeldung.com/spring-profileshttps://www.cnblogs.com/strugglion/p/7091021.htmlhttp://websystique.com/spring/spring-profile-example/","tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"profile","slug":"profile","permalink":"http://yoursite.com/tags/profile/"}]},{"title":"Web.xml中配置spring配置文件","date":"2018-12-08T08:33:33.170Z","path":"2018/12/08/web.xml中配置spring配置文件/","text":"1. web.xml的上下文参数配置方法web.xml介绍请参见Tomcat的web.xml配置。 &lt;context-param&gt; &lt;param-name&gt;webmaster&lt;/param-name&gt; &lt;param-value&gt;myaddress@mycompany.com&lt;/param-value&gt; &lt;description&gt; The EMAIL address of the administrator to whom questions and comments about this application should be addressed. &lt;/description&gt; &lt;/context-param&gt; web.xml中直接配置的上下文变量，可以被本webapp中的所有jsp和servlet调用。代码中可以通过如下代码获取 String value = getServletContext().getInitParameter(&quot;webmaster&quot;); 2. Spring上下文配置文件在web.xml中的配置方法Tomcat中集成Spring服务，也可以通过web.xml配置完成spring配置文件的加载，即Spring上下文的加载。 首先，需要在web.xml中配置Spring的上下文监听器。当webapp被加载时，将启动Spring的监听器。 &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; Spring上下文加载监听器启动时会读取contextConfigLocation来获取配置文件。1）当web.xml中没有配置contextConfigLocation时，将默认加载/WEB-INF/applicationContext.xml。2）如果web.xml中配置了上下文参数contextConfigLocation，则会加载这个参数指定路径下的文件。在web.xml中可以通过如下配置： &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:**/spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; 3. Spring的contextConfigLocation参数不同配置方式说明contextConfigLocation在web.xml中可以通过指定具体的路径或者class目录下的路径如classpath:和classpath*:两种配置方式，这两种配置方式是指定配置文件的位置信息。配置文件的名称可以使用功能通配符。 classpath：到webapp的class路径中查找找文件。 classpath*：到webapp的class路径及jar文件中(class路径)进行查找。 3.1 指定具体的文件名1) 指定目录下的具体文件。 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 2）class路径下的具体文件 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-base.xml,classpath:spring-datasource.xml&lt;/param-value&gt; &lt;/context-param&gt; 3）指定目录下文件及jar中的配置文件，在哪里找到都可以。 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring-base.xml,classpath:spring-datasource.xml&lt;/param-value&gt; &lt;/context-param&gt; 3.2 使用通配符1）class路径下以spring-或者spring-datasource-开头的xml类型的配置文件 contextConfigLocation classpath:spring-.xml,classpath:spring-datasource-.xml 2）class路径及所有子路径下以spring-或者spring-datasource-开头的xml类型的配置文件 contextConfigLocation classpath:*spring-.xml,classpath:spring-datasource-*.xml 3）class路径下以spring-或者spring-datasource-开头的xml类型的配置文件。注意，使用通配符时，无法匹配jar中的配置文件了，如果需要匹配，只能指定具体的文件名。 &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring-*.xml,classpath:spring-datasource-*.xml&lt;/param-value&gt; &lt;/context-param&gt; 最佳实践： 如果配置内容比较多，建议分不同的配置文件存放。 配置文件较多时，建议统一目录存放。 如果多个配置文件分属不同的功能模块，可以划分配置子目录存放。 如果需要加载的配置文件较多时，建议在web.xml中统一加载为spring-context.xml，将需要加载的配置文件使用Spring配置文件的import方法集中到spring-context.xml中加载。 spring监听器ContextLoaderListener初始化过程可参见https://blog.csdn.net/datoubangzhu/article/details/78856235。","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Linux挂载命令mount用法","date":"2018-12-06T14:28:57.009Z","path":"2018/12/06/Linux挂载命令mount用法/","text":"mount命令用于挂载文件系统到指定的加载点，他可以挂在ext3/vfat/nfs等文件系统。此命令的最常用于挂载cdrom，使我们可以访问cdrom中的数据，因为你将光盘插入cdrom中，Linux并不会自动挂载，必须使用Linux mount命令来手动完成挂载。此外可以挂载其他设备上的共享目录到指定的加载点。本文后者的使用。 1.挂接命令(mount) 语法 mount [-t vfstype] [-o options] device dir -t vfstype 指定文件系统的类型，一般不需要指定，mount 会自动选择正确的类型。 可挂载的文件类型包括：光盘或光盘镜像：iso9660DOS fat16文件系统：msdosWindows 9x fat32文件系统：vfatWindows NT ntfs文件系统：ntfsMount Windows文件网络共享：smbfsUNIX(LINUX) 文件网络共享：nfs -o options 用来描述设备或档案的挂接方式。 loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备iocharset：指定访问文件系统所用字符集 device 要挂接(mount)的设备，共享目录的服务端。 dir 设备在本系统上的挂接点(mount point)。 2.挂载Windows共享目录Linux挂载Windows的共享目录，必须安装samba软件。Windows网络共享核心必须是SMB/CIFS。先将Windows的目录设置为共享（假设ip为10.192.168.32，共享目录为F:/），再在Linux上挂载该Windows共享目录。 2.1 建立本地挂载点(mount point)# mkdir –p /mnt/share 2.2 执行挂载操作，将Windows的共享目录F，挂载到Linux的/mnt/share目录,如此就可以在linux系统上通过/mnt/share来访问windows系统磁盘上的文件了。# mount -t smbfs -o username=admin,password=123 //10.192.168.32/F$ /mnt/share 说明：admin 和 123 是ip地址为10.192.168.32的windows计算机的一个用户名和密码，F$是这台计算机的一个磁盘共享。 3.挂载UNIX系统NFS文件共享Linux(UNIX)系统也有自己的网络共享，那就是NFS(网络文件系统)，下面我们就以SUN Solaris2.8和REDHAT as server 3 为例介绍在linux下如何mount nfs网络共享。在linux客户端挂接(mount)NFS磁盘共享之前，必须先配置好NFS服务端。 3.1 服务端配置（被挂载者） Solaris系统NFS服务端配置方法 1.修改/etc/dfs/dfstab, 增加共享目录 # share -F nfs -o rw /export/home/sunky 2.启动nfs服务 # /etc/init.d/nfs.server start 3.NFS服务启动以后，也可以使用下面的命令增加新的共享 # share /export/home/sunky1 # share /export/home/sunky2 说明：注：/export/home/sunky和/export/home/sunky1是准备共享的目录 linux系统NFS服务端配置方法 1.修改/etc/exports,增加共享目录 /export/home/sharedir1 192.168.0.12(rw) /export/home/sharedir2 *(rw) /export/home/sharedir3 linux-client(rw) 说明： /export/home/sharedir1、sharedir2、sharedir3是准备共享的目录，而有权限挂载这些目录的客户端可以用IP、主机名、正则表达式等方式指定。如192.168.0.12、*、 linux-client是被允许挂接此共享linux客户机的IP地址或主机名。如果使用主机名指定挂载的客户端，需要在/etc/hosts中配置客户端的Ip映射：192.168.0.12 linux-client (rw)是挂载者对本共享目录所拥有的权限。 2.启动与停止NFS服务 /etc/rc.d/init.d/portmap start (在REDHAT中PORTMAP是默认启动的) /etc/rc.d/init.d/nfs start 启动NFS服务 /etc/rc.d/init.d/nfs stop 停止NFS服务 说明：修改/etc/export文件增加新的共享目录时，需要先停止NFS服务，再启动NFS服务才能使新增加的共享起作用。也可以使用命令exportfs -rv达到同样的效果。 3.2 客户端（挂载者）3.2.1 建立本地挂载点(mount point)# mkdir –p /mnt/share 3.2.2执行挂载操作,将主机IP为192.168.5.88的NFS服务端共享目录/export/home/sharedir1挂载到客户端的/mnt/share目录。#mount -t nfs -o rw 192.168.5.88:/export/home/sharedir1 /mnt/share 现在你可以在客户端的/mnt/share目录下操作文件和目录了，而这些文件和目录实际上是在192.168.5.88上的/export/home/sharedir1这个目录中。 4.解除挂载不再使用挂载目录时不能直接删除，因为那样删除的是被挂载的服务端的目录内容。首先应该先解除挂载。 umount /mnt/share 说明：/mnt/share是挂载点（mount point） 参考 《鸟哥的Linux私房菜》http://man.linuxde.net/mounthttps://www.linuxprobe.com/mount-detail-parameters.html","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"mount","slug":"mount","permalink":"http://yoursite.com/tags/mount/"}]},{"title":"Linux环境变量设置","date":"2018-12-05T16:00:06.077Z","path":"2018/12/06/Linux环境变量设置/","text":"操作系统一般都是支持多用户多任务，在操作系统中可以为不同的用户设置不同的环境变量（用户环境变量），也可以为所有用户设置统一的环境变量（系统环境变量）。Linux和windows系统均是如此。 1.Linux下的环境变量Linux的环境变量存在于多个文件中，主要有以下几个文件： 系统环境变量文件/etc/profile和/etc/environment。 用户环境变量文件~/.bash_profile、~/.bash_login和~/.profile。bash的login shell设定只会读取上面三个文件的其中一个， 而读取得顺序则是依照上面的顺序。 1.1 /etc/profile(login shell时读取）用户登录时才会读取的文件，是操作系统获取环境变量时第一个读取的文件。这个文件会主动引用其他的文件/etc/profile.d 、/etc/profile.d/*.sh和/etc/bash.bashrc。因此虽然login时读取文件/etc/profile，实际上获取到的环境变量不止在/etc/profile中。 1.2 /etc/environment用户在登录操作系统之后，操作系统配置环境时所使用的第二个文件。顾名思义，该文件中保存了一系列环境变量，这些变量将对所有的用户和终端起效。 到这一级为止，文件定义的都是系统环境变量，之后的文件都是在定义用户变量。 1.3 ~/.bash_profile (login shell 才会读)~/.bash_profile、~/.bash_login和~/.profile。bash的login shell设定只会读取上面三个文件的其中一个， 而读取得顺序则是依照上面的顺序。在我使用的Ubuntu操作系统中，实际存在的是~/.profile。我们看一下文件的内容： if…then中又判断了第二个文件~/.bashrc是否存在，如果存在就会引用。最后一行，以累加的方式对/etc/profile中设置过的path增加了~/bin等目录作为额外的执行文件存放目录。用户可以将自己建立的执行文件放到这个目录下（不需要再使用绝对路径或者相对路径执行了）。 1.4 ~/.bashrc该文件包含了专用于一个用户的bash的环境信息，每次登录或者新开shell的时候（包括在图形界面下打开新的终端），该文件被读取。该文件只会在新开的终端中起效。原有终端不会受到影响。 1.5 ~/.bash_logout每次退出bash的时候会执行。 1.6 小结login shell的读取顺序： 实线是主流程，虚线是被动应用的配置文件。 2.环境变量的查看方法及相关命令 env查看当前用户的环境变量与常用变量 set查看shell所有变量（环境变量和用户自定义变量） export若不带参数则显示用户变量的shell变量，若带参数，则将该shell参数添加至用户变量。如果在命令行直接使用这个参数设置变量（如export HELLO=”hello”），则变量只对当前shell（BASH）有效（临时的），重新登录后会失效。 source读入环境配置文件的指令。因为/etc/profile和~/.bash_profile在login是才会被读取，因此如果用户修改了这两个文件中的变量后，只能在重新登录后才会生效。此时可以使用source或者小数点加空格将新设置的环境变量读取到shell中。 echo $变量名，查看具体的变量设置。 3.常见的环境变量 PATH：决定了shell将在哪些目录中寻找命令和程序 HOME：当前用户的主目录 MAIL：当前用户的邮件存放目录 SHELL：当前用户用的是那种Shell HISTSIZE：保存历史命令记录的条数 LOGNAME：当前用户的登录名 HOSTNAME：主机的名称。 LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量 PS1：基本提示符，对于root是#，对于普通用户为$，在我手中的ubuntu10.10中则是一个字符串，显示了用户名、系统名和当前目录名在内的信息。 PS2：是附属提示符，默认是”&gt;”。可以修改此环境变量来修改当前的命令符。","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"环境变量","slug":"环境变量","permalink":"http://yoursite.com/tags/环境变量/"}]},{"title":"开源License","date":"2018-11-24T15:40:01.089Z","path":"2018/11/24/开源License/","text":"","tags":[{"name":"开源","slug":"开源","permalink":"http://yoursite.com/tags/开源/"},{"name":"License","slug":"License","permalink":"http://yoursite.com/tags/License/"}]},{"title":"江南白衣的java后端书架【转】","date":"2018-11-18T11:57:26.290Z","path":"2018/11/18/江南白衣的java后端书架【转】/","text":"见书单如面。&nbsp;在这份书单里，我是这么一个同学：关心Java，关心架构，对文字有一定的洁癖；基础知识懂一些，但忙，不会花太多时间来研究算法和OS；需要掌握一个软件时会买一本XX in Action，但不买那种各式安装指南、使用手册的。如果你和我差不多的趣味，那这份书单会适合你。为了避免混淆，书名的颜色分类，红色是种草， 黑色是拔草（至少不适合本文的预设读者）1. 国内一线的书说到大型互联网站的建设，我们在世界上也是一流的，比国外那些咨询师写的更深味其中艰辛。《高可用架构(第一卷)》厚厚的一本，新浪微博TimYang牵头的高可用架构社区，几十个一线实战案例的结集分享，从头看起的话只恨自己时间不够多。《大型网站： 架构演进与性能优化》薄薄的一本，今年新书，淘宝的分布式、无线化、中台化、单元化的历程与优化，同样是满满的一线经验。《大型网站技术架构：核心原理与案例分析》同是淘宝系薄书，如果一个新人进入到大型互联网站，这是最好的入门科书普。《亿级流量网站架构核心技术》京东开涛作品，很多技术掰细了讲，所以也蛮厚的。《京东基础架构建设之路》从早前的.Net，到如今大量自研组件的体系，可以给兄弟单位的基础架构部做参考。《进化 - 运维技术变革与实践探索》赵成的极客时间，印成书了。运维书里难得讲想法而不是工具使用的书：&nbsp;“运维能力是整体技术架构能力的体现，运维层面爆发的故障一定是整体技术架构中存在问题，割裂两者，单纯的看技术架构或运维都是毫无意义的。”&nbsp;极客时间：极客时间是一种新的知识交付模式。为了保持书单的利益无关中立性，就不放二维码了，大家自个上&nbsp;https://time.geekbang.org/&nbsp;《左耳听风》，左耳朵耗子把自己脑子里的东西一股脑地倒了出来，唯一缺点是贵。《从零开始学架构》，互联网架构的基础知识，用来培养新人或者自己查漏补缺。p&gt;拔草：有些书名字蛮吸引，但翻开目录都是各种软件的安装和使用指南。2. 国外互联网架构的书《SRE：Google运维解密》自编广告词：“地球上有这么一个团队，将运维推向极限高度”。SRE的事情，很多是基础架构部的事情。今年的续篇，《The Site Reliablity Workbook》。《发布！软件的设计与部署 》Nygard作品，关于高可靠性的软件，学校里不会教，出来社会却要面对的那部分。 英文原标题里，“软件”的完整表达是“Production-Ready Software”《DevOps 软件架构师行动指南》DevOps的书里难得地讲基本原则，而不是讲具体用什么监控软件。《微服务设计》&nbsp;微服务开山之作，那么多微服务的书，这本只谈原则而不会写一堆具体框架的使用。《生产微服务》再次被中文编辑的书名打败，其实是《Production-Ready Microservices》，作者以在Uber的经验，讲一个满足基本业务逻辑之外，生产可用的微服务的检查表。附加 ：有两本英文标题明明是Scalability的书，中文编辑硬是改为《架构即未来》，《架构真经》，前者有我们前CTO推荐不敢乱说，后者虽然是第二版还是觉得有点过时，大家自己看目录判断了。3. 架构师基础的书《恰如其分的软件架构 - 风险驱动的设计方法》由于人类与生俱来的惰性，计算机原本科学的、精准的设计方式，有了敏捷的借口之后就很难再维持了。本书就是在这种背景下，提出由风险来决定设计的度。除了开始的风险驱动部分，其余部分就是规规矩矩标标准准的架构师教科书。《软件系统架构：使用视点和视角与利益相关者合作 第2版》也是教科书，最难得的是，这本老书在十年后的2011年年升级了第二版，所以感觉鲜活了好多，也许是最鲜活的一本架构书。附加：说起更新，《Software Architecture in Practice&nbsp;3rd》也在2012年更新，《Documenting Software Architectures 2nd》在2010年更新，不过中规中矩，没那么大吸引力让人去啃英文了。拔草：关于设计模式，我以前曾经有过很多本，GOF23啦，企业应用架构模式啦，EIP啦， POSA 5卷本啦，反模式啦，JavaEE/SOA/Restful的模式啦。但现在觉得对新人来说，一本Java写的《Head First 设计模式》，知道什么叫设计模式就够了。UML相关的书，其实UML只在那个重度文档的年代会体现统一的作用，现在大家都是怎么表达清楚怎么来，最多简单用下类图和时序图了。4. Java语言的书《Java8 实战》Java8的新特性讲得最全最仔细的，Java8是一道坎，很多程序员现在还没迈过去。英文版有重写了，面向JDK9的《Modern Java in Action》。《Java性能权威指南》紫色的这本，比起多年前那部调优圣经，讲得更加深入，也更加贴近现在的JDK。英文版还有一本《Optimizing Java》。《深入理解 Java 虚拟机 第2版》理解虚拟机并不是那么难，Java程序员来说，很多知识其实是必须的。《Java并发编程实战》Java并发经典，人手一本不用多说了。《实战Java高并发程序设计》&nbsp;国人之作，流畅易读，内容也比上面一本新一些。《Effective Java 2nd》Java编码规范与指南， 英文版有覆盖JDK9的第三版。私家推荐，结合了它和《Java编码指南：编写安全可靠程序的75条建议》、《阿里巴巴Java开发手册》的《唯品会Java开发手册》(https://vipshop.github.io/vjtools/)&nbsp;&nbsp;极客时间：&nbsp;《Java核心技术36讲》是Oracle 做Java平台部门的杨晓峰的专栏，Java里很多关键点都讲到了。《深入拆解Java虚拟机》是Oracle里做新一代Graal编译器的高级研究员郑雨迪对JVM的深入讲解，能坚持看完的同学平时都可以装一副很懂的样子了。补充：&nbsp;培训新人最好找《Java核心技术》。最新是第10版，但按JDK近来的升级速度，这书都快追不上了。&nbsp;要一口吃成个胖子，推荐飒然的《Java工程师修炼之道》，可以作为老鸟培养新人，整个Java后端开发的提纲式材料。《Java 9模块化开发》，跳票无数回之后，Java9终于支持模块化了，对这方面关心对可以看看。《响应式编程 — RxJava 高阶指南》，掘金小册，连介绍里的几篇基础文章，是响应式编程不错的入门。&nbsp;https://juejin.im/book/5a09997cf265da432002bf6a拔草：《Thinking in Java》有点太旧了，而且作者思路随意，译者语言晦涩。《Java性能优化权威指南&nbsp;》多年前的调优圣经已经旧的没谱。5. 操作系统与网络的书《Linux内核设计与实现 第3版》业内缩写LKD。Robert Love用最薄的篇幅，顺畅的文字将Linux内核主要的算法讲清楚了，《深入理解Linux内核》之类厚厚的全是代码，不是专门的内核程序员看这本足够了。《性能之巅》Brendan Gregg的书，火焰图的推广者，在Netflix专攻性能。&nbsp;操作系统的性能调优、监控、工具和方法论，看这本就够了，已经足够厚，可能是书单里最厚的一本，但值得作为一本枕头书。《WireShark网络分析就这么简单》和&nbsp;《WireShark网络分析的艺术》多少人，是看了这两本轻松又实战的书，才真正理解TCP的细节。《深入理解计算机系统 第3版》如果实在觉得家里没本书镇楼心里不踏实，就买这一本，也是左耳朵耗子力荐的一本。极客时间：很有现代感，互联网站涉及的内容，那些经典教科书里都没有的。&lt;/p附加：《现代操作系统 第3版》如果看LKD未尽兴，可以回头看看这本基础概念，感觉没《操作系统概念》(恐龙书)那么枯燥。《TCP/IP详解 卷1:协议 第2版》&nbsp;这么多年过去了，TCP的书好像还是只有英年早逝的作者的这一本。后人写的第二版也出来，厚了很多。拔草：《UNIX环境高级编程》和《UNIX网络编程》，缩写为APUE和UNP，不写C的同学其实没啥用。《Unix 编程艺术》，扯的都是闲篇，厚厚的一本略读一下就行。&nbsp;另外，那些日本韩国人写的《图解XXX》都不喜欢。6. 算法的书《数据结构与算法分析-Java语言描述 第3版》够薄，数据结构与算法分析的点基本都涵盖了，而且示例代码是Java写的，新出了第3版。《算法 第4版》可与上一本对比着读，厚一些，也多些图，但知识点没上面的全，也是Java的。附加：&nbsp;《数学之美》、《编程珠玑》，都是专栏文章，讲得并不系统，可以当兴趣读物来看。拔草：无比枯燥很多公式的《算法导论》，《计算机程序设计艺术》就留给特别厉害的同学去读了。7. 程序员的自我修养《程序员修炼之道-从小工到专家》Pragmatic Programmer–注重实效的程序员系列的开山之作。《代码整洁之道》和&nbsp;《程序员的职业素养》Robert.C Martin作品，英文名是很相近的《Clean Code》和 《Clean Coder》，应该接替《代码大全2》成为必看系列，因为后者太厚了，而且也有不少过时的东西。还有一本英文版的《Clean Architecture》，不过讲的是单体应用自身的架构。《有效的单元测试》讲代码可读性的书很多，专门教测试代码怎么写得可读的少，而事实上我们很多时间都在维护测试代码，所以推荐下。拔草：《重构》很厚，但最有价值就是前面几章的洗脑篇。温伯格的书网上很推崇，《成为技术领导者》之类的，但我觉得年代太远，读起来其实没多大意思，一两个鸡汤观点还要自己从书里慢慢淘，有那功夫不如看点别的。8. 团队的书敏捷的书高度重复，看哪本都差不多，比如最开始那本《解析极限编程–拥抱变化》就行，但没得卖了。其他如《硝烟中的Scrum 和 XP》，《学习敏捷》，《敏捷开发的艺术》都不错。阻止大家买书的原因，一是没有地方放，二是没有时间看。好在Kindle上的书渐渐多了，解决了第一个问题。但第二个问题更难，所以我也没看完所有，但起码翻到了可以下判断的时候。 江南白衣的java后端书架https://mp.weixin.qq.com/s/-TJ8SW8gs5PIqUwKLCUfSg","tags":[{"name":"书单","slug":"书单","permalink":"http://yoursite.com/tags/书单/"}]},{"title":"存款准备金","date":"2018-11-18T11:50:02.311Z","path":"2018/11/18/存款准备金/","text":"存款准备金 金融机构为保证客户提取存款和资金清算需要而准备的，在中央银行的存款。初始意义在于保证商业银行的支付和清算。 存款准备金率 中央银行要求的存款准备金占其存款总额的比例就是存款准备金率。 货币乘数 一单位准备金所产生的货币量。 乘数效应 中央银行的初始货币提供量与社会货币最终形成量之间存在着数倍扩张（或收缩）的效果。 举例 先假设最低准备金率是20%，也就是说当银行得到100元的存款时它必须留存20元，只能贷出80元。其次假设银行会放足80元。 现在有某君A往银行里存了100元，银行再将其中的80元放贷给B，如果B把贷来的80元又全部存入银行，银行再将其中的64原贷给了C，C又把64元存入银行，银行再向D贷出51.2元…依此类推，央行最先向市场投放了100元，市场上最后多的货币会是100+80+64+51.2+… 解这个数列的值是500，其实就是100*（1/0.2）=500 也就是实际的货币投放量。这里的1/0.2就是货币乘数也就是1除以法定准备金率。 完整的货币（政策）乘数的计算公式是：m =（Rc+1）/(Rd+Re+Rc)。其中Rd、Re、Rc分别代表法定准备率、超额准备率和现金在存款中的比率。","tags":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/tags/金融/"},{"name":"存款准备金","slug":"存款准备金","permalink":"http://yoursite.com/tags/存款准备金/"},{"name":"乘数效应","slug":"乘数效应","permalink":"http://yoursite.com/tags/乘数效应/"}]},{"title":"其实它懂得比你想象的多","date":"2018-11-17T11:58:15.536Z","path":"2018/11/17/其实它懂得比你想象的多/","text":"情景 一天，儿子在玩扭扭车。 妹妹兴冲冲的走过来，儿子老远就看到了，眼神中充满敌意。 妹妹还没走到跟前，儿子就迎上推了一把，把妹妹推到了。 可能是还小的缘故，妹妹并没有哭，很快爬起来了。 过了一会，儿子拿起妹妹的杯子准备喝水。 舅妈一把夺过了杯子，严肃的说“不要用我们的杯子喝水”。 儿子怔怔得站在那里，可怜巴巴的说“舅妈，我不打妹妹了”。 重新认识 这个时候儿子只有28个月。他讲的话，没人教过他。也没人给他暗示，舅妈不让他用妹妹的杯子是因为他推了妹妹。 一个28个月的孩子能通过舅妈的行为和表情中判断并联想出这件事情发生的原因，并主动做出和解的反应，这很让我惊讶。 改变教育方式 以上的情景，让我意识到，孩子的思维发育远远超出我原本的预期。所以，在教育孩子时，可以试着用成人的思考方式来处理。 发生上面的情景该如何处理？ 首先需要同理心，思考下孩子为何会做出这样的反应？ 重要的一点，不只需要自己思考，还需要直接从孩子那里得到答案。（不要直接告诉孩子如何做，让他自己去思考） 问孩子：为什么打妹妹呢？ 答：妹妹会打我，抢我的玩具，我不喜欢妹妹。（妹妹只有15个月，处于感官发育期，经常用手拍人或者物） 问：哦，是因为妹妹经常拍你，抢你玩具你才会推她是吗？ 答：是的。 问：妹妹是怎么打你得呢： 答：她这样打我。（做出手拍的样子） 问：妹妹这样拍你很疼吧？ 答：是的。 告诉孩子：我知道了，妹妹经常这样拍你，拍得你很疼。其实啊，妹妹这是喜欢你，想跟你玩，她还不会控制摸你得力量，所以啊，她摸你得时候用的力气太大。（仅这样还不够，即使他知道了原因，他也不想挨打啊。因为孩子太小了，他怕被打怕玩具被抢，只会提前预防，除此之外他不知道该怎么应对。只能直接告诉他如何应对。）以后妹妹要拍你得时候，你就告诉妹妹，轻轻的啊，不能打我，不然我就打你喽。（因为妹妹太小，其实这样还是很难阻止事情的发生的，父母得好好盯着） 答：恩。 告诉孩子第二件事：妹妹一定是觉得你得玩具很好玩，她也想玩玩，我们跟她一起玩，她的玩具我们也一起玩，这样怎么样？ （上面的这两件事在平时要不断的重复告诉他） 答：好的，我跟她一起玩。 除此之外，平时需要必不可少的训练。在家里模拟妹妹拍他、抢玩具的情景，教他如何应变，不断的训练。（孩子的任何经历都可以在家里训练它的应变能力）","tags":[{"name":"教育","slug":"教育","permalink":"http://yoursite.com/tags/教育/"}]},{"title":"上海证交所云计算解决方案","date":"2018-11-17T07:30:07.254Z","path":"2018/11/17/上海证交所云计算解决方案/","text":"","tags":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/tags/金融/"},{"name":"云计算","slug":"云计算","permalink":"http://yoursite.com/tags/云计算/"},{"name":"合规体系","slug":"合规体系","permalink":"http://yoursite.com/tags/合规体系/"}]},{"title":"精益看板","date":"2018-11-17T01:05:52.502Z","path":"2018/11/17/精益看板/","text":"精益看板在软件方面的八大实践 建立看板 价值流映射：对研发整体流程进行价值流映射，分析典型业务流效率。 分析请求分配产能：对不同工作项类型，分析价值流请求量并分配产能（划分泳道）。 显式化流转规则：显式化每个活动上下游流转规则及时发现问题，质量可控。 限制在制品：限制并行任务数，让任务流动更快，缩短开发周期。 运作看板 消除瓶颈：通过提升瓶颈处的处理能力，从而提升项目的吞吐量。 加速流动：通过监控流动中的异常状态，及时处理等待和阻塞，加速流动提升吞吐量。 改进价值流：通过数据驱动的回顾消除浪费，持续不断的改进价值流，提升吞吐量。 拉动式开发：通过拉动机制平衡开发资源和请求，保证价值持续稳定的流动。 精益看板开源及收费软件 https://business901.com/blog1/lean-kanban-lessons-from-a-software-developer/https://www.leangoo.com/https://www.agilealliance.org/what-is-scrumban/https://www.teambition.com/agile?utm_source=sitesolution&amp;utm_term=agile+development&amp;utm_campaign=templatehttps://kanbantool.com/product","tags":[{"name":"精益看板","slug":"精益看板","permalink":"http://yoursite.com/tags/精益看板/"},{"name":"敏捷","slug":"敏捷","permalink":"http://yoursite.com/tags/敏捷/"},{"name":"scrum","slug":"scrum","permalink":"http://yoursite.com/tags/scrum/"}]},{"title":"六顶思考帽","date":"2018-11-16T15:51:24.174Z","path":"2018/11/16/六顶思考帽/","text":"部分内容","tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/思维/"},{"name":"思考方法","slug":"思考方法","permalink":"http://yoursite.com/tags/思考方法/"}]},{"title":"如何修改用户的SHELL参数","date":"2018-11-11T09:30:22.106Z","path":"2018/11/11/如何修改用户的SHELL参数/","text":"1.查看可用shellcat /etc/shells 2.假设指定test用户的shell为可用的/bin/shchsh -s /bin/sh test 3.在用户下查看 env即可查看到当前shell","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"取模与取余的区别","date":"2018-11-11T09:30:22.105Z","path":"2018/11/11/取模与取余的区别/","text":"对于整型数a，b来说，取模运算或者求余运算的方法都是： 1.求 整数商： c = a/b; 2.计算模或者余数： r = a - c*b. 求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。 例如：计算-7 Mod 4 那么：a = -7；b = 4； 第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）； 第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。 归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。 当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。 另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"linux查看端口被哪个程序占用","date":"2018-11-11T09:27:26.151Z","path":"2018/11/11/linux查看端口被哪个程序占用/","text":"1.查看端口被哪个程序占用1.&gt;netstat -apn|grep [port] 2.&gt; ll /proc/[pid]/ 或者用 ps -aux | grep [pid] 2. 查看某个应用程序的进程详情ps -aux | grep /home/tomcat/cartV1/vmall/ 3.查看某个进程占用了哪个端口netstat -nltp|grep pid","tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://yoursite.com/tags/linux命令/"}]},{"title":"MySQL索引和约束","date":"2018-11-11T09:24:32.795Z","path":"2018/11/11/MySQL索引和约束/","text":"1 索引分类按照字段个数分：单列索引、组合索引按照唯一性划分：普通索引、唯一索引MyISAM特殊索引：全文索引和空间索引 2 唯一性约束主键：一个表只能存在一个，且不允许空值 PRIMARY KEY&lt;字段名1,字段名2,…&gt;唯一性约束：允许列上存在一个空值 UNIQUE&lt;字段名1,字段名2,…&gt;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"能力提升知识体系","date":"2018-11-04T23:45:13.439Z","path":"2018/11/05/能力提升知识体系/","text":"","tags":[{"name":"能力提升","slug":"能力提升","permalink":"http://yoursite.com/tags/能力提升/"},{"name":"书单","slug":"书单","permalink":"http://yoursite.com/tags/书单/"}]},{"title":"子女教育问题","date":"2018-11-04T15:58:58.731Z","path":"2018/11/04/孩子教育问题/","text":"现在社会充斥着无处不在的压力与竞争，知识层次越高，往往面临的压力也越大。曾参加过一个培训机构的压力测试，测试的对象一个是汽车制造厂的蓝领工人群体，另一个国内某世界500强的民营高科技公司的白领群体，测试的结果令人意外，蓝领工人的压力普遍更小，而知识层次和收入较高的白领群体的压力普遍高很多。面对巨大的职场压力，白领群体往往在工作上付出的时间相对更多，加班成为工作的常态。即使在下班时间也会消耗大量的时间在工作上，还要持续加强自身的学习。然而，我们都面临着一个无法回避的问题：子女教育。 总结一下，孩子的教育归为两类：1）人格修养教育；2）思维、技能培养。 人格修养教育是父母必须要做到的部分，孩子的人格养成和修养的提升往往来源于父母的言传身教，在孩子形成是非判断能力前，身教往往更有效。孩子身上往往会反映出父母的一些行为习惯，这就是问题的家族性遗传。如果孩子性格暴躁，那么一方面是天生的性格特点，而最有可能的是因为父母一方性格比较暴躁，孩子很快就会学会。不信你可以观察下，大部分孩子的言行举止都会与父母神似。作为父母，我们必须先做好榜样，才能教会孩子。 思维、技能培养可以由父母以外的更专业的角色来承担，比如培训机构、学校，并不需要父母的言传身教。但是现在培训机构或者学校为了保证效果会给父母留各种的作业和任务，要求家长帮助孩子完成，这无形中增加了父母的负担。我的观点是如果你的精力不足，那么重点培养孩子的思维能力，适当挖掘孩子的兴趣，技能的教育不可缺少但是优先级最低。 这两类，无论哪一类，都需要父母花费大量时间。孩子的教育其实拼的是父母。孩子往往是在父母的基础上成长起来的，你的水平决定了你孩子的起始水平。你是否想过你的业余时间有多少？每天花费在孩子身上的时间有多少？每周有多少？跟孩子一起时都做些什么？你是如何教育孩子的？ 如果父母双方都在职场，时间紧张，那么合理规划自己的业余时间以保证在孩子教育上的投入是很有必要的。 我的建议是家务的事情，能外包的就不要自己做。洗衣、做饭、清洁这些工作完全可以交给他人去做，把时间省下来，用在孩子身上。 父母需要多读一些教育方面的书籍，提升自我修养，学会帮助孩子树立正确的人生观和价值观。 与孩子在一起时，要保证质量和效果，多与孩子做深层次的交流与互动，培养孩子高尚的品格，挖掘孩子的兴趣。 技能的培养交给专业的机构，花费少量的时间做孩子的辅导。","tags":[{"name":"教育，时间管理","slug":"教育，时间管理","permalink":"http://yoursite.com/tags/教育，时间管理/"}]},{"title":"一个离职华为员工的十年感悟（转）","date":"2018-11-03T11:22:13.447Z","path":"2018/11/03/一个离职华为员工的十年感悟/","text":"一毕业就加入公司，做过研发、一线，到今年已经是第十年（九年两个月）了；做人得感恩，首先必须要感谢公司，在公司遇到LP，有了娃，帝都买了房（有贷款）。 结合心声大家经常讨论的问题，以下有一点小收获，非经历贴非炫耀贴，分享给后来人，希望对困惑的人有所帮助；对或不对、听或不听，自行判断；觉得错的不用喷了，本周五就截止了，有问题可以留言，我尽量答复。 第一点，人和人区别就是思维，不断更新的思维体系；人可以累，但不能停止思考。 很多人最大的恐慌估计就是明知自己在打杂，又不敢或不能出去，担心出去没有竞争力。其实，这部分同学，大多数只停留在想一想的阶段，还没有到思考的阶段，没有到体系的阶段；竞争力，我的总结是工作经历+不断进步的思维体系，还有你的圈子；你会发现，每层领导都比下级领导牛，区别就是经验和思维逻辑。平时不要只抱怨，也要多思考，多学习，不断的更新自己；挑战别人容易，自己积累很难；如果一段时间，感觉自己一直很牛或者自己没有提升的输入/输出，那真的好好反思自己了，思维体系是顶层，是所有的基础，人可以累，不能停止思考，这就是哲学的本质。 第二，身体是革命的本钱。 公司导向是艰苦奋斗，身边一些兄弟真可以说是糟蹋自己的身体，来表现奋斗；如果能拼上去（至少19以上）还值得，不然病了没人管你；身边一个哥们得了很严重的病，后来公司也没管，离职了。 男人身体有两个关键时间点一定要注意：第一个是35岁，男人体质下降转折点；第二个是45岁，心血管疾病发生率高发期，经常喝酒熬夜的需要注意。 你没了，你这一辈子可能是在给你的司机打工（那天看到的一个新闻）。 建议平时多跑步（注意保暖，保护膝盖）、游泳，做些无氧增加肌肉，家里也行，哑铃、跳绳、卷腹、平板支撑等等，不要说自己累没有时间等，没有人不累，不是非要跑10公里才叫运动，只要你想明白了，你就会知道怎么做。 第三，家庭是根基，家都是温暖的港湾和动力源泉 人的爆发来自于安全感，家是安全感的重要来源，要懂得经营，家庭会给你很多的动力；不要动不动就吵架、离婚，离婚对家庭、孩子没有赢家，人品底线出了问题除外。 心声有同事说她老公天天打游戏，一个大人怎么能这样呢？？这种情况属于你老公不知道如何处理自己困境，迷茫，他也不是故意的。 很多人“不思进取”其根因，他的父母只停留在“好好学习”的层次，父母没有教给他正确的教育，他不知所措；那么，你就要思考了，你提升了吗？作为你的人生另一半，你该如何帮忙他提升呢？如何让你的孩子不走老路呢？ 分享一个经验，人天生就不爱听别人否定自己，请要不整天JJYY只会增加他的反感，人本能容易接受第三方的经验。 可以偶尔游戏、电影、运动、喝酒释放自己，但要养成看书/听书，多与人交流，每个人都有比自己强的地方，看书和与人交流是一种很好的方式，把这个习惯带给你的家人和孩子。如果你的圈子就只有喝酒，只能说明你的圈子很低。 第四，没有不懂事的孩子，只有不学习的家长；教育拼的是家长不是孩子，本质就是你和他一起提升；不要说等我挣完钱了抽时间在管他。 最近天涯曝光很多渣男，一个男人身体偶尔偏航，精神可以偶尔出轨，但人品一定不能；而，身边很多人对孩子可以说没有教育可言，你有没有想过，二十年后你的娃可能也会上天涯？想想这是多么可怕的事情；说实话，一方面公司太商业没有道德和精神，另一方面，是自己的父母从小没有给予我们正确的教育体系；那么，要么是我们自己努力改变自己形成教育传递给下一代，要么把碰壁的机会留给你的娃，选择后者，可以说是自私，等你老了你的娃内心里一定会责怪你的。 教育不是数理化，不是学习成绩；内核是心理学，孩子未来与人合作，自我更新处理能力；中间，品味、仪表姿态、财商；最后才是技能。内核和中间层出了问题，技能能好吗？或者光有学习成绩就够了吗？ 心声有说，我孩子天天打游戏求破？破什么，你平时在家看手机不？打游戏不？你都做不到，怎么要求一个孩子呢？为了孩子的学习，你有没有学习教育方面的书籍和交流？ 第五，要不要在公司干下去？每天你都要思考，公司不是家，你学到了什么，你未来如何规划。 多出去看看，你会发展现在的公司是个非常好的平台，但对于个人是不是最好的，你要分析；如果你的能力很强、逻辑思维和口才好、懂得和领导拉关系，机会得当，能拼到20以上，建议你好好拼搏一把。高管的待遇和境界是值得你付出的。 现在公司已经过了爆发期，到了和平发展期，个人迸发机会真的越来越少；如果你不是最牛X的那波人，必须面对现实，多思考，公司毕竟还是逃不开通信设备的圈子，这个圈子很小，都被公司给打的差不多了，没有了磨盘的市场，杀了驴，你又能如何？ 在公司各个岗位的待遇，在其他小公司都是小主管的待遇，你出去之后很容易形成落差；公司是个庞大的组织，虚职一堆，有竞争力的岗位有多少，对于公司你只是一个螺丝钉，胶片可以写一年两年，写到45岁你还剩什么？ 千万别想着到45岁财务自由，再降低工资找个公司，一样工资，谁不喜欢年轻力壮的，那个时候想创业，想想你的身体和思维还活跃吗？ 社会变化这么快，那个时候你的几套房子能够抗风险的吗？？ 其实，搞个兼职或创业，也是个不错的选择；不要偏激的以为创业就是互联网，传统行业也是个不错的选择，很多传统行业利润都很好，只是你不在圈子里，可以现在不做，但一定要想，万一机会来了呢？ 第六，在公司干多久对自己有利？ 即使工作中有很多不爽，你要相信华为走到今天一定有他过人的地方，一定是比外面简单一些的，不要太过批评；公司的管理和流程是公司发展的根本，技术本身就是为了管理服务的，这也是外面很多公司都想学习，那么这个也可能是你的资本，请静下心来多思考，你能带走哪些？ 在一个公司，时间不要太短，建议3年左右；还是要有些积累，出去好和下一家谈；平时有有时间网上发简历，看看自己到底值多少钱，想好惯例前，至少3个月认真找下一家；5年也是一个比较好的时间点；35岁，是男人职业关键期，也是很多大厂商很多岗位招聘的限制年龄；过了这个工龄，出来竞争力同比下降了。 第七，研发要不要转一线？ 你无非想问这几个问题： 关于一线岗位的选择，有情商可做客户经理，待遇最好，可以积累圈子，这是完全不同的路线，这相当于脱离了技术，想好，不是谁都适合；产品经理，事情多而杂；想轻松调养身体，选渠道经理；服务经理相对压力小，竞争力也少一些； 累不累？首先，在公司主力部门（非平台），就没有几个轻松的岗位；研发是持续的累，一线是有节奏的累，忙的时候经常通宵，没有周末，不忙的时候可以有周末，平时工作时有走路和抬头的时间，可以接触一些人； 然后，哪个更挣钱？正常情况是要向一线倾斜的，但目前公司业绩不好，没有了403项目奖金，都差不多； 最后，岗位区别；大部分研发出来选择产品经理的居多；两个岗位相同点打杂事情都不少；研发偏封闭，一线较开放；研发有团队的概念，领导就坐你屁股后面，一线你和领导天天各种跑；研发偏执行，一线需要独立思考，需要一些情商；有些人在研发干的特别好的，到市场都熄火了；反而有一些在研发混不下去的，到一线如鱼得水，他们头脑更灵活，更懂得投“机”，懂得如何找到领导为核心，而不是公司的利益。一线可能涉及到换地方，充分沟通，后方要稳。 一线没有回头路，大部分都出去了，可以回到研发和市场的中间，很难回到纯研发岗。出来后，从公司出来，大部分只能做你现在的这个岗位了。想好了再出来。所有的路，没有对错，必须是你自己拍板，不能把决策权留给别人。 第八，工作多长时间从研发转一线合适？ 个人建议2-3年，不要超过5年；研发和市场是两种工作方式，或者从某种意义上说是相反的方式；人的惯性思维、岗位经验一旦形成，时间越长，越难适应新岗位；而且，工龄长了，对新岗位不是好事。要想升职，多轮换几个办事处； 关于海外，现在真的过了当年暴发户的年代了，现在没有太好的地方，出去很难回来，除非你有人，所以你一定要多培养领导资源。现在很多海外开始裁员了，有的裁员50%，公司日子越来越难。 第九，公司有一种累，叫虐心 “白天吵架、晚上加班干活”，这是一个离职师姐的总结，很形象； 原因就是公司给了每个部门和岗位的压力，平衡制约，而各个岗位为了体现自己的价值，拼命的找事，产生了内耗，现在公司内耗很严重，很多事情，从我看对公司价值不大，但对个人来讲非常虐心，这是最催人老的地方，公司经常看到一头白发的小伙子，脾气暴躁、脸色很差的女汉子，这种老，不是花几千做个美容买个豪华化妆品能弥补的；有些部位老了，再也回不去了；虐心容易激发癌症，推荐大家看看近藤诚的书，我正在看。 第十，家庭生活如何和谐？ 看很多员工经常发离婚、吵架，挺着急；作为过来人，我也经历过吵架到现在的和睦；分享几点经验； 1、一定要多思考，多学习，多进步！你夫妻关系紧张一定是你不够进步，一定是，不要把责任仍给对方。 2、夫妻吵架也是正常的，夫妻都要经过互相爱慕，然后幻灭，最后内省的过程；这是有心理学依据的，要多看书，推荐《亲密关系》等书籍； 3、不要害怕吵架，生活需要掐架，需要波澜；任何的谈判都是基于竞争的，历史上很多谈判都是一边打仗一边谈，最终打服了才有了谈的资本，然后适当让一下；这就是谈判。 4、吵架要有底线，借用《正面管教》的一句话，温柔而坚定；不要动手，不要骂人，简单说要有人品；越近的人，感情伤了，很难恢复；个人的修为要提升。 5、最好的方法，你先进步了，同时让你的另一半也进步，这才是真谛。 6、只要ta不出原则性问题，你要相信还是原配好。即使是渣男，也有你的过错，人性都有灰暗的一念，肯定有你的小错，你压制了别人，别人就会反弹你；你太迁就了别人，就激发了他的阴暗面；你有没有关注过他的心里真正在想什么？他的儿时有什么经历？平时的你提高了没有？你如何帮忙他成长呢？还是只有掐。 7、家里矛盾包括社会矛盾，说通俗一点，人有时候都是嘴贱，不占便宜死不休；每天都需要别人说点好的，抬高自己，错都是别人的；老婆觉得我嫁到你们家，你们应该供着；老公觉得，我们老家老婆就应该天天被骂，这是传统；两个内心反差，加上儿时缺乏良好的沟通教育，这生活能好吗？如果确实水火不容，就让老人回去，自己体会到了辛苦，在让他们过来；人不能觉得别人天生都是欠自己的。 最后，写给我心中的公司，伟大但仍然风险重重。 公司领导也看不到，就算写给自己的第一个十年吧；三个方面： 1、战略惰性：首先要说，LB确实很牛X，一直保持高度的自我革新，膜拜的偶像，我在公司学到了很多，感激；但我想说，LB年龄大了，缺少接班人这是最让人痛心地方；LB的理解力和专制，在公司刚起步阶段和腾飞阶段，快速聚集主航道，以客户为中心艰苦奋斗，打跑了很多不能干脏活累活的外国人，获得成功；但从近十年发展看，公司一直在吃运营商的老底子，战略上惰性了，丢掉了很多机会（比如云的趋势、视频的趋势，造就了多少个百亿的企业），在很多的机会面前畏首畏尾（短期看不到钱的），又成了别人眼中当年的外国人，真是轮回； 现在的手机有核心竞争力吗（CPU算是国产的情怀吧）？我们用运营商的人力和薪资体系，套上消费者BG上，和国内OV打，没有优势可言，又没有苹果的高度；同样，除了品质，企业网有什么竞争力吗？运营商是块状大蛋糕，企业网是小远散点，客户需要培育，不可能快速形成规模，人均效益和运营商没法比，自给自足很困难，很难更新，大的方向上失去了视频的大趋势，卡在云的趋势中，关键部件都不是自己的，在给三星和intel打工，未来在哪里；搞了个2012探索新领域，现在还没看到冰山；企鹅厂兼并小公司，虽然口碑不好，但确实发挥了大公司耍流氓的最高境界，保持非常敏感的嗅觉，不断的更新自己，不被别人革命掉；现在公司的情况真的不乐观，未来的路很长，在外面遥祝公司百年长青。 2、缺少精神文明建设：目前的公司，就是改革开放的中国，一只手发展经济，丢了精神建设；在经济红利区，只要给钱随便骂，当你和平发展时期怎么办？部门独立核算，强考评，让很多员工养成了非常“势利”的习惯，和自己考评相关的，领导在场的，所有功劳都往自己身上晒，今天踢这个一脚踢那个一脚，晒存在感；领导不在场，和自己考评不强相关的，你以为你是谁啊？一个国家没有国家荣誉感、集体主义精神，人民没有信仰很可怕，一个企业同样也需要。但不是说大家每天空谈精神，不要物质。 3、人力资源的懈怠：人力资源对公司很重要，公司成长过程中人力逼研发和市场前行，但忽视对人力资源的变革，没人管；现在人力资源的薪资已经是研发市场最羡慕的岗位，而且从不招聘，没有点关系进不去，已经成了温柔乡了；人力属于上游部门，这是非常可怕的；新形势下，人力和组织如何布局？今年突然说离职率低裁员，不应该是今天LB说离职率低，才被动反应；公司的懈怠、管理层的错综关系，责任首先是领导和上游部门，首先应该动金字塔尖，而不是下面的根基，裁几个基层员工能解决公司前进的问题吗？这些都是没有对人力资源产生很好的牵引和抑制的体现；内部关系也很复杂，主管一言堂，看一个17B多么大的势力。大家经常诟病的问题，内耗、胶片文化、无效加班、组织臃肿、一言堂等，根深蒂固，很难改变，慢慢来吧； 昨天看了一本书《爸爸军团》推荐给大家，假如你被宣布得了癌症，躺在床上，闭上眼睛，想想你会有什么遗憾？孩子的教育？自己的身体？家庭关系？照顾父母？等等，那么现在还等什么呢，不要让自己老的时候才去后悔。","tags":[{"name":"人生，感悟","slug":"人生，感悟","permalink":"http://yoursite.com/tags/人生，感悟/"}]},{"title":"Tomcat的web.xml配置","date":"2018-10-30T00:01:36.687Z","path":"2018/10/30/Tomcat的web配置/","text":"web.xml出现的位置 tomcat中有两处使用到web.xml配置，一个是$HOME/conf/web.xml，另一个是$HOME/webapps/myapps/WEB-INF/web.xml。tomcat启动时，首先读取全局的$HOME/conf/web.xml，再读取/WEB-INF/web.xml。前者是全局性的，会在所有webapps中生效，后者只在本webapps中有效。 web.xml中元素配置的顺序要求 web.xml的root元素是web-app，除此之外，其他的内部元素都是非必须的。web-app下的子元素没有严格的顺序要求。但是，同一类型的配置是有顺序要求的，比如filter-mapping必须要跟在对应的filter之后，并且对隶属于同一个filter的filter-mapping，servlet在匹配时会先匹配前面的mapping的doFilter()方法。同样的道理servlet和servlet-mapping也是一样的处理。 web.xml中元素的加载顺序 不论web-app中的子元素配置的顺序如何，servlet加载时会按照context-param -&gt; listener -&gt; filter -&gt; servlet的顺序进行加载。 web.xml的配置说明下面这些配置仅仅包括常用配置 &lt;web-app&gt; &lt;icon&gt;&lt;/icon&gt; 应用图标，在GUI管理工具中使用 &lt;display-name&gt;&lt;/display-name&gt; Web应用名称 &lt;description&gt;&lt;/description&gt; Web应用描述 &lt;context-param&gt;&lt;/context-param&gt; 声明应用范围内的初始化参数 &lt;filter&gt;&lt;/filter&gt; 过滤器配置：将一个名字与一个实现javaxs.servlet.Filter接口的类相关联 &lt;filter-mapping&gt;&lt;/filter-mapping&gt; 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联 &lt;servlet&gt;&lt;/servlet&gt; 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。 &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 为servlet指定非缺省的URL &lt;session-config&gt;&lt;/session-config&gt; 指定session配置。如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。 &lt;listener&gt;&lt;/listener&gt; Context或会话监听器配置。事件监听程序在建立、修改和删除会话或servlet环境时得到通知 &lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; 指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件。 &lt;taglib&gt;&lt;/taglib&gt; 用来设定JSP网页所用到的Tag Library路径 &lt;resource-ref&gt;&lt;/resource-ref&gt; 定义利用JNDI取得站台可利用的外部资源，比如JDBC &lt;security-constraint&gt;&lt;/security-constraint&gt; 认证配置，与login-config元素联合使用 &lt;login-config&gt;&lt;/login-config&gt; 指定sercurity-constraint下使用怎样的登陆机制 &lt;security-role&gt;&lt;/security-role&gt; 安全角色的一个列表，与security-constraint配套使用 &lt;error-page&gt;&lt;/error-page&gt; 在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，映射到对应页面 &lt;env-entry&gt;&lt;/env-entry&gt; 声明Web应用的环境项 &lt;ejb-ref&gt;&lt;/ejb-ref&gt; 声明servlet使用的EJB &lt;ejb-local-ref&gt;&lt;/ejb-local-ref&gt; 声明servlet使用的EJB的本地接口 &lt;/web-app&gt; display-name和description这两个一般会配套使用，比如： &lt;display-name&gt;Tomcat Manager Application&lt;/display-name&gt; &lt;description&gt;A scriptable management web application for the Tomcat Web Server; Manager lets you view, load/unload/etc particular web applications.&lt;/description&gt; context-param定义传递给servlet或JSP的参数。比如数据库连接参数、文件名或网站信息等。 &lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; 上面的配置对webapp的所有servlet生效。也可以设置仅仅对某个servlet生效，但是此时context-param元素必须在servlet元素中，如下： &lt;servlet&gt; &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;mypack.SampleServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;initParam1&lt;/param-name&gt; &lt;param-value&gt;2&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; filter和filter-mapping过滤器在指定的URL传递给servlet之前，或执行servlet之后执行。filter的子元素包括： &lt;filter&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; 定义过滤器的名字。当有多个过滤器时，不能同名 &lt;filter-class&gt;org.apache.catalina.filters.SetCharacterEncodingFilter&lt;/filter-class&gt; 指定实现这一过滤的类，这个类负责具体的过滤事务 &lt;init-param&gt; 配置过滤器的初始化参数 &lt;param-name&gt;encoding&lt;/param-name&gt; 参数名 &lt;param-value&gt;UTF-8&lt;/param-value&gt; 参数值 &lt;/init-param&gt; &lt;/filter&gt; 过滤器配置完成后，需要通过filter-mapping来配置过滤器生效的对象，生效对象可以是URL或servlet。 对URL生效，使用url-pattern进行配置，所有符合模式的入向URL都会被过滤器处理。如： &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; 在filter中定义的过滤器名字 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 指定filter所对应的URL &lt;/filter-mapping&gt; 在servlet 2.5之后，filter-mapping中可以使用多个url-pattern，进而把多个pattern映射为该过滤器。 对servlet生效，使用servlet-name配置，会将过滤器的输出传给指定的servlet。如： &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; 过滤器名称 &lt;servlet-name&gt;HTMLManager&lt;/servlet-name&gt; servlet名称。这个servlet必须在前面定义过。 &lt;/filter-mapping&gt; listener用来指定事件监听器。事件监听程序在建立、修改和删除会话或servlet环境时得到通知。 &lt;listener&gt; &lt;listener-class&gt;listeners.ContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;listeners.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; servlet和servlet-mapping定义servlet，以用于servlet-mapping或者filter-mapping中。 &lt;!-- 基本配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;snoopImpl&lt;/servlet-name&gt; servlet名字 &lt;servlet-class&gt;com.SnoopImplServlet&lt;/servlet-class&gt; servlet代表的类 &lt;/servlet&gt; &lt;!-- 高级配置 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;servlet-class&gt;com.SnoopServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;foo&lt;/param-name&gt; servlet类的参数名 &lt;param-value&gt;bar&lt;/param-value&gt; servlet类的参数值 &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; 指定当Web应用启动时，装载Servlet的次序。当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet。当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它。 &lt;run-as&gt; &lt;description&gt;Security role for anonymous access&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; 执行此servlet的角色名称。 &lt;/run-as&gt; &lt;/servlet&gt; 上述元素并不是servlet的全部子元素，除此之外还有jsp-file和security-role-ref。 默认情况下，web对servlet的请求必须包含servlet的完整类名。但这样使用起来极不方便，可读性不好，因此，常用servlet的别名代替，而servlet-mapping就是用来做servlet与别名映射的元素。 &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; 前面定义的servlet名称 &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt; 指定servlet所对应的别名URL或别名 &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 这样配置的servlet，web可以通过应用的Context路径拼接url-pattern来访问对应的servlet。上述配置中所有的以“.jsp”结尾的文件名都会由snoop来处理。 另外一种用法, 会将所有的请求都映射成指定的JSP文件，如下例中的redirector.jsp，这里与重定向不完全相同，因为它动态的计算用于新Context的精确链接。 &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; 前面定义的servlet名称 &lt;jsp-file&gt;/redirector.jsp&lt;/jsp-file&gt; 指定web站台中的某个JSP网页的完整路径 &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;snoop&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; session-config用于设置会话闲置时间。当用户访问的会话超过这个时间时，Tomcat将会丢弃该会话，并回收内存。 &lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; 会话闲置120分钟后超时 &lt;/session-config&gt; welcome-file-list配置欢迎页面。假如用户输入了一个http://host/webAppPrefix/directoryName/这样的包含一个目录名但没有包含文件名的URL时，会发生什么呢？用户能得到一个目录表？一个错误？还是标准文件的内容？如果得到标准文件内容，是index.html、index.jsp、default.html、default.htm或别的什么东西呢？Welcome-file-list 元素及其辅助的welcome-file元素解决了这个模糊的问题。例如，下面的web.xml项指出，如果一个URL给出一个目录名但未给出文件名，服务器应该首先试用index.jsp，然后再试用index.html。如果两者都没有找到，则结果有赖于所用的服务器（如一个目录列表）。 &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 可以通过将DefaultServlet参数设置为false,来关闭Tomcat全部的打印目录清单功能： &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlet.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; jsp-configjsp-config包括taglib和jsp-property-group两个子元素。 JSP taglib元素具有一个必要的uri属性，它给出一个TLD（Tag Library Descriptor）文件相对于Web应用的根的位置。TLD文件的实际名称在发布新的标签库版本时可能会改变，但我们希望避免更改所有现有JSP页面。此外，可能还希望使用保持taglib元素的简练性的一个简短的uri。这就是部署描述符文件的taglib元素派用场的所在了。Taglib包含两个子元素：taglib-uri和taglib-location。 taglib-uri元素应该与用于JSP taglib元素的uri属性的东西相匹配。Taglib-location元素给出TLD文件的实际位置。例如，假如你将文件chart-tags-1.3beta.tld放在WebApp/WEB-INF/tlds中。现在，假如web.xml在webapp元素内包含下列内容。 jsp-property-group的作用是允许将Web应用程序的一组资源配置为不同于全局设置的JSP行为。Scriptlet是个不乐意被见到的东西，因为它会使得HTML与Java程式码交相混杂，对于程式的维护来说相当的麻烦，必要的时候，可以在web.xml 中加上 标签，设定所有的JSP 网页都不可以使用Scriptlet。 &lt;taglib&gt; &lt;taglib-uri&gt;/charts.tld&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tlds/chart-tags-1.3beta.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://tomcat.apache.org/example-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/jsp/example-taglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;description&gt;Special property group for JSP Configuration JSP example.&lt;/description&gt; &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt; 设定名称 &lt;url-pattern&gt;/jsp/jsp2/misc/config.jsp&lt;/url-pattern&gt; 设定值所影响的范围，如： /CH2 或 /*.jsp &lt;el-ignored&gt;true&lt;/el-ignored&gt; 若为 true，表示不支持 EL 语法 &lt;page-encoding&gt;ISO-8859-1&lt;/page-encoding&gt; 设定 JSP 网页的编码 &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; 若为 true，表示不支持 &lt;% scripting %&gt;语法 &lt;include-prelude&gt;/jsp/jsp2/misc/prelude.jspf&lt;/include-prelude&gt; 设置 JSP 网页的抬头，扩展名为 .jspf &lt;include-coda&gt;/jsp/jsp2/misc/coda.jspf&lt;/include-coda&gt; 设置 JSP 网页的结尾，扩展名为 .jspf &lt;/jsp-property-group&gt; 给出这个说明后，JSP页面可通过下面的简化形式使用标签库。 &lt;%@ taglib uri=&quot;/charts.tld&quot; prefix=&quot;somePrefix&quot; %&gt; security-constraint用来指定访问设定的资源（目录/url）时所需要的身份验证。一般情况下，用来保护Web应用中的特殊目录。 &lt;security-constraint&gt; &lt;display-name&gt;Example Security Constraint - part 1&lt;/display-name&gt; &lt;web-resource-collection&gt; 描述Web应用程序中的哪些web资源受到指定安全限制的保护 &lt;web-resource-name&gt;Protected Area - Allow methods&lt;/web-resource-name&gt; &lt;url-pattern&gt;/jsp/security/protected/*&lt;/url-pattern&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; 指定安全限制覆盖的HTTP方法 &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; 描述允许访问Web组件的安全角色 &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;role-name&gt;role1&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; login-config登录验证设置。Web应用程序通过login-config元素来认证用户，并确认该用户是否为正确的角色。longin-config包含的auth-method子元素用来指定认证方法，BASIC是一种常见的Web认证方式，浏览器给用户提示一个对话框，要求输入用户名和密码，随后Tomcat将给出的用户名和密码与tomcat-users.xml中的用户名和密码进行比较，然后使用前面的security-constraint配置来确定用户是否可访问受保护的servlet。 这种认证方法实际上有两个步骤：1、检查提供的用户名和密码是否正确。2、判断用户是否映射到特定的安全角色。例如，用户可能提供了正确的用户名和密码，但没有映射到特定的安全角色，也将被禁止访问特定的Web资源。 &lt;login-config&gt; &lt;auth-method&gt;FORM&lt;/auth-method&gt; 指定验证方法，它有四个可选值：BASIC(基本验证)、DIGEST(摘要验证)、FORM(表单验证)、CLIENT-CERT &lt;realm-name&gt;Example Form-Based Authentication Area&lt;/realm-name&gt; 设定当客户端访问受保护区域时，浏览器在其登录对话窗中显示的名称 &lt;form-login-config&gt; 当验证方法为FORM时，配置验证网页和出错网页 &lt;form-login-page&gt;/jsp/security/protected/login.jsp&lt;/form-login-page&gt; 当验证方法为FORM时，设定验证网页 &lt;form-error-page&gt;/jsp/security/protected/error.jsp&lt;/form-error-page&gt; 当验证方法为FORM时，设定出错网页 &lt;/form-login-config&gt; &lt;/login-config&gt; login-conf通常会紧跟在security-constraint元素之后，表示要使用哪种安全防护方法来访问受保护的区域。 security-role安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。 &lt;security-role&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/security-role&gt; error-page用来配置HTTP状态代码或Java的异常类型来指定自定义的错误提示页面。错误提示页面必须是Context内的绝对路径。 &lt;error-page&gt; 通过错误码来配置error-page。当系统发生404错误时，跳转到错误处理页面。 &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; 通过异常的类型配置error-page。当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面。 &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; env-entryWeb环境参数：env-entry元素声明Web应用的环境变量。是将参数传递给Web应用程序的Java代码的集中方式之一，应用程序代码会使用JNDI来查询这些参数。 &lt;env-entry&gt; &lt;env-entry-name&gt;minExemptions&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt; 参数类型，就是java的参数类型，必须用全限定类名 &lt;env-entry-value&gt;1&lt;/env-entry-value&gt; 参数值 &lt;/env-entry&gt; &lt;env-entry&gt; &lt;env-entry-name&gt;foo/name1&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt; &lt;env-entry-value&gt;value1&lt;/env-entry-value&gt; &lt;/env-entry&gt; &lt;env-entry&gt; &lt;env-entry-name&gt;foo/bar/name2&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.lang.Boolean&lt;/env-entry-type&gt; &lt;env-entry-value&gt;true&lt;/env-entry-value&gt; &lt;/env-entry&gt; &lt;env-entry&gt; &lt;env-entry-name&gt;name3&lt;/env-entry-name&gt; &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt; &lt;env-entry-value&gt;1&lt;/env-entry-value&gt; &lt;/env-entry&gt; Spring如何配置&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;display-name&gt;myApp&lt;/display-name&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; &lt;!--加载多个spring配置文件 --&gt; /WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml，classpath*:/spring/spring_dependence.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 定义SPRING监听器，加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--单点登出监听器--&gt; &lt;listener&gt; &lt;listener-class&gt; org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--登陆认证, 使用CAS server认证--&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--自定义应用servlet启动配置--&gt; &lt;servlet&gt; &lt;servlet-name&gt;myAppServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mudaoren.test.web.StartServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;100&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Spring MVC DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:/spring/spring_mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Spring MVC DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Mapping规则当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是http://localhost/test/aaa.html ，我的应用上下文是test，容器会将http://localhost/test 去掉，剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了。 其匹配规则和顺序如下： 精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /*，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了。 最长路径匹配。例子：servletA的url-pattern为/test/*，而servletB的url-pattern为/test/a/*，此时访问http://localhost/test/a 时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。 扩展匹配。如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet。例子：servletA的url-pattern：*.action 以”/’开头和以”/*”结尾的是用来做路径映射的。以前缀”*.”开头的是用来做扩展映射的。所以，为什么定义”/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法识别。 web.xm中的安全配置这个博文中有详细的说明：https://blog.csdn.net/z59d8m6e40/article/details/72861248 参考： 《Tomcat权威指南》《深入剖析Tomcat》http://www.cnblogs.com/cljdream/archive/2013/11/29/3449308.htmlhttps://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"web.xml","slug":"web-xml","permalink":"http://yoursite.com/tags/web-xml/"}]},{"title":"Spring MVC请求处理流程","date":"2018-10-28T23:47:55.305Z","path":"2018/10/29/Spring MVC请求处理流程/","text":"① 请求离开浏览器，并携带用户的请求信息。首先到达一个单例的前端控制器DispatcherServlet。 ② DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，查询一个或多个处理映射器（handler mapping），获得下一步的Handler（Controller)。 ③ DispatcherServlet 根据上一步获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） ④ 提取Request中的请求消息，转换成Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 ⑤ 控制器执行完成后，产生一些信息，这些信息保存在模型（model）中。但是这些信息不可能直接展示，必须以一个友好的界面（html/jsp）来承载，这个界面就是视图（view）表示的界面。然后将模型和视图名返回给DispatcherServlet。 ⑥ 上一步的视图名标示了一个界面，需要通过视图解析器（ViewResoler）来为view找到对应的视图实现（界面，比如JSP）。 ⑦ 视图使用模型数据进行渲染。 ⑧ 将渲染结果返回给用户。 参考：《Spring In Action》https://www.cnblogs.com/dreamworlds/p/5396112.html","tags":[{"name":"Spring MVC，请求处理","slug":"Spring-MVC，请求处理","permalink":"http://yoursite.com/tags/Spring-MVC，请求处理/"}]},{"title":"Spring MVC如何接收请求参数","date":"2018-10-26T23:32:35.027Z","path":"2018/10/27/Spring MVC如何接受参数请求/","text":"当用户与服务器交互时，需要将用户的输入传递到服务端。这时就涉及到Spring MVC控制器接收客户端请求参数。控制器接收客户端请求参数的方式主要包括： 查询参数 表单参数 路径参数 方式一：查询参数。请求中的查询参数作为Controller的方法参数。请求 url：http://localhost:8080/spittles?max=10&amp;count=2 △ 利用函数注解@RequestParam接收参数。后台代码： @Controller @RequestMapping(&quot;/spittles&quot;) public class SpittleController { private static final String MAX_LONG_AS_STRING = &quot;9223372036854775807&quot;; @Autowired private SpittleRepository spittleRepository; @RequestMapping(method = RequestMethod.GET) public List&lt;Spittle&gt; spittles( @RequestParam(value = &quot;max&quot;, defaultValue = MAX_LONG_AS_STRING) long max, @RequestParam(defaultValue = &quot;20&quot;) int count) { return spittleRepository.findSpittles(max, count); } } 上述片段中的@RequestParam如果有value属性，则value值必须与前台的入参名称一致，如果@RequestParam没有value属性，那其后的方法形参必须与前台的入参名称一致。 △ 通过HttpServletRequest来传递参数后台代码： @Controller @RequestMapping(&quot;/spittles&quot;) public class SpittleController { @Autowired private SpittleRepository spittleRepository; @RequestMapping(method = RequestMethod.GET) public List&lt;Spittle&gt; spittles(HttpServletRequest request) { long max = request.getParameter(&quot;max&quot;); long count = request.getParameter(&quot;count&quot;); return spittleRepository.findSpittles(max, count); } } 方式二：路径变量。请求路径中的一部分作为查询参数。请求 url：http://localhost:8080/spittles/1845647 尽管，这个也可以使用如http://localhost:8080/spittles？spittleId=1845647这样的rul来请求，但是一般在使用GET方法获取资源时，最合适的方式是通过路径，而不是参数。如果这里改成第二种url，则本质上是通过HTTP发起的RPC。 @Controller @RequestMapping(&quot;/spittles&quot;) public class SpittleController { @Autowired private SpittleRepository spittleRepository; @RequestMapping(value = &quot;/{spittleId}&quot;, method = RequestMethod.GET) public String spittle(@PathVariable(&quot;spittleId&quot;) long spittleId, Model model) { model.addAttribute(spittleRepository.findOne(spittleId)); return &quot;spittle&quot;; } } @RequestMapping(value = “/{spittleId}”, method = RequestMethod.GET)中的spittleId是一个占位符，这个占位符的名字可以随意取，但是这个占位符在url路径中的位置必须与请求url中的位置保持一致，占位符必须使用大括号“{}”表示。另外，这个占位符的名字与注解PathVariable的值spittleId是一致的，如果注解PathVariable不带参数，那么spittle方法的一个参数spittleId必须与占位符的名字一致。 方式三：表单参数。表单参数用于接收大量的用户输入参数，以对输入参数完成处理。 △ 使用对象传递参数@Controller @RequestMapping(&quot;/spittles&quot;) public class SpittleController { @Autowired private SpittleRepository spittleRepository; @RequestMapping(value = &quot;/register&quot;, method = GET) public String showRegistrationForm() { return &quot;registerForm&quot;; } @RequestMapping(value = &quot;/register&quot;, method = POST) public String processRegistration(@Valid Spitter spitter, Errors errors) { if (errors.hasErrors()) { return &quot;registerForm&quot;; } spitterRepository.save(spitter); return &quot;redirect:/spitter/&quot; + spitter.getUsername(); } @RequestMapping(value = &quot;/{username}&quot;, method = GET) public String showSpitterProfile(@PathVariable String username, Model model) { Spitter spitter = spitterRepository.findByUsername(username); model.addAttribute(spitter); return &quot;profile&quot;; } } 方法showRegistrationForm()和processRegistration(@Valid Spitter spitter, Errors errors)所接收的url都是“/spittles/register”，前者用于接收GET查询，并返回一个“registerForm”视图，后者用于接收POST提交的表单，并重定向到”/spitter/“ + spitter.getUsername()视图。 也就是重定向（redirect）到showSpitterProfile(@PathVariable String username, Model model)方法所表示的视图，这里的Model中保存的GET请求获取到的结果参数集。 本例中的接收用户提交表单的方法processRegistration(@Valid Spitter spitter, Errors errors)，形参包含一个Spitter对象，这个对象中的属性字段与用户HTML中填写的参数名是对应的，如下： public class Spitter { private Long id; @NotNull @Size(min=5, max=16) private String username; @NotNull @Size(min=5, max=25) private String password; @NotNull @Size(min=2, max=30) private String firstName; @NotNull @Size(min=2, max=30) private String lastName; @NotNull @Email private String email; //setter&amp;getter方法 ... ... } 前台代码form中submit后没有action属性，所以submit请求的url跟上一步GET到这个HTML页面的url是一致的，即“/spittles/register”。 &lt;html&gt; &lt;head&gt; &lt;title&gt;Spitter&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;c:url value=&quot;/resources/style.css&quot; /&gt;&quot; &gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form method=&quot;POST&quot;&gt; First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot; /&gt;&lt;br/&gt; Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; /&gt;&lt;br/&gt; Email: &lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;br/&gt; Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; △ 直接传递参数字段作为参数进行传递。以方法processRegistration为例后台代码： @Controller @RequestMapping(&quot;/spittles&quot;) public class SpittleController { @Autowired private SpittleRepository spittleRepository; @RequestMapping(value = &quot;/register&quot;, method = POST) public String processRegistration(HttpServletRequest request,ModelMap map,String username,String password,String firstName,String lastName, String email) { Spitter spitter = new Spitter(); spitter.setUsername(username); spitter.setPassword(password); spitterRepository.save(spitter); return &quot;redirect:/spitter/&quot; + spitter.getUsername(); } }","tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"基于dubbo的微服务部分容器化部署","date":"2018-10-22T15:20:07.273Z","path":"2018/10/22/基于dubbo的微服务部分容器化部署/","text":"Vmall微服务特点 Vmall采用基于dubbo+zookeeper的RPC微服务化架构方案，划分40多个微服务。缓存层采用redis、memcache，持久层采用mysql，消息框架使用rocketMQ。 微服务间即存在RPC调用，又包含部分http调用。 生产环境同时部署在华为公有云的北京、廊坊和广州三地，三地间通过专线建立连接。 容器化策略 将服务分成有状态服务和无状态服务，因对数据要求较高，所以数据库等有状态服务暂时保持部署在ECS，仅对无状态服务实行容器化。 分步骤实施，初始阶段选取两个微服务进行容器化灰度试点，保证容器化的风险可控。 对docker swarm、k8s、mesos+Marathon、华为公有云CCE和华为IT平台的HIC的对比，鉴于成本、可靠性、稳定性等因素，决定采用华为公有云CCE。 面临的问题因为华为云的CCE是基于K8s的云服务引擎，很好的保证了高可用、弹性伸缩、监控告警、滚动升级、镜像管理等功能，所以我们只需要应对一下几个关键问题： 统一配置中心，容器化需要统一配置中心的支持。 日志采集，需要解决日志的集中采集和处理问题。 部分服务的容器化，需要解决容器服务的dubbo注册问题和容器服务与非容器服务之间的网络通信问题。 实施过程1.统一配置中心。选用携程的apollo开源组件。2.日志采集与处理。将应用日志输出到宿主机目录，通过统一开源组件收集。3.容器部署： 步骤一 镜像制作 开机启动脚本 #!/bin/bash if [[&quot;${ELB_IP}&quot;x!=&quot;&quot;x]]&amp;&amp;[SERVICE_NAME] ; then cp /etc/hosts /etc/hosts.temp sed -i &apos;s/^.*$&apos;{SERVICE_NAME}&apos;/&apos;${ELB_IP}&apos; $&apos;{SERVICE_NAME}&apos;/g&apos; /etc/hosts.temp cat /etc/hosts.temp &gt; /etc/hosts else echo &quot;Please set env SERVICE_NAME and ELB_IP&quot; return1 fi source /etc/profile bash /root/myApp/bin/start.sh run 步骤二 镜像上传 步骤三 创建cce集群 步骤四 创建工作负载 步骤五 创建负载均衡 步骤六 为工作负载创建访问方式 步骤七 域名访问方式 四层负载均衡和七层负载均衡 遇到的问题？1）跨k8s集群的docker与zookeeper间的通信问题！dubbo注册原理：dubbo服务提供者在注册服务到zookeeper时，如果dubbo:protocol中配置了本机IP和port会使用配置的参数到zookeeper注册，本机则会监听该port，如果服务的dubbo:protocol没有配置过本机IP和port时，dubbo服务提供者将通过网卡自己获取本机IP，同时port默认取20880，docker中的dubbo服务会获取到docker的私有ip。问题：实际试点时，dubbo和zookeeper是在单独的虚拟机上，并不属于k8s集群，而服务提供者在docker中，此时服务提供者将docker私有IP注册到zookeeper上，服务提供者定时向zookeeper发送TCP心跳保持连接，当消费者查找到这个docker的Ip，并去连接时就会出现找不到IP的问题，因为docker的私有Ip不能暴露到pod外。解决方法：方法一 通过iptables路由规则，通过多层桥接配置实现网络连通。方法二 通过配置私网四层负载均衡，将负载均衡和docker做IP端口映射，并将负载均衡IP配置到dubbo:protocol中。消费者会访问负载均衡IP和端口，进而找到docker中的应用。在公有云上四层负载均衡是免费的，建议每个服务申请一个负载均衡，这样端口配置会更灵活。这里需要配套修改镜像，使用环境变量的方式将负载均衡IP替换docker的hosts文件中的私有IP，并在k8s的工作负载上配置环境变量。这个方法还存在一个缺点，相同负载均衡对应的相同服务注册到zookeeper上时，显示是完全相同的两条，无法区分。方法三 升级dubbo到最新的2.6.4版本，该版本增加了对容器化的支持，它将注册IP、port与监听IP、port做了区分，向zookeeper注册时可以使用负载均衡的参数，docker服务本地监听仍然使用本地私有IP和port。 日志输出问题配置中心问题https://blog.csdn.net/liu306487103/article/details/52221986https://www.kancloud.cn/good-rain/micro-services/248954https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D VPC与子网k8sdocker","tags":[{"name":"容器化","slug":"容器化","permalink":"http://yoursite.com/tags/容器化/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"dubbo","slug":"dubbo","permalink":"http://yoursite.com/tags/dubbo/"}]},{"title":"Paxos","date":"2018-10-11T23:28:05.438Z","path":"2018/10/12/Paxos算法/","text":"1. 拜占庭将军问题拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。【百度百科】 拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。 拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。拜占庭容错协议必须处理这些失效，并且这些协议还要满足所要解决的问题要求的规范。这些算法通常以其弹性t作为特征，t表示算法可以应付的错误进程数。 因为存在错误进程，因此拜占庭将军问题只有在n ≥ 3t+1时才有解，其中n是系统中进程的总数。 2. 希腊议会制度在古希腊一个叫Paxos的小岛，岛上采用议会的形式通过法令，议会中的议员通过信使进行消息的传递。议员和信使都是兼职的，他们随时可能会离开议会，并且信使可能会重复传递消息，也可能一去不复返。因此，议会协议要保证在这种情况下法令仍然能够正确的产生，并且不会出现冲突。 Paxos是一种为提高分布式系统容错的一致性算法，意在解决拜占庭将军问题。 3. Paxos算法详解3.1 问题描述假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点： 在这些被提出的提案中，只有一个会被选定。 如果提案没有被提出，就不会有被选定的提案。 当一个提案被选定后，进程应该可以获取被选定的提案信息。 一致性的安全需求有以下几点： 只有被提出的提案才能被选定。 只能有一个值被选定。 如果某个进程认为某提案被选定了，那么这个提案必须是真的被选定的那个。 3.2 算法陈述算法的推导过程比较复杂，这里不做解释。通过算法的推导，我们直接看结论。 算法的两阶段提交过程阶段一 1）Proposer选择一个提案编号M，然后向Acceptor的某个超过半数的子集成员发送编号为M的Prepare请求。 2）Proposer选择一个提案编号为M的Prepare请求，且编号M大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M的提案。 阶段二 1）如果Proposer收到来自半数以上的Acceptor对于其发出的编号为M的Prepare请求的响应，那么它就会发送一个针对[M,V]提案的Accept请求给Acceptor。注意，V的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。 2）如果Acceptor收到这个针对[M,V]提案的Accept请求，只要该Acceptor尚未对编号大于M的Prepare请求作出响应，他就可以通过这个提案。 算法的提案获取过程如何让Learner获取提案？ 方案一 Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有Learner。 这个方案需要让每个Acceptor与所有Learner逐个进行一次通信，通信次数至少为二者个数的乘积。 方案二 所有的Acceptor将它们对提案的批准情况,统一发送给一个特定的Learner(主Learner)。主Learner负责通知其他Learner。 这个方案的缺点是，主Learner故障时会出现问题。 方案三 对方案二进行改进，主Learner是一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他Learner。 如何保持算法的活性 为保证Paxos算法流程的可持续性，避免陷入死循环，必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这个主Proposer提出的最高编号的提案时会被通过。如果这个Proposer发现当前算法流程中已经有一个编号更大的天被提出或正在接受批准，那么它会丢弃当前编号较小的提案，并最终选出一个编号足够大的提案。 Paxos引入了“少数服从多数”的概念，解决了单点故障、脑裂和无限期等待问题，并且支持分布式节点角色之间的轮换，是目前最优秀的分布式一致性算法之一。目前，分布式锁服务Google Chubby，数据库Hypertable和zookeeper中都使用了Paxos来解决分布式一致性问题。","tags":[{"name":"分布式一致性算法","slug":"分布式一致性算法","permalink":"http://yoursite.com/tags/分布式一致性算法/"},{"name":"拜占庭将军问题，希腊议会制度","slug":"拜占庭将军问题，希腊议会制度","permalink":"http://yoursite.com/tags/拜占庭将军问题，希腊议会制度/"}]},{"title":"BASE理论","date":"2018-10-11T15:27:43.197Z","path":"2018/10/11/BASE理论/","text":"BASE理论是基本可用（Basically Available）、软状态（Soft state）、最终一致性（Eventually），是eBay架构师Dan Pritchett提出的。它是基于CAP理论发展而来，主要是针对大规模互联网系统分布式实践的总结。基本思想史即使无法做到强一致性，也要达到最终一致性。 基本可用系统在出现不可预知故障时，允许损失部分可用性，以保证整体可用性。比如损失响应时间换取最终结果，或是出现流量高峰时引导用户到降级页面。 弱状态允许系统中的数据存在中间状态，而这种中间状态不会影响整体可用性。比如数据在不同系统节点间同步时存在延时的情况。 最终一致性系统中所有数据副本，经过一段时间同步后，最终能达到一个一致状态。 最终一致性的几种变种： 因果一致性（Causal consistency）进程A更新数据后通知进程B，则B访问该数据时，获取的都是被A更新后的数据。与A无因果关心的C访问数据时，则没有限制。 读己之所写（Read you write）进程A更新一个数据项之后，它自己总能访问更新过的最新值，看不到旧值。 会话一致性（Session consistency）将系统数据的访问过程限定在一个会话当中，保证同一个有效会话中实现“读己之所写”的一致性。 单调读一致性（Monotonic read consistency）如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。 单调写一致性（Monotonic write consistency）保证来自同一个进程的写操作被顺序地执行。 想一想数据库的主从模式属于哪一种类型？","tags":[{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/tags/分布式算法/"}]},{"title":"2PC与3PC","date":"2018-10-10T23:39:52.378Z","path":"2018/10/11/2PC和3PC/","text":"在分布式系统中，当一个事务操作需要跨越多个分布式节点时，为了保证事务处理的ACID特性，需要引入一个“协调者”的组件来统一调度所有分布式节点的执行逻辑，被调度的分布式节点称为“参与者”。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。这个思想衍生出二阶段提交和三阶段提交两种协议。 2PC（Two-Phase Commit）目的是为了保证分布式系统架构下所有节点在进行事务处理过程中能够保持原子性和一致性而设计的算法。绝大部分关系型数据库采用的都是二阶段提交协议来完成分布式事务的处理。 协议说明 阶段一：提交事务请求 事务询问。协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。 执行事务。各参与者执行事务操作，并将Undo和Redo信息记入事务日志中。 各参与者向协调者反馈事务询问的响应。如果参与者成功执行了事务操作，则反馈给协调者Yes响应，表示事务可执行；否则就给协调者反馈NO响应，表示事务不可以执行。 这个阶段通常也称为“投票阶段”。 阶段二：执行事务提交协调者根据各参与者的反馈情况决定是否进行事务提交操作。包含两种可能： 执行事务提交当所有参与者都反馈Yes响应时，协调者就会执行事务提交。执行过程如下 发送提交请求协调者向所有参与者发送Commit请求。 事务提交参与者收到Commit请求后正式执行事务提交操作，在完成提交后释放整个事务执行期间占用的事务资源。 返回事务提交结果向协调者发送Ack消息。 完成事务协调者接收到所有参与者反馈的Ack消息后，完成事务。 中断事务当任何一个参与者向协调者反馈NO，或超时后协调者仍未收到某些参与者的响应，就会中断事务。 发送事务回滚请求。协调者向所有参与者发送Rollback请求。 事务回滚。参与者接收到Rollback后，会利用其在阶段一种记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。 反馈事务回滚结果。参与者在完成事务回滚之后，向协调者发送Ack消息。 中断事务。协调者收到所有参与者的Ack消息后，完成事务中断。 优缺点优点：原理简单，实现方便缺点：同步阻塞、单点问题、脑裂、保守 同步阻塞提交的执行过程中，所以参与者都需要等待其他参与者的响应，无法执行其他任何操作。限制性能。这是最大的问题。 单点问题协调者如果出现问题，整个系统提交流程将无法进行，如果恰好在阶段二故障，则参与者将一直锁定事务资源状态，无法继续工作。 数据不一致（脑裂）阶段二时，若协调者已向参与者发送Commit，此时发生局部网络异常或协调者只发送了部分Commit后自身崩溃，则只有部分参与者接收到Commit请求。就会出现部分参与者提交，部分未提交，导致数据不一致现象。 保守协调者指示参与者进行事务提交询问的过程中，参与值故障无法响应时，协调者只能通过超时判断是否中断。缺少一个完善的容错机制，任意一个节点失败都会导致整个事务的失败。 2PC协议因为其阻塞的特性，在执行过程中需要锁住其他更新，且容错不够好，所以对其支持的成本较高。分布式系统用2PC协议更多的是处理多个数据分片操作的原子性。而同一个数据分片的多个副本之间的数据一致性则更多的使用Paxos来实现。 3PC(Three-Phase Commit)三阶段提交协议，对二阶段提交协议的不足进行了改进。 协议说明 其将二阶段提交的“提交事务请求”过程一分为二，形成了由CanCommit、PreCommit、do Commit三个阶段组成的事务处理协议。 阶段一：CanCommit 事务询问协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待参与者响应。 各参与者向协议者反馈事务询问响应参与者受到canCommit请求后，正常情况下，如果认为可以执行事务，则返回Yes响应，并进入预备状态，否则反馈No响应。 阶段二：PreCommit两种可能的操作： 执行事务预提交假如协调者收到所有的响应Yes，则会执行事务预提交。 发送预提交请求协调者向所有参与者发出preCommit请求，并进入Prepared阶段。 事务预提交参与者收到preCommit后，执行事务操作，并将Undo和Redo信息记录到事务日志中。 各参与值向协调者反馈事务执行的响应如果参与者执行了事务操作，就会给协调者反馈Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。 中断事务假如任何一个参与者反馈的是No响应，或者超时未响应，那么协调者就会中断事务。 发送中断请求协调者向所有参与者发送abort请求。 中断事务无论收到来自协调者的abort请求，或是等待协调者请求过程中出现超时，参与者都会中断事务。 阶段三：doCommit进行真正的事务提交操作，存在两种情况： 执行提交 发送提交请求协调者收到所有响应者的Ack响应，他将从“预提交”状态转化到“提交”状态，并向所有参与者发送doCommit请求。 执行事务提交参与者收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。 反馈事务提交结果参与者在完成事务提交之后，向协调者发送Ack消息。 完成事务协调者接收到所有参与者的Ack消息后，完成事务。 中断事务任意一个参与者反馈No响应，或协调者等待超时后，协调者就会中断事务。 发送中断请求协调者向所有参与者节点发送abort请求。 事务回滚参与者接收到abort请求后利用在阶段二中的Undo信息来执行回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。 反馈事务回滚结果参与者完成事务回滚后，向协调者发送Ack消息。 中断事务协调者接收到所有参与者反馈的Ack消息后，中断事务。 在阶段三中可能存在两种故障： 协调者出现问题。 协调者和参与者之间的网络出现故障。 无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或abort请求，针对这样的异常情况，参与者都会在等待超时后，继续进行事务提交。 优缺点优点：解决了二阶段提交参与者无限期阻塞的问题，并且在出现单点故障后能继续达成一致。缺点：在第三阶段，如果参与者没有接收到协调者发出的abort请求，那超时后依然会自动完成事务提交，必然出现一致性问题。另外，3PC增加了交互的次数，降低了性能。 3PC保证了CAP理论中的C和A，但是无法保证P——分区容错性，在实际操作中极少使用3PC。","tags":[{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/tags/分布式算法/"}]},{"title":"ACID理论","date":"2018-10-09T23:38:41.033Z","path":"2018/10/10/ACID/","text":"ACID是事务的四个特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 原子性（Atomicity）事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态：全部执行成功、全部不执行。 一致性（Consistency）事务的执行不能破坏数据的完整性和一致性。数据在所有应用、服务和数据库中的状态必须是一致的，并且是无缺失的。 隔离性（Isolation）并发环境中，不同事务之间是隔离的，相互独立，无干扰。SQL规范中隔离性有4中级别：未授权读取、授权读取、可重复读取、串行化。 持久性（Durability）事务一旦提交，其变更的数据的状态就会永久保存。 思考：什么样的场景需要满足ACID？什么样的场景需要满足BASE理论?","tags":[{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/tags/分布式算法/"}]},{"title":"CAP理论","date":"2018-09-12T15:36:58.684Z","path":"2018/09/12/CAP理论/","text":"分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition rolerance）这三项基本需求，最多只能同时满足两种。 一致性：分布式环境中，数据在多个副本间保持一致。数据在两个节点上存在副本，数据在一个节点上更新后，在另一个节点上能马上读取到新的值（强一致性或严格一致性）。 可用性：对于用户的操作，总能在有限时间内返回结果。 分区容错性：分布式系统在遇到任何网络分区发生故障时，仍然能保证对外提供满足一致性和可用性的服务，除非是整个网络故障。 CAP理论示意图 CAP理论应用 既然是分布式系统，肯定是能满足分区容错性的，特别是现在的微服务系统。所以设计师往往会在一致性（Consistency）和可用性（Availability）之间抉择。 参考《从PAXOS到ZOOKEEPER分布式一致性原理与实践》","tags":[{"name":"分布式算法","slug":"分布式算法","permalink":"http://yoursite.com/tags/分布式算法/"}]},{"title":"MySQL索引","date":"2018-09-11T16:03:58.217Z","path":"2018/09/12/索引分类/","text":"索引分类 按照字段个数划分：单列索引、组合索引 按照唯一性划分：普通索引、唯一索引 MyISAM特殊索引：全文索引（char、varchar、text类型的列，不支持多列，用于全文搜索）、空间索引（非空字段） 索引创建方法一：创建表时创建 CREATE TABLE &lt;table_name&gt; [col_name data_type] [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length],...)[ASC|DESC] UNIQUE|FULLTEXT|SPATIAL 均为可选，分别表示唯一索引、全文索引、空间索引。 INDEX|KEY 含义相同均指创建索引。 index_name为索引名，不指定时与列名相同。 col_name要创建索引的列名。 length可选，表示索引长度，只有字符串类型的字段才可以指定。 ASC|DESC可选，表示升序还是降序。 方法二：已存在的表上创建索引 ALTER TABLE &lt;table_name&gt; ADD [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length],...)[ASC|DESC] CREATE [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name] ON &lt;table_name&gt;(col_name[length],...)[ASC|DESC] 索引删除方法一：ALTER语句删除 ALTER TABLE DROP INDEX &lt;index_name&gt; 方法二：DROP语句删除 DROP INDEX &lt;index_name&gt; ON &lt;table_name&gt;","tags":[{"name":"mysql基础","slug":"mysql基础","permalink":"http://yoursite.com/tags/mysql基础/"}]},{"title":"SQL性能优化一——减少数据库交互次数","date":"2018-09-11T16:00:27.655Z","path":"2018/09/12/SQL性能优化一——减少数据库交互次数/","text":"把多条SQL语句合并为一条，可减少数据库交互次数，提高性能，这是一种简单的优化改进。 创建表t_user CREATE TABLE `t_user` ( `id` tinyint(10) UNSIGNED AUTO_INCREMENT NOT NULL, `name` varchar(255) DEFAULT NULL, `age` int(10) DEFAULT NULL, `updatetime` datetime DEFAULT NULL, INDEX index_name(name), ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1 整合DDL语句多条的写法： ALTER table t_user ADD COLUMN uid TINYINT UNSIGNED; ALTER table t_user ADD UNIQUE INDEX (uid); ALTER table t_user DROP INDEX index_name, ADD INDEX index_name_age (name, age); ALTER TABLE t_user ADD PRIMARY KEY (id); 合并为一条： ALTER TABLE t_user ADD COLUMN uid TINYINT UNSIGNED, ADD UNIQUE INDEX (uid), DROP INDEX index_name, ADD INDEX index_name_age (NAME, age), ADD PRIMARY KEY (id); 2 整合DML语句2.1 INSERT的整合INSERT INTO &lt; table_name &gt; ( columnname1, columnname2 ,...) VALUES ( columnvalue1, columnvalue2 ,...) , ..., ( columnvalue1, columnvalue2 ,...); 整合前： INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200); INSERT INTO t_user (id, name, age) VALUES (2, &apos;张无忌&apos;, 50) ; 整合后 INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200), (2, &apos;张无忌&apos;, 50) ; 2.2 UPDATE的整合在更新目标一致的情况下可使用下面语句整合。 UPDATE &lt;table_name&gt; set &lt;columnname&gt;=&lt;columnvalue&gt;, ... where &lt;columnnamen&gt; in (value1, value2,...); 2.3 INSERT和UPDATE的整合当在满足条件时，可合并：先检查要插入的主键是否存在，如果不存在就插入行，如果存在就执行update操作。 INSERT ... ON DUPLICATE KEY UPDATE 举例： id是主键，当不存在id=1的数据是，插入一行；若存在，则将id=1的那行数据的age更新为201。 INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200) ON DUPLICATE KEY UPDATE age = 201; 注意：该语句存在死锁风险，请在满足以下两条件时使用（1、尽量不对存在多个唯一键的table使用该语句；2、在有可能有并发事务执行的insert 的内容一样情况下不使用该语句）bug","tags":[{"name":"mysql性能优化","slug":"mysql性能优化","permalink":"http://yoursite.com/tags/mysql性能优化/"}]},{"title":"MySQL唯一性约束","date":"2018-09-11T15:50:38.572Z","path":"2018/09/11/MySQL唯一性约束/","text":"主键一个表只能存在一个，且不允许空值 定义列时指定： &lt;col_name&gt; &lt;data_type&gt; PRIMARY KEY [DEFAULT &lt;value&gt;] 定义完列后指定： [CONSTANT&lt;key_name&gt;] PRIMARY KEY(&lt;col_name1&gt;,...) 唯一性约束一个表允许有多个，且允许列上存在一个空值 定义列时指定： &lt;col_name&gt; &lt;data_type&gt; UNIQUE 定义完列后指定： [CONSTANT&lt;key_name&gt;] UNIQUE(&lt;col_name1&gt;,...)","tags":[{"name":"mysql基础","slug":"mysql基础","permalink":"http://yoursite.com/tags/mysql基础/"}]},{"title":"AUTO_INCREMENT","date":"2018-09-11T15:44:32.540Z","path":"2018/09/11/AUTO_INCREMENT/","text":"一个表只能有一个字段使用自增约束，且字段必须是主键的一部分。其约束的字段可以是任何整型类型（TINYINT、INT、SMALLIN、BIGINT）。默认从1开始，每增加一行自动加1。 设置语法： &lt;col_name&gt; &lt;data_type&gt; AUTO_INCREMENT","tags":[{"name":"mysql基础","slug":"mysql基础","permalink":"http://yoursite.com/tags/mysql基础/"}]},{"title":"","date":"2018-09-11T15:18:19.975Z","path":"2018/09/11/库存/","text":"概述 库存是一个复杂度很高的核心系统，提供前端实时查询的能力和后端的商品扣减，还要处理订单取消问题。这对库存系统的准确性和可靠性提出了很高的要求，在各种场景下能保证数据的准确，在遇到突发流量时能保证高可用，除此之外，还需要提供熔断和降级的能力，保证在极端情况下不拖垮主站。 技术架构 DUBBO是一款非常优秀的 RPC 层框架，提供高性能和透明化的RPC远程服务调用方案,以及SOA服务治理方案。 RocketMQ是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。 Redisson是架设在Redis基础上的一个Java驻内存数据网格。 Redis单线程的高速缓存数据库，支持持久化、事务，通过哨兵和自动分区提供高可用。 Druid阿里的开源软件，专为监控而生的数据库连接池。 Mybatis是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。 MySQL关系型数据库系统。 库存扣减 为简化库存系统，库存系统之上建立交易系统和订单管理系统，库存只负责管理商品扣减。 1. 何时扣减 库存扣减一般有三个时机： 加购物车时扣减。商品加入购物车，并不能说明用户确实要购买，实际转化率并不高，假如此时扣库存，会导致库存被占用而无法释放，影响正常销售。 提交订单时扣减。用户下单后还有一个支付操作，如果用户仅仅下单而不进行支付，这部分库存将会被无效占用，影响正常销售。这里可以做一个支付时限，如果超过时限未支付，订单将被取消，预占得库存被返还。 支付时扣减。用户进行支付，说明交易即将完成，这部分是必须要留住的订单和用户，如果此时扣库存，出现库存不足导致用户支付失败会严重影响用户体验。 目前为提高库存效率和用户体验，系统采用提交订单扣库存的策略。这也是大部分电商平台采用的扣减策略。 2. 如何扣减 库存扣减需要应对主要问题是高并发问题、重复扣减问题（超卖）。 上游系统需要配合库存系统做好扩容、限流保护、隔离（业务隔离、数据隔离，以及系统隔离）、动静分离、localCache等措施，通过漏斗模型逐层减少用户流量，避免流量高峰对库存系统的冲击，必要时采用熔断进行降级（比如查询库存时直接返回有库存）。 系统采用Redission+Redis解决高并发问题，Redis是内存数据库性能相对较高，本身支持事务操作,使用Redisson的Rbatch保证事务性，扣减操作包含query和done，两个动作属于一个事务，且done操作保证幂等。 重复扣刷减最常出现的包括用户误操作、黄牛绕过前端进行单、交易系统重试操作： 用户误操作，前端购物车在用户提交订单后将购物车数据删除，无法继续提交。 黄牛绕过前段刷单，前端必须经过交易系统通过RPC调用库存系统，在交易系统中通过风控、调用次数限制、订单令牌等方法限制重复提交订单。 交易系统重试问题，库存系统通过限制一个订单只能进行一次事务性的库存扣减操作，防止交易系统重试导致的饭后服扣减。 还有重要的一点是记录库存扣减日志，在库存回滚时使用。 3. 如何回滚 用户取消订单、用户退货、异常订单流程都会触发库存回滚操作。 为每一个订单设定一个唯一编号，并且按照编号记录库存操作流日志，在需要做库存回滚时依据唯一编号进行库存的返还，回滚操作需要根据编号保证事务性和幂等性。 库存的返还采用同步回滚+异步重试机制，用户取消订单和异常订单的回滚操作首先进行订单的同步逆向操作，在库存返还时如果失败，将唯一编号记录下来，通过异步定时任务进行返还。 用户退货往往涉及到实物商品的退库，因此发起方是订单管理系统，当实物商品完成退库后，订单管理系统将发送MQ消息，库存系统通过订阅消息进行库存返还。 尽管同步回滚+异步重试已经足够保证库存的正确回滚，但是为万无一失，还需要增加一个数据健康度的自我检查能力，超时超次未完成回滚的库存数据需要人工干预。 数据库1.Redis 由于Redis的读写能力远胜于任何关系型数据库，因此在Redis中保存商品库存数据并完成扣减操作。 使用Redis的以下特性保证库存系统的高并发和高可用： 分库分表，因垂直电商业务特点且主站秒杀和抢购并不在主站中，因此为简化逻辑按照SKU维度采用HASH算法进行分库的策略。当然在极端情况下可以对每个SKU继续进行库存拆分，拆分成二级SKU，目前秒杀业务就是采用这种策略。 读写分离，采用Master/Slave模式，其中Master提供写操作，Slave提供读操作，降低Master的压力，提供高速读写操作。 主从+哨兵模式，为保证Redis的可靠性，启用Redis的主从模式和哨兵模式。部署Sentinel集群+Master/Slave集群，实现Master故障的自动发现和切换。 持久化，启用AOF实时持久化功能，保障数据的秒级备份。 2.MySQL 用于记录操作日志和扣减日志。 为提高读写性能采用主从模式和读写分离模式，最初MySQL还承担着库存数据的批量落盘功能，随着Redis库存方式的长时间稳定运行，库存逐渐完全转移到Redis上，MySQL仅仅承担着记录操作日志和扣减日志的功能。","tags":[]},{"title":"线程上下文类加载器的初始化","date":"2018-09-11T15:17:59.437Z","path":"2018/09/11/线程上下文类加载器的初始化/","text":"线程上线文类加载器是JVM类加载模型中的一个特殊存在，在使用时，只需要执行Thread.currentThread().getContextClassLoader()就可以获取线程上线文类加载器，即当前线程的类加载器。但是这个类加载器是什么时候设置的呢？ 我们执行下面代码 public static void main(String[] args) throws ClassNotFoundException, SQLException { System.out.println(Thread.currentThread().getContextClassLoader()); } 输出结果是 sun.misc.Launcher$AppClassLoader@c387f44 即使用的是AppClassLoader类加载器，但是这个上下文中的加载器是什么时候设置进去的？ 我们都知道，在调用类的静态方法时，类及其父类都会被初始化，初始化过程中最重要的部分就是执行类中的静态代码块、及初始化成员变量。但Thread的静态代码块中只是注册了一个本地方法而已。 static { registerNatives(); } 我们看看Thread对象被初始化时做了什么？ public Thread() { init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); } private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null); } private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) { if (name == null) { throw new NullPointerException(&quot;name cannot be null&quot;); } this.name = name.toCharArray(); Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it&apos;s an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn&apos;t have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); // 这里在做线程上下文类加载器的赋值操作，如果系统没有设置安全管理器，则会调用Thread的getContextClassLoader()方法获取类加载器。而parent是currentThread()即启动本线程的线程。把父线程的上下文类加载器给继承过来。这里的父子关系是指谁启动谁的关系，比如在线程A里面启动了线程B，那B线程的父线程就是A。 if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } @CallerSensitive public ClassLoader getContextClassLoader() { if (contextClassLoader == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) { ClassLoader.checkClassLoaderPermission(contextClassLoader, Reflection.getCallerClass()); } return contextClassLoader; } 第一个被启动的线程是哪个？那第一个启动的线程（包含main方法的那个线程）里面的contextClassLoader是谁设置的呢？不要忘记，Main本身就启动了一个线程。这要看 sun.misc.Launcher 这个类的源码。Launcher是JRE中用于启动程序入口main()的类。 loader = AppClassLoader.getAppClassLoader(extcl); Thread.currentThread().setContextClassLoader(loader); 这里截取的两行代码出自 Launcher 的构造方法。第一行用一个扩展类加载器extcl构造了一个系统类加载器loader，第二行把loader设置为当前线程（包含main方法）的类加载器。所以，我们启动一个线程的时候，如果之前都没有调用 setContextClassLoader 方法明确指定的话，默认的就是系统类加载器。 参考https://www.cnblogs.com/cz123/p/6867345.htmlhttps://blog.csdn.net/gabele/article/details/71250108","tags":[{"name":"类加载","slug":"类加载","permalink":"http://yoursite.com/tags/类加载/"}]},{"title":"CAS","date":"2018-09-06T23:37:51.865Z","path":"2018/09/07/CAS/","text":"CAS保证了并发时，操作和冲突检查的原子性。 CAS最初用到硬件指令上，是一条硬件指令，包括3个操作数：内存位置（地址）用V表示、旧的预期值用A表示、新值用B表示，在执行时，仅当V符合旧的预期值A时，处理器才会用新值B更新V的值，否则不执行更新，但无论是否更新了V，都会返回V的旧值，这个过程是一个原子操作。 jdk1.5后，java开始使用CAS操作，该操作由sun.misc.Unsafe类中的compareAndSweepInt()和compareAndSweepLong()等几个方法包装提供。在虚拟机即时编译出的结果就是一条平台相关的CAS指令，没有JAVA方法的调用过程。（即过程是原子性的）。这个功能在JDK1.8又做了增强，重试的过程也是在机器的指令集上执行的。 CAS的ABA问题，如果V的初始值是A，在第一次读取时也是A，但是在读取后——赋值前这期间V被改为B，然后又被改回到A，此时，CAS操作会认为V没有被改变过。这个就是著名的ABA问题。","tags":[{"name":"并发理论","slug":"并发理论","permalink":"http://yoursite.com/tags/并发理论/"}]},{"title":"mysql驱动的类加载过程","date":"2018-09-03T14:05:09.918Z","path":"2018/09/03/JDBC类加载过程分析/","text":"JDBC是开发中常用的驱动程序，但一直没有深入了解过其加载过程。JDBC驱动的加载也是线程上下文类加载器使用的经典案例。最近有时间研究一下源码，结合JVM线程上下文类加载器的知识做个总结。 public static void main(String[] args) throws ClassNotFoundException, SQLException { // 加载mysql驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Connection connection = DriverManager.getConnection( &quot;jdbc://localhost:3306/mysql&quot;, &quot;username&quot;, &quot;password&quot;); } #1. Class.forName完成JDBC驱动的加载，底层是如何实现的？ # @CallerSensitive public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException { Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller); } forName继续调用forName0方法，但是forName0方法是个Native方法，看不到源码了，如下： /** Called after security check for system loader access checks have been made. */ private static native Class&lt;?&gt; forName0(String name, boolean initialize, ClassLoader loader, Class&lt;?&gt; caller) throws ClassNotFoundException; 通过查询oracle的技术文档，这个方法返回的是一个由字符串className相同类限定名的Class对象“Returns the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to: Class.forName(className, true, currentLoader)where currentLoader denotes the defining class loader of the current class.” 再来看Class.forName(className, true, currentLoader)方法的技术文档，如下： “Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void. If name denotes an array class, the component type of the array class is loaded but not initialized.For example, in an instance method the expression: Class.forName(&quot;Foo&quot;)is equivalent to:Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())”。 forName方法返回的是一个指定全限定类（接口）名的对象，使用的是指定的类加载器进行加载，如果指定的类加载器为空并且initialize传入true，则使用bootstrapClassLoader进行加载。同时，如果加载器中没有该类的初始化信息，则会对类（接口）进行初始化。 这里就是类（接口）的初始化过程，将字节码信息转化成方法区（元数据区）的数据，并返回一个Class对象到堆内存中，作为调用的入口。 因为我们传入的是com.mysql.cj.jdbc.Driver，因此这个过程就是类Driver被初始化的过程。JVM虚拟机在类初始化过程中最重要的两个动作就是初始化本类和父类的成员变量和执行静态代码块。我们来看看Driver类中的成员变量和静态代码块，如下： public class Driver extends com.mysql.cj.jdbc.Driver { public Driver() throws SQLException { super(); } static { System.err.println(&quot;Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. &quot; + &quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;); } } 代码中static块中只是打印了一个日志，没有其他动作。类加载时如果还会加载父类的信息，来看看com.mysql.cj.jdbc.Driver中是否有静态代码块。 public class Driver extends NonRegisteringDriver implements java.sql.Driver { // // Register ourselves with the DriverManager // static { try { // 实际加载的驱动，这里调用了DriverManager的静态方法，会触发该类的初始化动作 java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException { // Required for Class.forName().newInstance() } } 代码中看到com.mysql.cj.jdbc.Driver中静态块执行了这段代码java.sql.DriverManager.registerDriver(new Driver())，实际上是将自己作为参数传递给了jdk的DriverManager.registerDriver方法，而这个方法是将MySQL的Drive对象包装成jdk的DriverInfo对象后保存到成员变量DriverManager.registeredDrivers的数组中（如果已经存在就什么都不做）。 我们还遗漏了什么？ com.mysql.cj.jdbc.Driver还继承了NonRegisteringDriver，在Driver初始化前会先初始化NonRegisteringDriver中的静态成员变量和代码块，来看下代码： static { try { Class.forName(AbandonedConnectionCleanupThread.class.getName()); } catch (ClassNotFoundException e) { // ignore } } 这里又加载了一个类AbandonedConnectionCleanupThread，这个类什么作用呢？ 再来看一下他的代码： /**This class implements a thread that is responsible for closing abandoned MySQL connections, i.e., connections that are not explicitly closed. There is only one instance of this class and there is a single thread to do this task. This thread&apos;s executor is statically referenced in this same class. **/ public class AbandonedConnectionCleanupThread implements Runnable { private static final ExecutorService cleanupThreadExcecutorService; static Thread threadRef = null; static { cleanupThreadExcecutorService = Executors.newSingleThreadExecutor(new ThreadFactory() { public Thread newThread(Runnable r) { Thread t = new Thread(r, &quot;Abandoned connection cleanup thread&quot;); t.setDaemon(true); // Tie the thread&apos;s context ClassLoader to the ClassLoader that loaded the class instead of inheriting the context ClassLoader from the current // thread, which would happen by default. // Application servers may use this information if they attempt to shutdown this thread. By leaving the default context ClassLoader this thread // could end up being shut down even when it is shared by other applications and, being it statically initialized, thus, never restarted again. t.setContextClassLoader(AbandonedConnectionCleanupThread.class.getClassLoader()); return threadRef = t; } }); cleanupThreadExcecutorService.execute(new AbandonedConnectionCleanupThread()); } .... } 很明显，这里启动了一个守护线程，这个线程用来关闭没有被正确关闭的MySQL链接。 2.DriverManager.getConnection做了什么事情？ 继续看一下文章开头的第二行代码DriverManager.getConnection()做了什么。 @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(&quot;user&quot;, user); } if (password != null) { info.put(&quot;password&quot;, password); } return (getConnection(url, info, Reflection.getCallerClass())); } 将mysql的用户名密码设置到Properties中，连同url、调用类（Reflection.getCallerClass获取）传递给getConnection方法，重点来了： // Worker method called by the public getConnection() methods. private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException { /* * 当传入的caller不为空时，使用传入对象的类加载器，否则就进入到同步块中获取当前线程的上下文中的类加载器。而这类传入的caller不为空，是在DriverManager中调用了Reflection.getCallerClass()获取了DriverManager的Class,因此这里的ClassLoader应该是BootstrapClassLoader，然而系统类加载器是不能被程序获取的（JVM虚拟机限制）。所以callerCL获取了线程上下文类加载器，这里使用了currentThread()，实际上是获取了main方法的类加载器即appClassLoader。 */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) { // synchronize loading of the correct classloader. if (callerCL == null) { callerCL = Thread.currentThread().getContextClassLoader(); } } if(url == null) { throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); } println(&quot;DriverManager.getConnection(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; //轮训成员变量registeredDrivers中的DriverInfo,并创建连接。如果创建连接发生异常则将最近一次异常记录下来，后面会打日志并抛出这个异常。 for(DriverInfo aDriver : registeredDrivers) { // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) { try { println(&quot; trying &quot; + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) { // Success! println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); } } catch (SQLException ex) { if (reason == null) { reason = ex; } } } else { println(&quot; skipping: &quot; + aDriver.getClass().getName()); } } // if we got here nobody could connect. if (reason != null) { println(&quot;getConnection failed: &quot; + reason); throw reason; } println(&quot;getConnection: no suitable driver found for &quot;+ url); throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); } 还有一个重要的点被我们忽略了！初始化一个对象、调用类的静态方法、读取或者设置一个类的静态变量、使用反射调用一个类、子类被初始化。了解了这些，我们再来看DriverManager.getConnection是不是调用了DriverManager的静态方法？是不是触发了DriverManager的初始化过程？ 这里执行了静态代码块： /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;); } 继续看loadInitialDrivers方法干了什么？ private static void loadInitialDrivers() { String drivers; try { // 通过权限控制器获取系统配置jdbc.drivers，这里我们没有设置系统，因此这里返回空 drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() { public String run() { return System.getProperty(&quot;jdbc.drivers&quot;); } }); } catch (Exception ex) { drivers = null; } // If the driver is packaged as a Service Provider, load it. // Get all the drivers through the classloader // exposed as a java.sql.Driver.class service. // ServiceLoader.load() replaces the sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() { public Void run() { // 重点在这里 ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); //记住这里，后面会用到 Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); /* Load these drivers, so that they can be instantiated. * It may be the case that the driver class may not be there * i.e. there may be a packaged driver with the service class * as implementation of java.sql.Driver but the actual class * may be missing. In that case a java.util.ServiceConfigurationError * will be thrown at runtime by the VM trying to locate * and load the service. * * Adding a try catch block to catch those runtime errors * if driver not available in classpath but it&apos;s * packaged as service and that service is there in classpath. */ try{ while(driversIterator.hasNext()) { driversIterator.next(); } } catch(Throwable t) { // Do nothing } return null; } }); println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers); if (drivers == null || drivers.equals(&quot;&quot;)) { return; } String[] driversList = drivers.split(&quot;:&quot;); println(&quot;number of Drivers:&quot; + driversList.length); for (String aDriver : driversList) { try { println(&quot;DriverManager.Initialize: loading &quot; + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); } catch (Exception ex) { println(&quot;DriverManager.Initialize: load failed: &quot; + ex); } } } 上面这段代码因为drivers变量值为空，所以实际起作用的是中间的代码块。先来看代码ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class)传入的参数是java.sql.Driver.class，这里面做了什么： /** * Creates a new service loader for the given service type, using the * current thread&apos;s {@linkplain java.lang.Thread#getContextClassLoader * context class loader}. */ public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } 注释写的很清楚，返回一个server loader，使用的是线程上下文类加载器,currentThread()即当前main线程的类加载器。继续到ServiceLoader.load(service, cl)中看一看： public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader) { // 返回了一个ServiceLoader对象。service和loader是两个构造参数，实际上赋值给成员变量了。 return new ServiceLoader&lt;&gt;(service, loader); } 继续看ServiceLoader是如何构造新对象的，将参数传给了两个成员变量。这里要注意ClassLoader.getSystemClassLoader()获取的并不是boot类加载器，而是本线程的类加载器，即MAIN线程的类加载器appClassLoader。 private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) { service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;); loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload(); } 回到上面，来看一下loadInitialDrivers方法的while循环中的内容，ServiceLoader的iterator()方法返回了一个Iterator类型的对象，ServiceLoader实现了几个方法，看代码 public Iterator&lt;S&gt; iterator() { return new Iterator&lt;S&gt;() { ／／ 因为providers中并没有添加元素，因此元素数必定是０ Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() { ／／loadInitialDrivers方法的while循环在执行hasNext时，因为knownProviders没有元素，所必定走到了lookupIterator.hasNext()，这个里边有个关键的信息。 if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } 上面的过程看注释。 public boolean hasNext() { if (acc == null) { return hasNextService(); } else { PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() { // 注意这行，重点在hasNextService()中。 public Boolean run() { return hasNextService(); } }; return AccessController.doPrivileged(action, acc); } } private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { // PREFIX = &quot;META-INF/services/&quot;，而这里的service在前面ServiceLoader.load(Driver.class)传入的是java.sql.Driver.class, 完成的fullname就是&quot;META-INF/services/java.sql.Driver&quot; String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); } catch (IOException x) { fail(service, &quot;Error locating configuration files&quot;, x); } } while ((pending == null) || !pending.hasNext()) { if (!configs.hasMoreElements()) { return false; } pending = parse(service, configs.nextElement()); } nextName = pending.next(); return true; } 上面的”META-INF/services/java.sql.Driver”是哪里来的？ 来看看我们的驱动包驱动包的这个路径下有个java.sql.Driver命名的文件，而文件中的内容只有一行com.mysql.cj.jdbc.Driver，就是mysql的驱动类名。也就是JDK会查找驱动包中META-INF/services/java.sql.Driver，找到文件中列出的驱动类。 后面不再深入，有兴趣的自己看下。loadInitialDrivers方法的while循环driversIterator.next()方法就是用最初传入的类加载器加载了JDBC的驱动。 PS： 关于Reflection类的使用，可参考博文https://blog.csdn.net/aguda_king/article/details/72355807 关于线程上下文类加载器的理解可以参考博文https://blog.csdn.net/yangcheng33/article/details/52631940和https://blog.csdn.net/gabele/article/details/71250108","tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}]}]