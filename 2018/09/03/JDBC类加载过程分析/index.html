<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="网站简要描述,如：mudaoren's blog."><meta name="keywords" content="网站关键字, key, key1, key2, key3"><title> | 木道人</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">木道人</h1><a id="logo" href="/.">木道人</a><p class="description">看风的必不撒种；望云的必不收割。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta"><a href="/2018/09/03/JDBC类加载过程分析/#comments" class="comment-count"></a><p><span class="date">Sep 03, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><font size="6">mysql驱动的类加载过程</font>

<hr>
<p>　　JDBC是开发中常用的驱动程序，但一直没有深入了解过其加载过程。JDBC驱动的加载也是线程上下文类加载器使用的经典案例。最近有时间研究一下源码，结合JVM线程上下文类加载器的知识做个总结。</p>
<pre><code>public static void main(String[] args) throws ClassNotFoundException,
        SQLException
{
    // 加载mysql驱动
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
    Connection connection = DriverManager.getConnection(
            &quot;jdbc://localhost:3306/mysql&quot;, &quot;username&quot;, &quot;password&quot;);
}
</code></pre><p>#1. Class.forName完成JDBC驱动的加载，底层是如何实现的？ #<br>    @CallerSensitive<br>    public static Class&lt;?&gt; forName(String className)<br>                throws ClassNotFoundException {<br>        Class&lt;?&gt; caller = Reflection.getCallerClass();<br>        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);<br>    }</p>
<p>　　forName继续调用forName0方法，但是forName0方法是个Native方法，看不到源码了，如下：</p>
<pre><code>/** Called after security check for system loader access checks have been made. */
private static native Class&lt;?&gt; forName0(String name, boolean initialize,
                                        ClassLoader loader,
                                        Class&lt;?&gt; caller)
    throws ClassNotFoundException;
</code></pre><p>　　通过查询oracle的技术文档，这个方法返回的是一个由字符串className相同类限定名的Class对象<br>“Returns the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to:<br>　　<code>Class.forName(className, true, currentLoader)</code><br>where currentLoader denotes the defining class loader of the current class.”</p>
<p>　　再来看Class.forName(className, true, currentLoader)方法的技术文档，如下：</p>
<p>“Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.</p>
<p>If name denotes an array class, the component type of the array class is loaded but not initialized.<br>For example, in an instance method the expression:<br>    <code>Class.forName(&quot;Foo&quot;)</code><br>is equivalent to:<br><code>Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())</code>”。</p>
<p>　　forName方法返回的是一个指定全限定类（接口）名的对象，使用的是指定的类加载器进行加载，如果指定的类加载器为空并且initialize传入true，则使用bootstrapClassLoader进行加载。同时，如果加载器中没有该类的初始化信息，则会对类（接口）进行初始化。<br>　　这里就是类（接口）的初始化过程，将字节码信息转化成方法区（元数据区）的数据，并返回一个Class对象到堆内存中，作为调用的入口。</p>
<p>　　因为我们传入的是<code>com.mysql.cj.jdbc.Driver</code>，因此这个过程就是类<code>Driver</code>被初始化的过程。JVM虚拟机在类初始化过程中最重要的两个动作就是初始化本类和父类的成员变量和执行静态代码块。我们来看看<code>Driver</code>类中的成员变量和静态代码块，如下：</p>
<pre><code>public class Driver extends com.mysql.cj.jdbc.Driver {
    public Driver() throws SQLException {
        super();
    }

    static {
        System.err.println(&quot;Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. &quot;
                + &quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;);
    }
}
</code></pre><p>代码中static块中只是打印了一个日志，没有其他动作。类加载时如果还会加载父类的信息，来看看<code>com.mysql.cj.jdbc.Driver</code>中是否有静态代码块。</p>
<pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            // 实际加载的驱动，这里调用了DriverManager的静态方法，会触发该类的初始化动作
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
        }
    }

    /**
     * Construct a new driver and register it with DriverManager
     * 
     * @throws SQLException
     *             if a database error occurs.
     */
    public Driver() throws SQLException {
        // Required for Class.forName().newInstance()
    }
}
</code></pre><p>代码中看到<code>com.mysql.cj.jdbc.Driver</code>中静态块执行了这段代码<code>java.sql.DriverManager.registerDriver(new Driver())</code>，实际上是将自己作为参数传递给了jdk的<code>DriverManager.registerDriver</code>方法，而这个方法是将MySQL的Drive对象包装成jdk的DriverInfo对象后保存到成员变量DriverManager.registeredDrivers的数组中（如果已经存在就什么都不做）。<br>　　我们还遗漏了什么？<br>　　<code>com.mysql.cj.jdbc.Driver</code>还继承了<code>NonRegisteringDriver</code>，在Driver初始化前会先初始化<code>NonRegisteringDriver</code>中的静态成员变量和代码块，来看下代码：</p>
<pre><code>static {
    try {
        Class.forName(AbandonedConnectionCleanupThread.class.getName());
    } catch (ClassNotFoundException e) {
        // ignore
    }
}
</code></pre><p>　　这里又加载了一个类AbandonedConnectionCleanupThread，这个类什么作用呢？ 再来看一下他的代码：</p>
<pre><code>/**This class implements a thread that is responsible for closing abandoned MySQL connections, i.e., connections that are not explicitly closed.
There is only one instance of this class and there is a single thread to do this task. This thread&apos;s executor is statically referenced in this same class.
**/
public class AbandonedConnectionCleanupThread implements Runnable {
    private static final ExecutorService cleanupThreadExcecutorService;
    static Thread threadRef = null;

    static {
        cleanupThreadExcecutorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r, &quot;Abandoned connection cleanup thread&quot;);
                t.setDaemon(true);
                // Tie the thread&apos;s context ClassLoader to the ClassLoader that loaded the class instead of inheriting the context ClassLoader from the current
                // thread, which would happen by default.
                // Application servers may use this information if they attempt to shutdown this thread. By leaving the default context ClassLoader this thread
                // could end up being shut down even when it is shared by other applications and, being it statically initialized, thus, never restarted again.
                t.setContextClassLoader(AbandonedConnectionCleanupThread.class.getClassLoader());
                return threadRef = t;
            }
        });
        cleanupThreadExcecutorService.execute(new AbandonedConnectionCleanupThread());
    }
    ....
}
</code></pre><p>　　很明显，这里启动了一个守护线程，这个线程用来关闭没有被正确关闭的MySQL链接。</p>
<h1 id="2-DriverManager-getConnection做了什么事情？"><a href="#2-DriverManager-getConnection做了什么事情？" class="headerlink" title="2.DriverManager.getConnection做了什么事情？"></a>2.DriverManager.getConnection做了什么事情？</h1><p>　　继续看一下文章开头的第二行代码<code>DriverManager.getConnection()</code>做了什么。</p>
<pre><code>@CallerSensitive
public static Connection getConnection(String url,
    String user, String password) throws SQLException {
    java.util.Properties info = new java.util.Properties();

    if (user != null) {
        info.put(&quot;user&quot;, user);
    }
    if (password != null) {
        info.put(&quot;password&quot;, password);
    }

    return (getConnection(url, info, Reflection.getCallerClass()));
}
</code></pre><p>　　将mysql的用户名密码设置到Properties中，连同url、调用类（Reflection.getCallerClass获取）传递给getConnection方法，重点来了：</p>
<pre><code>//  Worker method called by the public getConnection() methods.
private static Connection getConnection(
    String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {
    /*
     *  当传入的caller不为空时，使用传入对象的类加载器，否则就进入到同步块中获取当前线程的上下文中的类加载器。而这类传入的caller不为空，是在DriverManager中调用了Reflection.getCallerClass()获取了DriverManager的Class,因此这里的ClassLoader应该是BootstrapClassLoader，然而系统类加载器是不能被程序获取的（JVM虚拟机限制）。所以callerCL获取了线程上下文类加载器，这里使用了currentThread()，实际上是获取了main方法的类加载器即appClassLoader。
     */
    ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;
    synchronized(DriverManager.class) {
        // synchronize loading of the correct classloader.
        if (callerCL == null) {
            callerCL = Thread.currentThread().getContextClassLoader();
        }
    }

    if(url == null) {
        throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);
    }

    println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);

    // Walk through the loaded registeredDrivers attempting to make a connection.
    // Remember the first exception that gets raised so we can reraise it.
    SQLException reason = null;

    //轮训成员变量registeredDrivers中的DriverInfo,并创建连接。如果创建连接发生异常则将最近一次异常记录下来，后面会打日志并抛出这个异常。
    for(DriverInfo aDriver : registeredDrivers) {
        // If the caller does not have permission to load the driver then
        // skip it.
        if(isDriverAllowed(aDriver.driver, callerCL)) {
            try {
                println(&quot;    trying &quot; + aDriver.driver.getClass().getName());
                Connection con = aDriver.driver.connect(url, info);
                if (con != null) {
                    // Success!
                    println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());
                    return (con);
                }
            } catch (SQLException ex) {
                if (reason == null) {
                    reason = ex;
                }
            }

        } else {
            println(&quot;    skipping: &quot; + aDriver.getClass().getName());
        }

    }

    // if we got here nobody could connect.
    if (reason != null)    {
        println(&quot;getConnection failed: &quot; + reason);
        throw reason;
    }

    println(&quot;getConnection: no suitable driver found for &quot;+ url);
    throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);
}
</code></pre><p>　　还有一个重要的点被我们忽略了！初始化一个对象、调用类的静态方法、读取或者设置一个类的静态变量、使用反射调用一个类、子类被初始化。了解了这些，我们再来看DriverManager.getConnection是不是调用了DriverManager的静态方法？是不是触发了DriverManager的初始化过程？ 这里执行了静态代码块：</p>
<pre><code>/**
 * Load the initial JDBC drivers by checking the System property
 * jdbc.properties and then use the {@code ServiceLoader} mechanism
 */
static {
    loadInitialDrivers();
    println(&quot;JDBC DriverManager initialized&quot;);
}
</code></pre><p>　　继续看loadInitialDrivers方法干了什么？</p>
<pre><code>private static void loadInitialDrivers() {
    String drivers;
    try {
        // 通过权限控制器获取系统配置jdbc.drivers，这里我们没有设置系统，因此这里返回空
        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            public String run() {
                return System.getProperty(&quot;jdbc.drivers&quot;);
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }
    // If the driver is packaged as a Service Provider, load it.
    // Get all the drivers through the classloader
    // exposed as a java.sql.Driver.class service.
    // ServiceLoader.load() replaces the sun.misc.Providers()

    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
        public Void run() {

            // 重点在这里
            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); //记住这里，后面会用到
            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();

            /* Load these drivers, so that they can be instantiated.
             * It may be the case that the driver class may not be there
             * i.e. there may be a packaged driver with the service class
             * as implementation of java.sql.Driver but the actual class
             * may be missing. In that case a java.util.ServiceConfigurationError
             * will be thrown at runtime by the VM trying to locate
             * and load the service.
             *
             * Adding a try catch block to catch those runtime errors
             * if driver not available in classpath but it&apos;s
             * packaged as service and that service is there in classpath.
             */
            try{
                while(driversIterator.hasNext()) {
                    driversIterator.next();
                }
            } catch(Throwable t) {
            // Do nothing
            }
            return null;
        }
    });

    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);

    if (drivers == null || drivers.equals(&quot;&quot;)) {
        return;
    }
    String[] driversList = drivers.split(&quot;:&quot;);
    println(&quot;number of Drivers:&quot; + driversList.length);
    for (String aDriver : driversList) {
        try {
            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);
            Class.forName(aDriver, true,
                    ClassLoader.getSystemClassLoader());
        } catch (Exception ex) {
            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);
        }
    }
}
</code></pre><p>　　上面这段代码因为drivers变量值为空，所以实际起作用的是中间的代码块。先来看代码<code>ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class)</code>传入的参数是<code>java.sql.Driver.class</code>，这里面做了什么：</p>
<pre><code>/**
 * Creates a new service loader for the given service type, using the
 * current thread&apos;s {@linkplain java.lang.Thread#getContextClassLoader
 * context class loader}.
 */
public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
</code></pre><p>　　注释写的很清楚，返回一个server loader，使用的是线程上下文类加载器,currentThread()即当前main线程的类加载器。继续到<code>ServiceLoader.load(service, cl)</code>中看一看：</p>
<pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,
                                        ClassLoader loader)
{
    // 返回了一个ServiceLoader对象。service和loader是两个构造参数，实际上赋值给成员变量了。
    return new ServiceLoader&lt;&gt;(service, loader);
}
</code></pre><p>　　继续看ServiceLoader是如何构造新对象的，将参数传给了两个成员变量。这里要注意ClassLoader.getSystemClassLoader()获取的并不是boot类加载器，而是本线程的类加载器，即MAIN线程的类加载器appClassLoader。</p>
<pre><code>private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {
    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
    reload();
}
</code></pre><p>　　回到上面，来看一下loadInitialDrivers方法的while循环中的内容，ServiceLoader的iterator()方法返回了一个Iterator类型的对象，ServiceLoader实现了几个方法，看代码</p>
<pre><code>public Iterator&lt;S&gt; iterator() {
    return new Iterator&lt;S&gt;() {

        ／／　因为providers中并没有添加元素，因此元素数必定是０
        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders
            = providers.entrySet().iterator();

        public boolean hasNext() {
            ／／loadInitialDrivers方法的while循环在执行hasNext时，因为knownProviders没有元素，所必定走到了lookupIterator.hasNext()，这个里边有个关键的信息。
            if (knownProviders.hasNext())
                return true;
            return lookupIterator.hasNext();
        }

        public S next() {
            if (knownProviders.hasNext())
                return knownProviders.next().getValue();
            return lookupIterator.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    };
}
</code></pre><p>　　上面的过程看注释。</p>
<pre><code>public boolean hasNext() {
        if (acc == null) {
            return hasNextService();
        } else {
            PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() {
                // 注意这行，重点在hasNextService()中。
                public Boolean run() { return hasNextService(); }
            };
            return AccessController.doPrivileged(action, acc);
        }
    }

private boolean hasNextService() {
        if (nextName != null) {
            return true;
        }
        if (configs == null) {
            try {
                // PREFIX = &quot;META-INF/services/&quot;，而这里的service在前面ServiceLoader.load(Driver.class)传入的是java.sql.Driver.class, 完成的fullname就是&quot;META-INF/services/java.sql.Driver&quot;
                String fullName = PREFIX + service.getName();
                if (loader == null)
                    configs = ClassLoader.getSystemResources(fullName);
                else
                    configs = loader.getResources(fullName);
            } catch (IOException x) {
                fail(service, &quot;Error locating configuration files&quot;, x);
            }
        }
        while ((pending == null) || !pending.hasNext()) {
            if (!configs.hasMoreElements()) {
                return false;
            }
            pending = parse(service, configs.nextElement());
        }
        nextName = pending.next();
        return true;
    }
</code></pre><p>上面的”META-INF/services/java.sql.Driver”是哪里来的？ 来看看我们的驱动包<br><img src="https://i.imgur.com/yseBq0f.png" alt=""><br>驱动包的这个路径下有个java.sql.Driver命名的文件，而文件中的内容只有一行<code>com.mysql.cj.jdbc.Driver</code>，就是mysql的驱动类名。也就是JDK会查找驱动包中META-INF/services/java.sql.Driver，找到文件中列出的驱动类。 后面不再深入，有兴趣的自己看下。loadInitialDrivers方法的while循环driversIterator.next()方法就是用最初传入的类加载器加载了JDBC的驱动。</p>
<p>PS：</p>
<ul>
<li>关于Reflection类的使用，可参考博文<a href="https://blog.csdn.net/aguda_king/article/details/72355807" title="JDK8的@CallerSensitive" target="_blank" rel="noopener">https://blog.csdn.net/aguda_king/article/details/72355807</a> </li>
<li>关于线程上下文类加载器的理解可以参考博文<a href="https://blog.csdn.net/yangcheng33/article/details/52631940" title="真正理解线程上下文类加载器（多案例分析）" target="_blank" rel="noopener">https://blog.csdn.net/yangcheng33/article/details/52631940</a>和<a href="https://blog.csdn.net/gabele/article/details/71250108" title="深入理解Java类加载器：线程上下文类加载器" target="_blank" rel="noopener">https://blog.csdn.net/gabele/article/details/71250108</a></li>
</ul>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/09/07/CAS/" class="pre"></a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-DriverManager-getConnection做了什么事情？"><span class="toc-text">2.DriverManager.getConnection做了什么事情？</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/库存/">库存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/线程上下文类加载器的初始化/">线程上下文类加载器的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/CAS/">CAS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/JDBC类加载过程分析/">JDBC类加载过程分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mudaoren.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>