<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木道人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-09T23:23:42.290Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木道人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>容器化实施中的日志文件权限问题</title>
    <link href="http://yoursite.com/2019/04/10/%E5%AE%B9%E5%99%A8%E5%8C%96%E5%AE%9E%E6%96%BD%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/10/容器化实施中的日志权限问题/</id>
    <published>2019-04-09T23:12:47.240Z</published>
    <updated>2019-04-09T23:23:42.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>　　商城的微服务创建的日志会输出到指定磁盘，提供给专门的运维监控系统分析。微服务在虚拟机上创建的目录默认权限是755，文件默认权限是644，others组中的用户均可正常读取。但在迁移到华为云的CCE后，容器中微服务创建的目录权限变成750，文件权限变成640，这导致others用户无法读取微服务创建的文件。</p><h1 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h1><p>docker中微服务创建的目录和文件的默认权限如下：</p><pre><code>drwxr-x--- 2 tomcat tomcat 4096 Jun 16 17:57 app-server-rw-r----- 1 tomcat tomcat0 Jun 16 17:57 server.log</code></pre><h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><h2 id="1-tomcat应用"><a href="#1-tomcat应用" class="headerlink" title="1.tomcat应用"></a>1.tomcat应用</h2><p>tomcat_home/bin/catalina.sh中的一段脚本：</p><pre><code>#   UMASK           (Optional) Override Tomcat&apos;s default UMASK of 0027# Set UMASK unless it has been overriddenif [ -z &quot;$UMASK&quot; ]; then    UMASK=&quot;0027&quot;fiumask $UMASK</code></pre><p><strong>解释</strong>：umask=0027的后三位表示tomcat创建的文件默认user|group|others三个用户组的权限，计算方法是（6-0）（6-2）（6-7），结果是640，最后一位代表的权限最小是0，权限数字不可能有负值。<br>所以tomcat中可以直接修改UMASK=”0022”，将日志文件的默认权限设置为644。</p><h2 id="2-java应用"><a href="#2-java应用" class="headerlink" title="2.java应用"></a>2.java应用</h2><p>直接使用java的应用不像tomcat一样，它没有umask参数。这时候想到log4j中有个配置参数filePermissions(2.9以上版本才增加的参数)，通过这个参数配置可以指定日志文件的权限。</p><pre><code>&lt;File name=&quot;File&quot; fileName=&quot;server.log&quot; filePermissions=&quot;rw-r--r--&quot;&gt;   &lt;PatternLayout pattern=&quot;%m%n&quot; /&gt;&lt;/File&gt;</code></pre><p>但我们的日志组件使用的是logback，没有这个参数。logback和log4j是同一个作者，这时候自然想到了参考log4j去改造logback。<br>logback.xml中的配置的appender如下：</p><pre><code>&lt;appender name=&quot;FILE&quot; class= &quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;          &lt;!-- 按天来回滚，如果需要按小时来回滚，则设置为{yyyy-MM-dd_HH} --&gt;          &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;               &lt;fileNamePattern&gt;/opt/log/test.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;               &lt;!-- 如果按天来回滚，则最大保存时间为1天，1天之前的都将被清理掉 --&gt;               &lt;maxHistory&gt;30&lt;/maxHistory&gt;          &lt;!-- 日志输出格式 --&gt;          &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;               &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} -%msg%n&lt;/Pattern&gt;          &lt;/layout&gt;  &lt;/appender&gt;</code></pre><p>这个配置应用了ch.qos.logback.core.rolling.RollingFileAppender，可以想到是否可以对这个类进行改造？ 于是我试着继承RollingFileAppender并重写了其中的方法。</p><pre><code>public class MyRollingFileAppender extends RollingFileAppender{    private String filePermissions;    public void setFilePermissions(String filePermissions)    {        this.filePermissions = filePermissions;    }    public void openFile(String fileName)    {        super.openFile(fileName);        definePosixPermission(fileName);    }    private void definePosixPermission(String fileName)    {        if (StringUtil.isEmpty(filePermissions))        {            return;        }        Set attriViews = FileSystems.getDdfault.supportedFileAttributeViews();        if (!attriViews.contains(&quot;posix&quot;))        {            addInfo(&quot;posix file attrbute permission defined but it is not supporter by this files system&quot;);            return;        }        Path path = (new File(fileName)).toPath();        Set posixPermission = PosixPermissions.fromString(filePermissions);        PosixFileAttrbuteView posixView = (PosixFileAttrbuteView)Files.getFileAttributeView(path, java.nio.file.attribute.PosixFileAttributeView, new LinkOption[0]);        if (posixView != null)        {            try            {                posixView.setPermissions(filePermissions);            }            catch(IOException e)            {                addWarn(.......);            }        }    }}</code></pre><p>这时候，logback中的appender就需要增加属性配置了：</p><pre><code>&lt;appender name=&quot;FILE&quot; class= &quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;          &lt;!-- 按天来回滚，如果需要按小时来回滚，则设置为{yyyy-MM-dd_HH} --&gt;          &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;               &lt;filePermissions&gt;rw-r--r--&lt;/filePermissions&gt;             &lt;fileNamePattern&gt;/opt/log/test.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;               &lt;!-- 如果按天来回滚，则最大保存时间为1天，1天之前的都将被清理掉 --&gt;               &lt;maxHistory&gt;30&lt;/maxHistory&gt;          &lt;!-- 日志输出格式 --&gt;          &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;               &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} -%msg%n&lt;/Pattern&gt;          &lt;/layout&gt;  &lt;/appender&gt;</code></pre><p>其实从代码中可以看出这使用了java底层的能力去修改文件的权限，java nio提供的文件操作的底层能力非常强大。</p><p>另外，如果java的微服务日志还包含在启动脚本/bin/*.sh中创建的，那么就需要在shell中指定文件的权限了，这相对来说简单很多，在创建文件的脚本后执行命令赋权限即可。</p><pre><code>exec chmod -R 644 $LOGS/my.log</code></pre><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol><li>不管是tomcat还是java都是通过修改底层操作系统的文件权限来实现对文件权限的管理。在linux操作系统etc/profile和etc/bashrc中都有默认的umask设置。可以看到根据不同的uid设置了不同的umask。<br><img src="https://i.imgur.com/LGy2g4a.png" alt=""></li><li><p>基于上一点的操作系统原理，自然可以想到是否可以通过直接修改日志目录的权限来控制目录中的文件权限？通过查阅找到了linux的操作系统命令<code>setfacl</code>，这个命令可以强制指定目录的所有子文件（目录）继承本目录的权限。<br>那我是不是可以直接在shell脚本中将微服务的日志目录创建好并赋予644权限呢？答案是肯定的，在shell脚本中创建日志目录后增加一行：</p><p> setfacl -Rm “u::rw,g::r,o::r” $LOG_DIR<br>有了这个方法，tomcat和java应用的日志权限问题都可以迎刃而解了。</p></li></ol><blockquote><p><a href="https://blog.csdn.net/chenjie2000/article/details/8902727" target="_blank" rel="noopener">https://blog.csdn.net/chenjie2000/article/details/8902727</a><br><a href="https://blog.csdn.net/silvita/article/details/73294628" target="_blank" rel="noopener">https://blog.csdn.net/silvita/article/details/73294628</a><br><a href="https://blog.csdn.net/wo2huoa/article/details/79205575" target="_blank" rel="noopener">https://blog.csdn.net/wo2huoa/article/details/79205575</a><br><a href="https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_001.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_001.html</a><br><a href="https://www.cnblogs.com/MrListening/p/5821296.html" target="_blank" rel="noopener">https://www.cnblogs.com/MrListening/p/5821296.html</a><br><a href="https://www.cnblogs.com/William-Guozi/p/Shell_setfacl.html" target="_blank" rel="noopener">https://www.cnblogs.com/William-Guozi/p/Shell_setfacl.html</a><br><a href="https://www.jb51.net/article/124542.htm" target="_blank" rel="noopener">https://www.jb51.net/article/124542.htm</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h1&gt;&lt;p&gt;　　商城的微服务创建的日志会输出到指定磁盘，提供给专门的运维监控系统分析。微服务在虚拟机上创建的目录默认权限是755
      
    
    </summary>
    
      <category term="容器化" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="容器化" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="权限" scheme="http://yoursite.com/tags/%E6%9D%83%E9%99%90/"/>
    
      <category term="umask" scheme="http://yoursite.com/tags/umask/"/>
    
      <category term="logback" scheme="http://yoursite.com/tags/logback/"/>
    
      <category term="setfacl" scheme="http://yoursite.com/tags/setfacl/"/>
    
  </entry>
  
  <entry>
    <title>理发行业的未来</title>
    <link href="http://yoursite.com/2019/04/07/%E7%90%86%E5%8F%91%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%9C%AA%E6%9D%A5/"/>
    <id>http://yoursite.com/2019/04/07/理发行业的未来/</id>
    <published>2019-04-07T06:57:54.279Z</published>
    <updated>2019-04-07T06:57:27.117Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天清明假期，趁大家都外出游玩，我到小区门口的一家理发店修剪一下。<br>　　这次店里不太忙，值班的几个发型师看起来都是90后甚至是00后。随便选了一个发型师，告诉他，按现在的发型修剪一下即可。剪发过程中闲聊几句，了解到店长又选了一个位置新开了一家门店，今天开业，店长和一些老店员都去新店帮忙了。很快剪完了，本来也没很高的期望，结果还是让我很吃惊，与我想要的结果差距太大。<br>　　近两次剪发过程让我不禁对这个行业做了一些思考。<br>　　前一次剪发是店长上阵，我没有提要求，任凭他发挥，剪发过程细致，效果超过我预期，当时店长说洗剪吹平时是120元，那天客户太多店长帮忙。我花了40元，剪了120元的效果，感觉很满意。第二次是小店员操刀，一样是40元，跟旁边店20元的效果一样。这就让我有了一种感觉，这家店平时40元剪发不值，而店长的120元效果同样不值120元，这120元中包含了服务的价值。<br>　　作为一家理发店的店长，技术再好，个人精力也是有限的，每天能服务的用户数总会有上限，收入也就有上限。想增加营业收入，只能通过增加店员数量，但是店员的水平参差不齐，很难剪出店长的水平，一旦他们能剪出店长的水平，他们也就不会甘于做店员了。<br>　　<br>　　好了进入正题。<br>　　想一想，为什么店长剪出来的效果会让更多的用户满意？仅仅是因为熟练？眼光？<br>　　站在客户角度看，因素很多。剪发基本功是基础，大脑中的发型库算经验。除了这两项必备能力，想要让用户满意最重要的是能了解客户，从客户的衣着、言谈、举止、装扮、发型等判断客户的类型，时尚型、严肃型、张扬型、保守型、杀马特型、无所谓型等，再根据用户的年龄、身高、脸型、头型、工作类型从发型师大脑的发型库中匹配合适的发型，依靠自己的剪发功力，将这些发型在客户身上落地。<br>　　这不就是用户画像+大数据分析的一个简单应用场景么？再加点料就是人工智能的一个场景。可以预想人工智能+虚拟现实，在剪发前就让客户看到效果，这会大大降低了理发师的门槛，淡化店长的个人经验对服务结果的影响。未来的理发师，只需要具备扎实的基本功就可以很容易得剪出让用户满意的发型。甚至在更远一点的未来，当人类发明了只对头发有切割效果的“工具”后，理发师这个职业也将随之消失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　今天清明假期，趁大家都外出游玩，我到小区门口的一家理发店修剪一下。&lt;br&gt;　　这次店里不太忙，值班的几个发型师看起来都是90后甚至是00后。随便选了一个发型师，告诉他，按现在的发型修剪一下即可。剪发过程中闲聊几句，了解到店长又选了一个位置新开了一家门店，今天开业，店长和
      
    
    </summary>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="人工智能" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="美发行业" scheme="http://yoursite.com/tags/%E7%BE%8E%E5%8F%91%E8%A1%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>走钢丝的启示</title>
    <link href="http://yoursite.com/2019/04/06/%E8%B5%B0%E9%92%A2%E4%B8%9D%E7%9A%84%E5%90%AF%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/04/06/走钢丝的启示/</id>
    <published>2019-04-06T15:41:28.135Z</published>
    <updated>2019-04-07T05:35:01.446Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天有幸现场观看杂技表演——高空走钢丝。从中获得许多启示。<br>　　自杂技演员拿着平衡杆脚踩上钢丝的那一刻起，就意味着一段旅程的开始。当他慢慢走到钢丝中间，对他而言，已没有了退路，停不行，放弃也不可，没有人能帮助他，他只能勇敢的走到对面，或者原路返回，但无论如何选择，都需要一步步走完。<br>　　人的一生会遇到很多事，需要做很多决定，有多少自己选择的路是有始有终的走完？困难、挫折、气馁、放弃，结果是永远无法成功的走到终点，当然也难全身而退。<br>　　选择太多往往就容易导致没有结果。<br>　　我没走过钢丝，不知道走钢丝的人是什么心理。换位思考一下，如果我是走钢丝的人，从迈出第一步后，心里想的一定是如何走好，如何走下去，不管遇到什么困难，只会想各种方法克服，心无旁骛。也许台下掌声雷动，纵然有观众竭力呼喊，对钢丝上那个人来讲，又有什么影响呢？他还是一样一步一步继续走下去。如果以走钢丝人的心态做事，成功的几率只会成倍增加。<br>　　另一个层面。<br>　　走钢丝表演固然精彩，但如果让你每周看一场，你能坚持多久？钢丝表演也需要创新，也需要突破，花样要更多、难度要更大，否则观众也不愿意为一个一成不变的表演长期买单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　今天有幸现场观看杂技表演——高空走钢丝。从中获得许多启示。&lt;br&gt;　　自杂技演员拿着平衡杆脚踩上钢丝的那一刻起，就意味着一段旅程的开始。当他慢慢走到钢丝中间，对他而言，已没有了退路，停不行，放弃也不可，没有人能帮助他，他只能勇敢的走到对面，或者原路返回，但无论如何选择，
      
    
    </summary>
    
      <category term="思维方式" scheme="http://yoursite.com/categories/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="思维方式" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql自增序列</title>
    <link href="http://yoursite.com/2019/03/16/mysql%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/16/mysql自增序列/</id>
    <published>2019-03-16T13:13:16.623Z</published>
    <updated>2019-03-28T22:57:39.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-变量类型"><a href="#一-变量类型" class="headerlink" title="一 变量类型"></a>一 变量类型</h2><p>mysql系统参数分为：全局变量和会话变量。这两类设置在设置后立刻生效，但mysql重启后就会失效，如果希望一直有效需要修改Mysql配置文件并重启。</p><h2 id="二-重要的命令"><a href="#二-重要的命令" class="headerlink" title="二 重要的命令"></a>二 重要的命令</h2><h3 id="1-查看系统级自增序列种子值和间隔值"><a href="#1-查看系统级自增序列种子值和间隔值" class="headerlink" title="1. 查看系统级自增序列种子值和间隔值"></a>1. 查看系统级自增序列种子值和间隔值</h3><p>SHOW GLOBAL VARIABLES LIKE ‘auto_incre%’; – 全局变量</p><p>MySQL设置表字段属性AUTO_INCREMENT时，默认初始值为1，默认增长间隔为1。</p><h3 id="2-设置增长初始值为n"><a href="#2-设置增长初始值为n" class="headerlink" title="2. 设置增长初始值为n"></a>2. 设置增长初始值为n</h3><p>SET @@auto_increment_offset = n;<br>取值范围是1-65535</p><h3 id="3-设置增长幅度为2"><a href="#3-设置增长幅度为2" class="headerlink" title="3. 设置增长幅度为2"></a>3. 设置增长幅度为2</h3><p>SET @@auto_increment_increment = 2;<br>取值范围是1-65535</p><p>做数据库的主从同步时需要在参数文件中设置自增长的两个相关配置：auto_increment_offset和auto_increment_increment。</p><p>在主主同步配置时，需要将两台服务器的auto_increment_increment增长量都配置为2，而要把auto_increment_offset分别配置为1和2.这样才可以避免两台服务器同时做更新时自增长字段的值之间发生冲突。</p><h3 id="4-查看序列下一个值"><a href="#4-查看序列下一个值" class="headerlink" title="4. 查看序列下一个值"></a>4. 查看序列下一个值</h3><pre><code>SELECT AUTO_INCREMENT FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = &apos;table_name&apos;；</code></pre><h2 id="三-自增序列使用方法"><a href="#三-自增序列使用方法" class="headerlink" title="三 自增序列使用方法"></a>三 自增序列使用方法</h2><h3 id="1-创建表时指定"><a href="#1-创建表时指定" class="headerlink" title="1. 创建表时指定"></a>1. 创建表时指定</h3><pre><code>CREATE TABLE t_userinfo(    id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,    username VARCHAR(30) NOT NULL) AUTO_INCREMENT = 100;</code></pre><p>可在建表时用“AUTO_INCREMENT=n”选项来指定自增序列的初始值。也可以通过脚本<br>    alter table t_userinfo auto_increment = n ;<br>设置表的唯一auto_increment字段起始值从n开始，此表数据量很大时，这样方式执行很慢。</p><h3 id="2-通过alter设置"><a href="#2-通过alter设置" class="headerlink" title="2. 通过alter设置"></a>2. 通过alter设置</h3><pre><code>alter table t_userinfo modify id int auto_increment;</code></pre><h2 id="四-AUTO-INCREMENT说明"><a href="#四-AUTO-INCREMENT说明" class="headerlink" title="四 AUTO_INCREMENT说明"></a>四 AUTO_INCREMENT说明</h2><ul><li>把NULL插入到一个AUTO_INCREMENT数据列时，MySQL将自动生成下一个序列编号。</li><li>把0插入AUTO_INCREMENT数据列的效果与插入NULL值一样。建议使用null。</li><li>当插入记录时，没有为AUTO_INCREMENT明确指定值，则等同插入NULL值。</li><li>当插入记录时，如果为AUTO_INCREMENT数据列明确指定了一个数值，则会出现两种情况，情况一，如果插入的值与已有的编号重复，则会出现出错信息，因为AUTO_INCREMENT数据列的值必须是唯一的；情况二，如果插入的值大于已编号的值，则会把该插入到数据列中，而下一个编号将从这个新值开始递增。</li><li>如果用UPDATE命令更新自增列，如果列值与已有的值重复，则会出错。如果大于已有值，则下一个编号从该值开始递增。</li><li>如果一张表里有个字段为id的自增主键，向表里面插入了5条数据，删除id为3、4、5的数据，再把mysql重启，之后再插入一条数据，那么这条数据的id值存在两种情况：情况一，如果表的类型为MyISAM，那么是6。情况二，如果表的类型为InnoDB，则id为3。因为两种类型的存储引擎所存储的最大ID记录的方式不同，MyISAM表将最大的ID记录到了数据文件里，重启mysql自增主键的最大ID值也不会丢失； 而InnoDB则是把最大的ID值记录到了内存中，所以重启mysql或者对表进行了OPTIMIZE操作后，最大ID值将会丢失。 </li></ul><blockquote><p>参考：<br><a href="https://www.cnblogs.com/wade-lt/p/9008058.html" target="_blank" rel="noopener">https://www.cnblogs.com/wade-lt/p/9008058.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-变量类型&quot;&gt;&lt;a href=&quot;#一-变量类型&quot; class=&quot;headerlink&quot; title=&quot;一 变量类型&quot;&gt;&lt;/a&gt;一 变量类型&lt;/h2&gt;&lt;p&gt;mysql系统参数分为：全局变量和会话变量。这两类设置在设置后立刻生效，但mysql重启后就会失效，如果希望
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="自增序列" scheme="http://yoursite.com/tags/%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    
      <category term="AUTO_INCREMENT" scheme="http://yoursite.com/tags/AUTO-INCREMENT/"/>
    
  </entry>
  
  <entry>
    <title>DNS</title>
    <link href="http://yoursite.com/2019/03/13/DNS/"/>
    <id>http://yoursite.com/2019/03/13/DNS/</id>
    <published>2019-03-12T23:25:16.196Z</published>
    <updated>2019-03-12T23:34:43.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS概念"><a href="#DNS概念" class="headerlink" title="DNS概念"></a>DNS概念</h2><p>　　DNS，即域名服务器，用完成域名和IP间的转换。用户访问网站时，通常会使用域名，比如<a href="http://www.google.com，" target="_blank" rel="noopener">www.google.com，</a> 而不是直接通过Ip:port的方式，因为域名更容易记忆，更方便使用。而如果通过域名找到真正的网站服务器？这就是DNS做的事。<br>　　DNS通常有多级，起始的节点是根节点，在IP转换时会从根节点逐级查找具体的DNS。通常客户端会对DNS做缓存，而不需要从根节点逐级查找。</p><h2 id="网站与DNS"><a href="#网站与DNS" class="headerlink" title="网站与DNS"></a>网站与DNS</h2><p>　　对于单一架构小流量网站而言，只需要最简单的能力，向域名供应商注册一个域名，再向DNS服务商购买一个DNS服务，在DNS上完成域名与IP配置即可。<br>　　现在的互联网网站，比如华为商城，需要频繁应对大流量冲击，用户来自全国各地。如果让全国各地使用不同网络运营商服务的用户都去访问处于北京或上海的网站服务器，访问过程的网络跳转次数会很多，由此造成的网络时延也会很明显。<br>　　为应对上述的情况，网站运营商不得不在全国各地的不同通信运营商的网络中建立站点，这样用户网络可以就近选择网站服务器进行访问，减少跳转次数和网络时延。如同<a href="http://www.vmall.com的域名，域名只有一个，如何根据不同用户IP指向不同的网站服务器？" target="_blank" rel="noopener">www.vmall.com的域名，域名只有一个，如何根据不同用户IP指向不同的网站服务器？</a> 这可以由DNS来完成。<br>　　<br>　　<strong>DNS可以支持：</strong></p><ul><li>根据网站访问者所在的网络类型，判断给用户提供最佳的访问解析地址，使访问用户获得最快捷、最流畅的体验。</li><li>可以根据服务器IP所在的运营商省份，来选择不同的细分线路，包括移动、联通、电信、教育网的国内31个省份线路。</li><li>可以根据IP范围细分线路。</li><li>对于有海外部署服务器的用户，支持非洲、亚洲、欧洲、大洋洲、南美洲、北美洲6大洲设置解析线路，为海外用户提供访问解析地址。每个大洲中，可以细化到国家地区。</li><li>支持多级域名配置。</li><li>可以分别对实时性内容服务和静态内容服务通过子域名完成差异配置。</li><li>支持服务器集合，通过集合中设置的服务器优先级来指定访问顺序，避免服务关闭后用户无法继续访问网站。</li></ul><p>　　有了DNS的域名解析，还可以在域名映射中挂在负载均衡的IP地址，再通过在负载均衡后挂载服务集群的方式有效分散流量冲击。</p><h2 id="DNS服务商"><a href="#DNS服务商" class="headerlink" title="DNS服务商"></a>DNS服务商</h2><p>　　这里主要是国内的DNS服务商，中国联通、中国电信、阿里云、114、南方电信、百度、360、中国万网等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DNS概念&quot;&gt;&lt;a href=&quot;#DNS概念&quot; class=&quot;headerlink&quot; title=&quot;DNS概念&quot;&gt;&lt;/a&gt;DNS概念&lt;/h2&gt;&lt;p&gt;　　DNS，即域名服务器，用完成域名和IP间的转换。用户访问网站时，通常会使用域名，比如&lt;a href=&quot;http:
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
      <category term="域名服务器" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（十一）Web的攻击技术</title>
    <link href="http://yoursite.com/2019/01/15/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2019/01/15/图解HTTP——（十一）Web的攻击技术/</id>
    <published>2019-01-15T15:54:04.369Z</published>
    <updated>2019-01-15T15:53:57.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/otFu28x.png" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/otFu28x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/otFu28x.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/otFu28x.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（十）构建Web内容的技术</title>
    <link href="http://yoursite.com/2019/01/15/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E5%8D%81%EF%BC%89%E6%9E%84%E5%BB%BAWeb%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2019/01/15/图解HTTP——（十）构建Web内容的技术/</id>
    <published>2019-01-15T14:49:42.807Z</published>
    <updated>2019-01-15T14:49:33.127Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/xf5IIrW.png" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/xf5IIrW.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/xf5IIrW.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/xf5IIrW.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（九）基于HTTP的功能追加协议</title>
    <link href="http://yoursite.com/2019/01/15/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E4%B9%9D%EF%BC%89%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%8A%9F%E8%83%BD%E8%BF%BD%E5%8A%A0%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/01/15/图解HTTP——（九）基于HTTP的功能追加协议/</id>
    <published>2019-01-14T23:46:52.966Z</published>
    <updated>2019-01-14T23:46:04.187Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/J3PjlH1.png" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/J3PjlH1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/J3PjlH1.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/J3PjlH1.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="spdy" scheme="http://yoursite.com/tags/spdy/"/>
    
      <category term="websocket" scheme="http://yoursite.com/tags/websocket/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
      <category term="comet" scheme="http://yoursite.com/tags/comet/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（八）确认访问用户身份的认证</title>
    <link href="http://yoursite.com/2019/01/13/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E5%85%AB%EF%BC%89%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E7%9A%84%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2019/01/13/图解HTTP——（八）确认访问用户身份的认证/</id>
    <published>2019-01-13T15:41:20.209Z</published>
    <updated>2019-01-13T15:41:10.242Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/AozeDyQ.png" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/AozeDyQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/AozeDyQ.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/AozeDyQ.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="认证" scheme="http://yoursite.com/tags/%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（七）确保Web安全的HTTPS</title>
    <link href="http://yoursite.com/2019/01/13/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E4%B8%83%EF%BC%89%E7%A1%AE%E4%BF%9DWeb%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/"/>
    <id>http://yoursite.com/2019/01/13/图解HTTP——（七）确保Web安全的HTTPS/</id>
    <published>2019-01-13T13:34:51.042Z</published>
    <updated>2019-01-13T13:31:55.233Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/VpVh2X1.png" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/VpVh2X1.png" alt=""></p><p>从仅使用服务器端的公开密钥证书（服务器证书）建立HTTPS通信的过程:<br><img src="https://i.imgur.com/KgianC4.jpg" alt="从仅使用服务器端的公开密钥证书（服务器证书）建立HTTPS通信的过程"></p><p>CBC模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做XOR运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initialvector，IV）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/VpVh2X1.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/VpVh2X1.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
      <category term="ssl" scheme="http://yoursite.com/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（六）HTTP首部</title>
    <link href="http://yoursite.com/2019/01/10/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E5%85%AD%EF%BC%89HTTP%E9%A6%96%E9%83%A8/"/>
    <id>http://yoursite.com/2019/01/10/图解HTTP——（六）HTTP首部/</id>
    <published>2019-01-10T15:27:25.270Z</published>
    <updated>2019-01-12T13:22:49.032Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/CnfaJAH.png" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/CnfaJAH.png" alt=""></p><blockquote><p>参考：<br><a href="https://my.oschina.net/u/588516/blog/621569" target="_blank" rel="noopener">https://my.oschina.net/u/588516/blog/621569</a><br><a href="https://www.jianshu.com/p/ff5ff6f3c353" target="_blank" rel="noopener">https://www.jianshu.com/p/ff5ff6f3c353</a><br><a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="noopener">https://imququ.com/post/x-forwarded-for-header-in-http.html</a><br><a href="https://www.freebuf.com/articles/web/140669.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/140669.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/CnfaJAH.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/CnfaJAH.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="header" scheme="http://yoursite.com/tags/header/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（五）与HTTP协作的Web服务器</title>
    <link href="http://yoursite.com/2019/01/09/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/01/09/图解HTTP——（五）与HTTP协作的Web服务器/</id>
    <published>2019-01-09T15:16:13.841Z</published>
    <updated>2019-01-09T15:15:56.806Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/mNo3l4M.png" target="_blank" rel="noopener">点击查看原图</a></p><p><img src="https://i.imgur.com/mNo3l4M.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/mNo3l4M.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mNo3l4M.png&quot; alt
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（四）返回结果的HTTP状态码</title>
    <link href="http://yoursite.com/2019/01/09/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E5%9B%9B%EF%BC%89%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://yoursite.com/2019/01/09/图解HTTP——（四）返回结果的HTTP状态码/</id>
    <published>2019-01-09T14:42:27.908Z</published>
    <updated>2019-01-09T14:41:34.708Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/kcmMk43.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/kcmMk43.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="状态码" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（三）HTTP报文内的HTTP信息</title>
    <link href="http://yoursite.com/2019/01/08/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E4%B8%89%EF%BC%89HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2019/01/08/图解HTTP——（三）HTTP报文内的HTTP信息/</id>
    <published>2019-01-08T15:19:01.399Z</published>
    <updated>2019-01-08T15:52:36.203Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://i.imgur.com/RIcdTaM.png" title="点击查看原图" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/RIcdTaM.png" alt=""></p><p><font size="5" color="#00dddd">multipart/form-data</font><br><br><img src="https://i.imgur.com/HoCYola.png" alt="multipart/form-data"></p><p><font size="5" color="#00dddd">multipart/byteranges</font><br><br><img src="https://i.imgur.com/sSE0Go0.png" alt="multipart/byteranges"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://i.imgur.com/RIcdTaM.png&quot; title=&quot;点击查看原图&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原图&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/RIcdT
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（二）简单的HTTP协议</title>
    <link href="http://yoursite.com/2019/01/08/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E4%BA%8C%EF%BC%89%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/01/08/图解HTTP——（二）简单的HTTP协议/</id>
    <published>2019-01-07T23:25:15.478Z</published>
    <updated>2019-01-08T14:24:34.388Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/L3QCkgy.png" alt=""></p><p><strong>请求报文</strong><br><img src="https://i.imgur.com/ov5CVZk.png" alt=""></p><p><strong>响应报文</strong><br><img src="https://i.imgur.com/YcxjYSa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/L3QCkgy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求报文&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/ov5CVZk.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP——（一）Web及网络协议基础</title>
    <link href="http://yoursite.com/2019/01/07/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%EF%BC%88%E4%B8%80%EF%BC%89Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/01/07/图解HTTP——（一）Web及网络协议基础/</id>
    <published>2019-01-07T15:21:43.197Z</published>
    <updated>2019-01-15T23:48:06.406Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP参考文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a><br><a href="https://github.com/mudaoren/resource/blob/master/http/RFC2616-%E4%B8%AD%E6%96%87-%E5%B8%A6%E4%B9%A6%E7%AD%BE.pdf" target="_blank" rel="noopener">《图解HTTP》</a><br><a href="https://github.com/mudaoren/resource/blob/master/http/RFC2616-%E4%B8%AD%E6%96%87-%E5%B8%A6%E4%B9%A6%E7%AD%BE.pdf" target="_blank" rel="noopener">RFC2616</a></p></blockquote><p><a href="https://i.imgur.com/HgVOYEf.png" title="查看原图" target="_blank" rel="noopener">点击查看原图</a><br><img src="https://i.imgur.com/HgVOYEf.png" alt="https://i.imgur.com/HgVOYEf.png"></p><p><img src="https://i.imgur.com/SfN1vNF.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;HTTP参考文档：&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mo
      
    
    </summary>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2019/01/06/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/06/Java代理模式/</id>
    <published>2019-01-06T11:51:28.705Z</published>
    <updated>2019-01-06T12:48:40.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是代理模式？"><a href="#一、什么是代理模式？" class="headerlink" title="一、什么是代理模式？"></a><font color="#006600">一、什么是代理模式？</font></h1><p>　　代理模式也叫做委托模式，为其他对象提供一种代理以控制对这个对象的访问。<br>　　举一个例子，你希望假期出国旅游，但是又不想自己处理诸如签证、行程、交通、食宿等麻烦事，就可以找个旅游公司代办，你只需要按照旅游公司的安排出行。生活中的经纪人、中介、律师所的律师、会计事务所会计、甚至超市等都是现实中代理模式应用。</p><h1 id="二、常用的代理模式"><a href="#二、常用的代理模式" class="headerlink" title="二、常用的代理模式"></a><font color="#006600">二、常用的代理模式</font></h1><p>　　常用的代理模式分为<strong>静态代理</strong>和<strong>动态代理</strong>。</p><h2 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h2><p>　　静态代理是在程序编译阶段就已经确定代理类和被代理类，他们的关系已经存在于编译后的字节码文件中。简单讲就是程序员手写的代理就是静态代理。</p><h3 id="2-1-1-使用场景"><a href="#2-1-1-使用场景" class="headerlink" title="2.1.1 使用场景"></a>2.1.1 使用场景</h3><p>　　类型（接口/继承）单一，接口功能相对单一，实现类明确且数量较少的情况。</p><h3 id="2-1-2-实现方式"><a href="#2-1-2-实现方式" class="headerlink" title="2.1.2 实现方式"></a>2.1.2 实现方式</h3><ul><li>继承</li><li>接口</li></ul><h3 id="2-1-3-实现示例"><a href="#2-1-3-实现示例" class="headerlink" title="2.1.3 实现示例"></a>2.1.3 实现示例</h3><p><strong>定义一个抽象的被代理者Subject</strong></p><pre><code>/** * 被代理对象 * 航空公司 */public interface AirlineCompany{    // 订票方法    boolean booking();}</code></pre><p><strong>定义一个具体的被代理者RealSubject</strong></p><pre><code>/** * 南方航空 */public class SouthernAirlines implements AirlineCompany{    @Override    public boolean booking()    {        System.out.println(&quot;订票成功, 欢迎乘坐南方航空！&quot;);        return true;    }}</code></pre><p><strong>定义一个代理proxy</strong></p><pre><code>/** * 机票代理公司，可以代理多家航空公司的机票 */public class AirlineProxy implements AirlineCompany{    private AirlineCompany airlineCompany;    public AirlineProxy(AirlineCompany airlineCompany)    {        this.airlineCompany = airlineCompany;    }    @Override    public boolean booking()    {        System.out.println(&quot;通过代理订购机票！&quot;);        return airlineCompany.booking();    }}</code></pre><p><strong>测试方法，即消费者</strong></p><pre><code>/** * 消费者 */public class Customer{    // 消费者预订机票    public static void main(String[] args)    {        // 定义一家航空公司，比如南方航空        AirlineCompany southernAir = new SouthernAirlines();        // 定义一家机票代理商        AirlineCompany proxy = new AirlineProxy(southernAir);        boolean result = proxy.booking();        System.out.println(&quot;消费者订购机票结果：&quot;+ result);    }}</code></pre><h3 id="2-1-4-小结"><a href="#2-1-4-小结" class="headerlink" title="2.1.4 小结"></a>2.1.4 小结</h3><p>　　业务类只需要关注业务逻辑本身，保证了业务类的重用性和可扩展性。尽管继承和接口都可以实现静态代理模式，但是使用继承大大限制了代理的范围，因而常用的代理实现方式是接口。比如一个票务公司通常会同时代理机票、火车票、汽车票、轮船票、景点门票甚至演出门票等，这种情况下明显使用接口更加合适。</p><h2 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h2><p>　　动态代理是在程序运行阶段才能确定被代理类，被代理类通常是在使用时才会被通过反射机制创建。</p><h3 id="2-2-1-使用场景"><a href="#2-2-1-使用场景" class="headerlink" title="2.2.1 使用场景"></a>2.2.1 使用场景</h3><ul><li>被代理的实现类不确定，比如对第三方开放。</li><li>对象创建开销很大，在使用时才需要创建。</li><li>调用其他进程的接口。</li></ul><p>　　动态代理已经被广泛使用，常见的面向切面编程AOP、Hibernate、RPC、JDBC驱动、OSGI、java注解等。</p><h3 id="2-2-2-实现方式"><a href="#2-2-2-实现方式" class="headerlink" title="2.2.2 实现方式"></a>2.2.2 实现方式</h3><ul><li>jdk原生动态代理</li><li>Cglib动态代理</li></ul><h3 id="2-2-3-jdk原生动态代理实现步骤"><a href="#2-2-3-jdk原生动态代理实现步骤" class="headerlink" title="2.2.3 jdk原生动态代理实现步骤"></a>2.2.3 jdk原生动态代理实现步骤</h3><p><strong>创建被代理的接口</strong></p><pre><code>/** * 被代理对象 * 航空公司 */public interface AirlineCompany{    // 订票方法    boolean booking();    // 返回公司名称    String company();}</code></pre><p><strong>创建一个被代理接口的具体实现</strong></p><pre><code>/** * 南方航空 */public class SouthernAirlines implements AirlineCompany{    @Override    public boolean booking()    {        System.out.println(&quot;订票成功，欢迎乘坐南方航空！&quot;);        return true;    }    @Override    public String company()    {        return &quot;南方航空&quot;;    }}</code></pre><p><strong>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</strong></p><pre><code>/** * 机票代理公司，可以代理多家航空公司的机票 */public class AirlineProxy implements InvocationHandler{    private Object target;    /**     * @param object 该参数为要代理的实例对象，目的是用于执行method.invoke()方法（也就是执行目标方法）     * @return Object 返回被代理类实例     * /    public Object getInstance(Object object)    {        this.target = object;        Class clazz = object.getClass();        System.out.println(MessageFormat.format(&quot;创建{0}的代理！&quot;, target.getClass()));        // 这里要调用Proxy的newProxyInstance静态方法，创建一个代理类。如果这里不创建，那么需要在顾客订票时创建。newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);    }    /**     * 在invoke()方法里我们可以加入任何逻辑。     * @param proxy 动态生成的代理对象     * @param method 目标方法的实例     * @param args 目标方法的参数     * @return 该方法的返回值就是代理对象执行目标方法的返回值     * /    @Override    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable    {        return method.invoke(target, args);    }}</code></pre><p><strong>通过代理对象调用目标方法</strong></p><pre><code>/** * 定义一个顾客 */public class Customer{    // 顾客通过代理订票    public static void main(String[] args)    {        // 南方航空        SouthernAirlines southernAir = new SouthernAirlines();        // 定义一家机票代理商        SouthernAirlines proxy = (SouthernAirlines)new AirlineProxy().getInstance(southernAir);        boolean result = proxy.booking();        String companyName = proxy.company();        System.out.println(MessageFormat.format(&quot;顾客通过代理[ {0}]，订购[{1}]机票结果[{2}]&quot;, proxy.getClass(), companyName, result));        // 打印代理类的二进制文件        writeProxyByte(proxy);    }    // 输出代理类的二进制文件    private static void writeProxyByte(Object object)    {        try        {            byte[] $Proxy0s = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, new Class[] {object.getClass()});            FileOutputStream fileOutputStream = new FileOutputStream(&quot;$Proxy0.class&quot;);            fileOutputStream.write($Proxy0s);            fileOutputStream.close();        }        catch(IOException ex)        {        }    }}</code></pre><p><strong>测试结果：</strong></p><pre><code>创建class designPaterns.proxyPaterns.dynamicProxy.jdkRealize.SouthernAirlines的代理！订票成功，欢迎乘坐南方航空！消费者通过代理[ class com.sun.proxy.$Proxy0]，订购[南方航空]机票结果[true]</code></pre><p><strong>小结：</strong><br>　　JDK原生动态代理只能代理实现了接口的类， 没有实现接口的类不能实现动态代理。</p><h3 id="2-2-4-Cglib动态代理实现步骤"><a href="#2-2-4-Cglib动态代理实现步骤" class="headerlink" title="2.2.4 Cglib动态代理实现步骤"></a>2.2.4 Cglib动态代理实现步骤</h3><p>　　Cglib动态代理的实现原理和jdk基本相同，都是生成新的代理类。但具体实现有所不同，cglib动态代理生成的代理类是被代理者的子类，且会重写父类除private和final修饰的所有方法，要求该父类必须有空的构造方法。</p><p><strong>创建一个被代理类型的具体实现</strong></p><pre><code>/** * 南方航空 */public class SouthernAirlines{    public boolean booking()    {        System.out.println(&quot;订票成功，欢迎乘坐南方航空！&quot;);        return true;    }    public String company()    {        return &quot;南方航空&quot;;    }}</code></pre><p><strong>创建一个代理，需要实现cglib包的MethodInterceptor接口，以保证可以调用方法intercept</strong></p><pre><code>/**   *  定义一个代理 */public class AirlineProxy implements MethodInterceptor{    private Object target;    // 返回代理对象    public Object getInstance(Object object)    {        this.target = object;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        System.out.println(MessageFormat.format(&quot;创建{0}的代理对象！&quot;, target.getClass()));        return enhancer.create();            }    /**     * 实现MethodInterceptor接口的intercept方法后，所有生成的代理方法都调用这个方法     * @param obj 目标类的实例     * @param method 目标方法实例（通过反射获取的目标方法实例）     * @param args 目标方法的参数     * @param proxy 代理类的实例     * @return Object 目标方法的返回值。     */    public Object intercept(Object obj, Method method, Object[] args,            MethodProxy proxy) throws Throwable    {        return method.invoke(target, args);    }}</code></pre><p><strong>通过代理对象调用目标方法</strong></p><pre><code>/** * 定义一个顾客 */public class Customer{    // 顾客通过代理订票    public static void main(String[] args)    {        // 南方航空        SouthernAirlines southernAir = new SouthernAirlines();        // 定义一家机票代理商        SouthernAirlines proxy = (SouthernAirlines)new AirlineProxy().getInstance(southernAir);        boolean result = proxy.booking();        String companyName = proxy.company();        System.out.println(MessageFormat.format(&quot;顾客通过代理[ {0}]，订购[{1}]机票结果[{2}]&quot;, proxy.getClass(), companyName, result));        // 打印代理类的二进制文件        writeProxyByte(proxy);    }    // 输出代理类的二进制文件    private static void writeProxyByte(Object object)    {        try        {            byte[] $Proxy0s = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, new Class[] {object.getClass()});            FileOutputStream fileOutputStream = new FileOutputStream(&quot;$Proxy0.class&quot;);            fileOutputStream.write($Proxy0s);            fileOutputStream.close();        }        catch(IOException ex)        {        }    }}</code></pre><p><strong>测试结果：</strong></p><pre><code>创建class com.mudaoren.designPaterns.proxyPaterns.dynamicProxy.cblibrealize.SouthernAirlines的代理对象！订票成功，欢迎乘坐南方航空！顾客通过代理[ class com.mudaoren.designPaterns.proxyPaterns.dynamicProxy.cblibrealize.SouthernAirlines$$EnhancerByCGLIB$$f6637d97]，订购[南方航空]机票结果[true]</code></pre><p>小结：<br>　　cglib的动态代理是针对类来实现代理。对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用。因为通过继承实现，所以final类无法使用。</p><blockquote><p>参考：<br><a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">https://dzone.com/articles/cglib-missing-manual</a><br><!-- https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651482109&idx=1&sn=04445b8b5c493e0bf439e779bb9791c2&chksm=bd250b828a5282944348b26b3d4711f551ad3302d07b1b16a0cb6f93c2067bd8011b1a2d3bc0&scene=0&xtrack=1#rdhttps://mp.weixin.qq.com/s/FGK3DD9bcDS3FwO39-uh6g --></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、什么是代理模式？&quot;&gt;&lt;a href=&quot;#一、什么是代理模式？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是代理模式？&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#006600&quot;&gt;一、什么是代理模式？&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;　　代理模式也叫做
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PDCA循环</title>
    <link href="http://yoursite.com/2019/01/02/PDCA%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2019/01/02/PDCA循环/</id>
    <published>2019-01-02T15:31:09.657Z</published>
    <updated>2019-01-05T07:14:17.922Z</updated>
    
    <content type="html"><![CDATA[<p>　　PDCA循环也叫戴明循环，是一个持续改进模型，包括持续改进和不断学习的四个循环反复步骤。分别是计划（Plan）、执行（Do）、检查（Check）、处理（Action）。</p><h2 id="PDCA的典型适用场景"><a href="#PDCA的典型适用场景" class="headerlink" title="PDCA的典型适用场景"></a>PDCA的典型适用场景</h2><ul><li>个人管理和提升</li><li>项目管理</li><li>人力资源管理</li><li>供应商管理</li><li>流程管理</li><li>持续改进</li></ul><h2 id="PDCA循环步骤"><a href="#PDCA循环步骤" class="headerlink" title="PDCA循环步骤"></a>PDCA循环步骤</h2><ol><li>计划（Plan）。制定行动方案和目标，可以使用5W1H。</li><li>执行（Do）。依据计划具体执行。</li><li>检查（Check）。检查计划执行的过程和结果是否符合预期方案或目标，出现哪些问题和偏差。检查点的选择就是执行过程中的“控制点”、“管理点”。</li><li>效果（Action）。对检查结果进行处理，好的经验进行固化推广，失败的经验要总结改进措施，以便应用到下一个循环。Action如同导演拍电影时使用的Action，由演员按照剧本进行表演，导演对表演效果进行评判。</li></ol><h2 id="PDCA循环的重点"><a href="#PDCA循环的重点" class="headerlink" title="PDCA循环的重点"></a>PDCA循环的重点</h2><p>　　持续改进，不断上升。多个PDCA环是持续上升的过程，预示着效果、质量和水平不断提升。</p><p><img src="https://i.imgur.com/oPugqmw.jpg" alt=""></p><h2 id="相关理论"><a href="#相关理论" class="headerlink" title="相关理论"></a>相关理论</h2><ul><li>Plan的过程建议使用5W1H的方式进行，即why、what、where、who、when、how。</li><li>Check的过程如果能结合AAR（After Action Review）方法进行，效果会更好。AAR是美国陆军的一种任务检视方法，主要有4个方面：当初的目标是什么？ 实际发生了什么？ 从中学到了什么？ 以后该怎么做？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　PDCA循环也叫戴明循环，是一个持续改进模型，包括持续改进和不断学习的四个循环反复步骤。分别是计划（Plan）、执行（Do）、检查（Check）、处理（Action）。&lt;/p&gt;
&lt;h2 id=&quot;PDCA的典型适用场景&quot;&gt;&lt;a href=&quot;#PDCA的典型适用场景&quot; cl
      
    
    </summary>
    
      <category term="管理" scheme="http://yoursite.com/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="PDCA循环" scheme="http://yoursite.com/tags/PDCA%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="戴明循环" scheme="http://yoursite.com/tags/%E6%88%B4%E6%98%8E%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>高效能认识的七个习惯读书笔记</title>
    <link href="http://yoursite.com/2018/12/24/%E9%AB%98%E6%95%88%E8%83%BD%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/24/高效能认识的七个习惯读书笔记/</id>
    <published>2018-12-24T15:44:22.185Z</published>
    <updated>2018-12-25T14:34:41.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="成长过程"><a href="#成长过程" class="headerlink" title="成长过程"></a>成长过程</h2><p>依赖期——&gt;独立期——&gt;互赖期</p><p><img src="https://i.imgur.com/6Iag2aq.png" alt="七个习惯模型"></p><h2 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h2><p>生理独立：自由行动<br>心智独立：自主思考<br>情感独立：肯定自我<br>精神独立：价值观清晰（合作与奉献）</p><h2 id="互赖"><a href="#互赖" class="headerlink" title="互赖"></a>互赖</h2><p>合作、双赢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;成长过程&quot;&gt;&lt;a href=&quot;#成长过程&quot; class=&quot;headerlink&quot; title=&quot;成长过程&quot;&gt;&lt;/a&gt;成长过程&lt;/h2&gt;&lt;p&gt;依赖期——&amp;gt;独立期——&amp;gt;互赖期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6Ia
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="高效能认识的七个习惯" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%88%E8%83%BD%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSRF 攻击与防范</title>
    <link href="http://yoursite.com/2018/12/23/CSRF%20%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/23/CSRF 攻击与防范/</id>
    <published>2018-12-23T11:16:30.079Z</published>
    <updated>2018-12-24T14:58:15.105Z</updated>
    
    <content type="html"><![CDATA[<p>　　CSRF（Cross Site Request Forgery），跨站点请求伪造，是一种常见的Web攻击方式。</p><h2 id="1-CSRF如何攻击？"><a href="#1-CSRF如何攻击？" class="headerlink" title="1. CSRF如何攻击？"></a>1. CSRF如何攻击？</h2><p>　　CSRF攻击之所以会成功是由于<strong>请求操作的所有参数都能被攻击者所预知</strong>。<br>　　1） 一个普通的银行用户A，通过银行网站<code>http://huixfeng.bank.com/transfer?account=A&amp;amount=20000&amp;to=B</code>， 向B用户账户转账20000。正常情况，服务端会对用户A的请求进行验证，假设是通过session完成。<br>　　2） 攻击者X也了解到该银行的转账链接<code>http://huixfeng.bank.com/transfer?account=A&amp;amount=10000&amp;to=X</code>，希望从A的账户向自己的账户X，转账10000元。但是因为服务端会通过session验证，他无法成功完成转账。<br>　　3） X想到了CSRF攻击，他自己做了一个木马网站，通过某些手段诱导了A用户点击这个木马网站。并且木马网站中植入代码<code>http://huixfeng.bank.com/transfer?account=A&amp;amount=10000&amp;to=X</code>,这时，如果A用户点击了木马链接，就会向银行服务发起转账请求。<br>　　4） 尽管X成功的诱导了A向银行发起了转账请求，但是由于银行端需要session验证，所以此时转账并不会成功。 假设用户A在点击木马链接前，恰好登陆过银行的网站，那么A的浏览器cookie中可能还存有认证信息，如果A用户在银行服务器的session此时没有过期，那么这个攻击就成功了。</p><h2 id="2-CSRF-攻击的目标"><a href="#2-CSRF-攻击的目标" class="headerlink" title="2. CSRF 攻击的目标"></a>2. CSRF 攻击的目标</h2><p>　　浏览器具有同源策略，攻击者无法解析浏览器返回的结果。因此<strong>CSRF攻击主要是通过请求连接来触发Web端的某些操作，常见的操作是服务器端数据的增删改</strong>，如同上例中的银行账户数据的变化。Google的Gmail邮箱曾经出现过一个CSRF漏洞，攻击者诱导用户点击木马链接后，向服务端发送了一个为用户设置邮件自动转发规则，将用户的邮件自动转发到攻击者指定的邮箱。</p><h2 id="3-如何防范CSRF"><a href="#3-如何防范CSRF" class="headerlink" title="3. 如何防范CSRF"></a>3. 如何防范CSRF</h2><p>　　目前常用的防御措施：</p><ul><li>验证码</li><li>增加HTTP Referer验证</li><li>增加token验证</li></ul><h3 id="3-1-验证码"><a href="#3-1-验证码" class="headerlink" title="3.1 验证码"></a>3.1 验证码</h3><p>　　重要操作增加验证码校验，强制用户完成互动。比如银行转账或消费时，当超过10000时自动触发验证码验证，当用户输入正确验证码后才能继续操作。但是这种方式严重影响用户体验，并不适合所有场景。</p><h3 id="3-2-增加HTTP-Referer验证"><a href="#3-2-增加HTTP-Referer验证" class="headerlink" title="3.2 增加HTTP Referer验证"></a>3.2 增加HTTP Referer验证</h3><p>　　HTTP Referer是HTTP Header中的字段叫Referer，它记录了该HTTP请求的来源地址。</p><p><img src="https://i.imgur.com/QcuxlgF.png" alt=""></p><p>　　通常情况下，当用户登录一个网站后，在Web页面上的任何操作都是来源于这个网站，这个页面上的所有操作请求的Referer值就是操作所在的页面url。因此服务端可以通过对HTTP Referer进行验证，即可判断该请求是否合法。<br>　　还是以文章开头的例子，用户A在银行界面上发起的所有操作的HTTP Referer值都会带有该网站的域名。而攻击者通过木马网站触发的转账请求的HTTP Referer值是木马网站的url。银行服务端只需要增加对Referer的验证就可以判断该转账操作是否合法。</p><p><strong>优点：</strong><br>　　简单方便。只需要在服务端增加拦截器对请求的HTTP Referer统一校验，没有侵入性。</p><p><strong>缺点：</strong><br>　　1） Referer的值是浏览器提供，尽管你理论上HTTP协议和浏览器可以共同保证。但浏览器并不是完全可信的，有些浏览器比如IE6有方法可以篡改Referer值。<br>　　2） Referer记录下用户的访问来源，涉及到用户隐私保护，在某些地区如欧洲北美等地区用户保护组织并不认可通过Referer发送来源信息，用户可以自己在浏览器中设置禁止发送Referer信息。</p><h3 id="3-3-增加token验证"><a href="#3-3-增加token验证" class="headerlink" title="3.3 增加token验证"></a>3.3 增加token验证</h3><p>　　CSRF的攻击者通过完整伪造用户请求，诱导用户在自己的浏览器发起了操作请求，而此时请求的验证信息完全来源于用户浏览器的cookie。<br>　　基于上述事实使用token验证时，token必须是不可预测的，并且不能存储在cookie中。惯用的做法是在HTTP请求中增加一个token参数，如CSRFToken，参数值是由服务端随机产生并返回给浏览器的数值，在服务端增加拦截器进行验证。<br>　　具体操作中，Web服务端增加两个拦截器，一个token赋值拦截器，一个token验证拦截器。<br>　　1） 用户在登陆网站时，token赋值拦截器会产生一个随机token并将token置于javascript中返回给浏览器。浏览器在接收到返回消息中的javascript时会立即执行该脚本，该脚本的作用是通知浏览器将CSRFToken设置到下次请求的hander中。<br>　　2） 用户再次发起请求时，hander中会携带CSRFToken到服务端，服务端的token验证拦截器会对该CSRFToken进行验证。<br>　　为了实现方便，一般用户的一次会话会产生一个Token，并保存到session中用于token的验证（注意，分布式系统中需要存在session中）。当然也可以每次请求使用一个token，但是这种方式会造成一个问题：当用户在浏览器中同时打开多个页面同时操作时，一个页面消耗掉token，另外一个页面就不能再使用该token了，此时需要服务端一次产生多个token供多个页面使用，这种方式复杂性就增加了。<br>　　一般实现是为javaScript制作一个钩子返回给浏览器以监控浏览器的JS动作，当浏览器下一次操作时，钩子就会生效向Header中添加token（当然脚本中也可以同时向from中写入token），非IE浏览器可以使用XMLHttpRequest，IE浏览器使用window.XMLHttpRequest，关于XMLHttpRequest可参考<a href="http://www.w3school.com.cn/xmldom/dom_http.asp。" target="_blank" rel="noopener">http://www.w3school.com.cn/xmldom/dom_http.asp。</a></p><p><strong>优点：</strong><br>　　安全性高，无侵入性。实现原理也并不复杂。</p><p><strong>缺点：</strong><br>　　1） 返回消息中需要携带JavaScript片段，增加了网络传输负担。<br>　　2） 如果网站支持跳转到用户指定个人网站，那么这种方式会造成token泄露，因此这种情况还需要做特殊处理。</p><h3 id="3-4-开源工具"><a href="#3-4-开源工具" class="headerlink" title="3.4 开源工具"></a>3.4 开源工具</h3><p>　　<a href="https://github.com/aramrami/OWASP-CSRFGuard" target="_blank" rel="noopener">OWASP-CSRFGuard</a>是一个拥有BSD许可的友好开源软件，通过简单配置即可使用。</p><h2 id="4-CSRF测试"><a href="#4-CSRF测试" class="headerlink" title="4. CSRF测试"></a>4. CSRF测试</h2><p>　　开源测试工具<a href="https://www.owasp.org/index.php/CSRFTester" title="CSRFTester" target="_blank" rel="noopener">CSRFTester</a>工具可以进行测试。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>　　CSRF的Token防御仅能对抗CSRF攻击，如果网站还存在XSS漏洞，攻击者可以通过模拟客户端浏览器执行任意操作，攻击者可以获取到Token，并构造出合法请求而绕过CSRF防御。因此安全防御必须成体系建设。</p><p>参考</p><blockquote><p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank" rel="noopener">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)</a><br>《白帽子讲Web安全》<br><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html?mhq=token%20%20%E6%94%BB%E5%87%BB&amp;mhsrc=ibmsearch_d" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html?mhq=token%20%20%E6%94%BB%E5%87%BB&amp;mhsrc=ibmsearch_d</a><br><a href="http://www.yihaomen.com//article//java//408.htm" target="_blank" rel="noopener">http://www.yihaomen.com//article//java//408.htm</a><br><a href="https://my.oschina.net/langxSpirit/blog/678901" target="_blank" rel="noopener">https://my.oschina.net/langxSpirit/blog/678901</a><br><a href="https://blog.csdn.net/u013711961/article/details/70237515" target="_blank" rel="noopener">https://blog.csdn.net/u013711961/article/details/70237515</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　CSRF（Cross Site Request Forgery），跨站点请求伪造，是一种常见的Web攻击方式。&lt;/p&gt;
&lt;h2 id=&quot;1-CSRF如何攻击？&quot;&gt;&lt;a href=&quot;#1-CSRF如何攻击？&quot; class=&quot;headerlink&quot; title=&quot;1. CS
      
    
    </summary>
    
      <category term="安全隐私" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E9%9A%90%E7%A7%81/"/>
    
    
      <category term="Web安全" scheme="http://yoursite.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="CSRF" scheme="http://yoursite.com/tags/CSRF/"/>
    
      <category term="Token" scheme="http://yoursite.com/tags/Token/"/>
    
  </entry>
  
</feed>
