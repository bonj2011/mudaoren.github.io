<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木道人</title>
  
  <subtitle>看风的必不撒种；望云的必不收割。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-04T16:09:24.855Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mudaoren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>子女教育问题</title>
    <link href="http://yoursite.com/2018/11/04/%E5%AD%A9%E5%AD%90%E6%95%99%E8%82%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/04/孩子教育问题/</id>
    <published>2018-11-04T15:58:58.731Z</published>
    <updated>2018-11-04T16:09:24.855Z</updated>
    
    <content type="html"><![CDATA[<p>　　现在社会充斥着无处不在的压力与竞争，知识层次越高，往往面临的压力也越大。曾参加过一个培训机构的压力测试，测试的对象一个是汽车制造厂的蓝领工人群体，另一个国内某世界500强的民营高科技公司的白领群体，测试的结果令人意外，蓝领工人的压力普遍更小，而知识层次和收入较高的白领群体的压力普遍高很多。面对巨大的职场压力，白领群体往往在工作上付出的时间相对更多，加班成为工作的常态。即使在下班时间也会消耗大量的时间在工作上，还要持续加强自身的学习。然而，我们都面临着一个无法回避的问题：子女教育。</p><p>　　总结一下，孩子的教育归为两类：1）人格修养教育；2）思维、技能培养。</p><p>　　<strong>人格修养教育</strong>是父母必须要做到的部分，孩子的人格养成和修养的提升往往来源于父母的言传身教，在孩子形成是非判断能力前，身教往往更有效。孩子身上往往会反映出父母的一些行为习惯，这就是问题的家族性遗传。如果孩子性格暴躁，那么一方面是天生的性格特点，而最有可能的是因为父母一方性格比较暴躁，孩子很快就会学会。不信你可以观察下，大部分孩子的言行举止都会与父母神似。作为父母，我们必须先做好榜样，才能教会孩子。</p><p>　　<strong>思维、技能培养</strong>可以由父母以外的更专业的角色来承担，比如培训机构、学校，并不需要父母的言传身教。但是现在培训机构或者学校为了保证效果会给父母留各种的作业和任务，要求家长帮助孩子完成，这无形中增加了父母的负担。我的观点是如果你的精力不足，那么重点培养孩子的思维能力，适当挖掘孩子的兴趣，技能的教育不可缺少但是优先级最低。</p><p>　　这两类，无论哪一类，都需要父母花费大量时间。孩子的教育其实拼的是父母。孩子往往是在父母的基础上成长起来的，你的水平决定了你孩子的起始水平。你是否想过你的业余时间有多少？每天花费在孩子身上的时间有多少？每周有多少？跟孩子一起时都做些什么？你是如何教育孩子的？</p><p>　　如果父母双方都在职场，时间紧张，那么合理规划自己的业余时间以保证在孩子教育上的投入是很有必要的。</p><p>　　<strong>我的建议</strong>是家务的事情，能外包的就不要自己做。洗衣、做饭、清洁这些工作完全可以交给他人去做，把时间省下来，用在孩子身上。<br>　　父母需要多读一些教育方面的书籍，提升自我修养，学会帮助孩子树立正确的人生观和价值观。<br>　　与孩子在一起时，要保证质量和效果，多与孩子做深层次的交流与互动，培养孩子高尚的品格，挖掘孩子的兴趣。<br>　　技能的培养交给专业的机构，花费少量的时间做孩子的辅导。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　现在社会充斥着无处不在的压力与竞争，知识层次越高，往往面临的压力也越大。曾参加过一个培训机构的压力测试，测试的对象一个是汽车制造厂的蓝领工人群体，另一个国内某世界500强的民营高科技公司的白领群体，测试的结果令人意外，蓝领工人的压力普遍更小，而知识层次和收入较高的白领群
      
    
    </summary>
    
      <category term="教育" scheme="http://yoursite.com/categories/%E6%95%99%E8%82%B2/"/>
    
    
      <category term="教育，时间管理" scheme="http://yoursite.com/tags/%E6%95%99%E8%82%B2%EF%BC%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一个离职华为员工的十年感悟（转）</title>
    <link href="http://yoursite.com/2018/11/03/%E4%B8%80%E4%B8%AA%E7%A6%BB%E8%81%8C%E5%8D%8E%E4%B8%BA%E5%91%98%E5%B7%A5%E7%9A%84%E5%8D%81%E5%B9%B4%E6%84%9F%E6%82%9F/"/>
    <id>http://yoursite.com/2018/11/03/一个离职华为员工的十年感悟/</id>
    <published>2018-11-03T11:22:13.447Z</published>
    <updated>2018-11-03T11:01:34.666Z</updated>
    
    <content type="html"><![CDATA[<font face="微软雅黑">一毕业就加入公司，做过研发、一线，到今年已经是第十年（九年两个月）了；做人得感恩，首先必须要感谢公司，在公司遇到LP，有了娃，帝都买了房（有贷款）。<br><br>结合心声大家经常讨论的问题，以下有一点小收获，非经历贴非炫耀贴，分享给后来人，希望对困惑的人有所帮助；对或不对、听或不听，自行判断；觉得错的不用喷了，本周五就截止了，有问题可以留言，我尽量答复。<br><br><strong>第一点，人和人区别就是思维，不断更新的思维体系；人可以累，但不能停止思考。</strong><br><br>很多人最大的恐慌估计就是明知自己在打杂，又不敢或不能出去，担心出去没有竞争力。其实，这部分同学，大多数只停留在想一想的阶段，还没有到思考的阶段，没有到体系的阶段；竞争力，我的总结是工作经历+不断进步的思维体系，还有你的圈子；你会发现，每层领导都比下级领导牛，区别就是经验和思维逻辑。平时不要只抱怨，也要多思考，多学习，不断的更新自己；挑战别人容易，自己积累很难；如果一段时间，感觉自己一直很牛或者自己没有提升的输入/输出，那真的好好反思自己了，思维体系是顶层，是所有的基础，人可以累，不能停止思考，这就是哲学的本质。<br><br><strong>第二，身体是革命的本钱。</strong><br><br>公司导向是艰苦奋斗，身边一些兄弟真可以说是糟蹋自己的身体，来表现奋斗；如果能拼上去（至少19以上）还值得，不然病了没人管你；身边一个哥们得了很严重的病，后来公司也没管，离职了。<br><br>男人身体有两个关键时间点一定要注意：第一个是35岁，男人体质下降转折点；第二个是45岁，心血管疾病发生率高发期，经常喝酒熬夜的需要注意。<br><br>你没了，你这一辈子可能是在给你的司机打工（那天看到的一个新闻）。<br><br>建议平时多跑步（注意保暖，保护膝盖）、游泳，做些无氧增加肌肉，家里也行，哑铃、跳绳、卷腹、平板支撑等等，不要说自己累没有时间等，没有人不累，不是非要跑10公里才叫运动，只要你想明白了，你就会知道怎么做。<br><br><strong>第三，家庭是根基，家都是温暖的港湾和动力源泉</strong><br><br>人的爆发来自于安全感，家是安全感的重要来源，要懂得经营，家庭会给你很多的动力；不要动不动就吵架、离婚，离婚对家庭、孩子没有赢家，人品底线出了问题除外。<br><br>心声有同事说她老公天天打游戏，一个大人怎么能这样呢？？这种情况属于你老公不知道如何处理自己困境，迷茫，他也不是故意的。<br><br>很多人“不思进取”其根因，他的父母只停留在“好好学习”的层次，父母没有教给他正确的教育，他不知所措；那么，你就要思考了，你提升了吗？作为你的人生另一半，你该如何帮忙他提升呢？如何让你的孩子不走老路呢？<br><br>分享一个经验，人天生就不爱听别人否定自己，请要不整天JJYY只会增加他的反感，人本能容易接受第三方的经验。<br><br>可以偶尔游戏、电影、运动、喝酒释放自己，但要养成看书/听书，多与人交流，每个人都有比自己强的地方，看书和与人交流是一种很好的方式，把这个习惯带给你的家人和孩子。如果你的圈子就只有喝酒，只能说明你的圈子很低。<br><br><strong>第四，没有不懂事的孩子，只有不学习的家长；教育拼的是家长不是孩子，本质就是你和他一起提升；不要说等我挣完钱了抽时间在管他。</strong><br><br>最近天涯曝光很多渣男，一个男人身体偶尔偏航，精神可以偶尔出轨，但人品一定不能；而，身边很多人对孩子可以说没有教育可言，你有没有想过，二十年后你的娃可能也会上天涯？想想这是多么可怕的事情；说实话，一方面公司太商业没有道德和精神，另一方面，是自己的父母从小没有给予我们正确的教育体系；那么，要么是我们自己努力改变自己形成教育传递给下一代，要么把碰壁的机会留给你的娃，选择后者，可以说是自私，等你老了你的娃内心里一定会责怪你的。<br><br>教育不是数理化，不是学习成绩；内核是心理学，孩子未来与人合作，自我更新处理能力；中间，品味、仪表姿态、财商；最后才是技能。内核和中间层出了问题，技能能好吗？或者光有学习成绩就够了吗？<br><br>心声有说，我孩子天天打游戏求破？破什么，你平时在家看手机不？打游戏不？你都做不到，怎么要求一个孩子呢？为了孩子的学习，你有没有学习教育方面的书籍和交流？<br><br><strong>第五，要不要在公司干下去？每天你都要思考，公司不是家，你学到了什么，你未来如何规划。</strong><br><br>多出去看看，你会发展现在的公司是个非常好的平台，但对于个人是不是最好的，你要分析；如果你的能力很强、逻辑思维和口才好、懂得和领导拉关系，机会得当，能拼到20以上，建议你好好拼搏一把。高管的待遇和境界是值得你付出的。<br><br>现在公司已经过了爆发期，到了和平发展期，个人迸发机会真的越来越少；如果你不是最牛X的那波人，必须面对现实，多思考，公司毕竟还是逃不开通信设备的圈子，这个圈子很小，都被公司给打的差不多了，没有了磨盘的市场，杀了驴，你又能如何？<br><br>在公司各个岗位的待遇，在其他小公司都是小主管的待遇，你出去之后很容易形成落差；公司是个庞大的组织，虚职一堆，有竞争力的岗位有多少，对于公司你只是一个螺丝钉，胶片可以写一年两年，写到45岁你还剩什么？<br><br>千万别想着到45岁财务自由，再降低工资找个公司，一样工资，谁不喜欢年轻力壮的，那个时候想创业，想想你的身体和思维还活跃吗？<br><br>社会变化这么快，那个时候你的几套房子能够抗风险的吗？？<br><br>其实，搞个兼职或创业，也是个不错的选择；不要偏激的以为创业就是互联网，传统行业也是个不错的选择，很多传统行业利润都很好，只是你不在圈子里，可以现在不做，但一定要想，万一机会来了呢？<br><br><strong>第六，在公司干多久对自己有利？</strong><br><br>即使工作中有很多不爽，你要相信华为走到今天一定有他过人的地方，一定是比外面简单一些的，不要太过批评；公司的管理和流程是公司发展的根本，技术本身就是为了管理服务的，这也是外面很多公司都想学习，那么这个也可能是你的资本，请静下心来多思考，你能带走哪些？<br><br>在一个公司，时间不要太短，建议3年左右；还是要有些积累，出去好和下一家谈；平时有有时间网上发简历，看看自己到底值多少钱，想好惯例前，至少3个月认真找下一家；5年也是一个比较好的时间点；35岁，是男人职业关键期，也是很多大厂商很多岗位招聘的限制年龄；过了这个工龄，出来竞争力同比下降了。<br><br><strong>第七，研发要不要转一线？</strong><br><br>你无非想问这几个问题：<br><br>关于一线岗位的选择，有情商可做客户经理，待遇最好，可以积累圈子，这是完全不同的路线，这相当于脱离了技术，想好，不是谁都适合；产品经理，事情多而杂；想轻松调养身体，选渠道经理；服务经理相对压力小，竞争力也少一些；<br><br>累不累？首先，在公司主力部门（非平台），就没有几个轻松的岗位；研发是持续的累，一线是有节奏的累，忙的时候经常通宵，没有周末，不忙的时候可以有周末，平时工作时有走路和抬头的时间，可以接触一些人；<br><br>然后，哪个更挣钱？正常情况是要向一线倾斜的，但目前公司业绩不好，没有了403项目奖金，都差不多；<br><br>最后，岗位区别；大部分研发出来选择产品经理的居多；两个岗位相同点打杂事情都不少；研发偏封闭，一线较开放；研发有团队的概念，领导就坐你屁股后面，一线你和领导天天各种跑；研发偏执行，一线需要独立思考，需要一些情商；有些人在研发干的特别好的，到市场都熄火了；反而有一些在研发混不下去的，到一线如鱼得水，他们头脑更灵活，更懂得投“机”，懂得如何找到领导为核心，而不是公司的利益。一线可能涉及到换地方，充分沟通，后方要稳。<br><br>一线没有回头路，大部分都出去了，可以回到研发和市场的中间，很难回到纯研发岗。出来后，从公司出来，大部分只能做你现在的这个岗位了。想好了再出来。所有的路，没有对错，必须是你自己拍板，不能把决策权留给别人。<br><br><strong>第八，工作多长时间从研发转一线合适？</strong><br><br>个人建议2-3年，不要超过5年；研发和市场是两种工作方式，或者从某种意义上说是相反的方式；人的惯性思维、岗位经验一旦形成，时间越长，越难适应新岗位；而且，工龄长了，对新岗位不是好事。要想升职，多轮换几个办事处；<br><br>关于海外，现在真的过了当年暴发户的年代了，现在没有太好的地方，出去很难回来，除非你有人，所以你一定要多培养领导资源。现在很多海外开始裁员了，有的裁员50%，公司日子越来越难。<br><br><strong>第九，公司有一种累，叫虐心</strong><br><br>“白天吵架、晚上加班干活”，这是一个离职师姐的总结，很形象；<br><br>原因就是公司给了每个部门和岗位的压力，平衡制约，而各个岗位为了体现自己的价值，拼命的找事，产生了内耗，现在公司内耗很严重，很多事情，从我看对公司价值不大，但对个人来讲非常虐心，这是最催人老的地方，公司经常看到一头白发的小伙子，脾气暴躁、脸色很差的女汉子，这种老，不是花几千做个美容买个豪华化妆品能弥补的；有些部位老了，再也回不去了；虐心容易激发癌症，推荐大家看看近藤诚的书，我正在看。<br><br><strong>第十，家庭生活如何和谐？</strong><br><br>看很多员工经常发离婚、吵架，挺着急；作为过来人，我也经历过吵架到现在的和睦；分享几点经验；<br><br>1、一定要多思考，多学习，多进步！你夫妻关系紧张一定是你不够进步，一定是，不要把责任仍给对方。<br><br>2、夫妻吵架也是正常的，夫妻都要经过互相爱慕，然后幻灭，最后内省的过程；这是有心理学依据的，要多看书，推荐《亲密关系》等书籍；<br><br>3、不要害怕吵架，生活需要掐架，需要波澜；任何的谈判都是基于竞争的，历史上很多谈判都是一边打仗一边谈，最终打服了才有了谈的资本，然后适当让一下；这就是谈判。<br><br>4、吵架要有底线，借用《正面管教》的一句话，温柔而坚定；不要动手，不要骂人，简单说要有人品；越近的人，感情伤了，很难恢复；个人的修为要提升。<br><br>5、最好的方法，你先进步了，同时让你的另一半也进步，这才是真谛。<br><br>6、只要ta不出原则性问题，你要相信还是原配好。即使是渣男，也有你的过错，人性都有灰暗的一念，肯定有你的小错，你压制了别人，别人就会反弹你；你太迁就了别人，就激发了他的阴暗面；你有没有关注过他的心里真正在想什么？他的儿时有什么经历？平时的你提高了没有？你如何帮忙他成长呢？还是只有掐。<br><br>7、家里矛盾包括社会矛盾，说通俗一点，人有时候都是嘴贱，不占便宜死不休；每天都需要别人说点好的，抬高自己，错都是别人的；老婆觉得我嫁到你们家，你们应该供着；老公觉得，我们老家老婆就应该天天被骂，这是传统；两个内心反差，加上儿时缺乏良好的沟通教育，这生活能好吗？如果确实水火不容，就让老人回去，自己体会到了辛苦，在让他们过来；人不能觉得别人天生都是欠自己的。<br><br><strong>最后，写给我心中的公司，伟大但仍然风险重重。</strong><br><br>公司领导也看不到，就算写给自己的第一个十年吧；三个方面：<br><br><strong>1、战略惰性</strong>：首先要说，LB确实很牛X，一直保持高度的自我革新，膜拜的偶像，我在公司学到了很多，感激；但我想说，LB年龄大了，缺少接班人这是最让人痛心地方；LB的理解力和专制，在公司刚起步阶段和腾飞阶段，快速聚集主航道，以客户为中心艰苦奋斗，打跑了很多不能干脏活累活的外国人，获得成功；但从近十年发展看，公司一直在吃运营商的老底子，战略上惰性了，丢掉了很多机会（比如云的趋势、视频的趋势，造就了多少个百亿的企业），在很多的机会面前畏首畏尾（短期看不到钱的），又成了别人眼中当年的外国人，真是轮回；<br><br>现在的手机有核心竞争力吗（CPU算是国产的情怀吧）？我们用运营商的人力和薪资体系，套上消费者BG上，和国内OV打，没有优势可言，又没有苹果的高度；同样，除了品质，企业网有什么竞争力吗？运营商是块状大蛋糕，企业网是小远散点，客户需要培育，不可能快速形成规模，人均效益和运营商没法比，自给自足很困难，很难更新，大的方向上失去了视频的大趋势，卡在云的趋势中，关键部件都不是自己的，在给三星和intel打工，未来在哪里；搞了个2012探索新领域，现在还没看到冰山；企鹅厂兼并小公司，虽然口碑不好，但确实发挥了大公司耍流氓的最高境界，保持非常敏感的嗅觉，不断的更新自己，不被别人革命掉；现在公司的情况真的不乐观，未来的路很长，在外面遥祝公司百年长青。<br><br><strong>2、缺少精神文明建设</strong>：目前的公司，就是改革开放的中国，一只手发展经济，丢了精神建设；在经济红利区，只要给钱随便骂，当你和平发展时期怎么办？部门独立核算，强考评，让很多员工养成了非常“势利”的习惯，和自己考评相关的，领导在场的，所有功劳都往自己身上晒，今天踢这个一脚踢那个一脚，晒存在感；领导不在场，和自己考评不强相关的，你以为你是谁啊？一个国家没有国家荣誉感、集体主义精神，人民没有信仰很可怕，一个企业同样也需要。但不是说大家每天空谈精神，不要物质。<br><br><strong>3、人力资源的懈怠</strong>：人力资源对公司很重要，公司成长过程中人力逼研发和市场前行，但忽视对人力资源的变革，没人管；现在人力资源的薪资已经是研发市场最羡慕的岗位，而且从不招聘，没有点关系进不去，已经成了温柔乡了；人力属于上游部门，这是非常可怕的；新形势下，人力和组织如何布局？今年突然说离职率低裁员，不应该是今天LB说离职率低，才被动反应；公司的懈怠、管理层的错综关系，责任首先是领导和上游部门，首先应该动金字塔尖，而不是下面的根基，裁几个基层员工能解决公司前进的问题吗？这些都是没有对人力资源产生很好的牵引和抑制的体现；内部关系也很复杂，主管一言堂，看一个17B多么大的势力。大家经常诟病的问题，内耗、胶片文化、无效加班、组织臃肿、一言堂等，根深蒂固，很难改变，慢慢来吧；<br><br>昨天看了一本书《爸爸军团》推荐给大家，假如你被宣布得了癌症，躺在床上，闭上眼睛，想想你会有什么遗憾？孩子的教育？自己的身体？家庭关系？照顾父母？等等，那么现在还等什么呢，不要让自己老的时候才去后悔。</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font face=&quot;微软雅黑&quot;&gt;一毕业就加入公司，做过研发、一线，到今年已经是第十年（九年两个月）了；做人得感恩，首先必须要感谢公司，在公司遇到LP，有了娃，帝都买了房（有贷款）。&lt;br&gt;&lt;br&gt;结合心声大家经常讨论的问题，以下有一点小收获，非经历贴非炫耀贴，分享给后来人，希
      
    
    </summary>
    
      <category term="人生经验" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="人生，感悟" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%EF%BC%8C%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat的web.xml配置</title>
    <link href="http://yoursite.com/2018/10/30/Tomcat%E7%9A%84web%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/30/Tomcat的web配置/</id>
    <published>2018-10-30T00:01:36.687Z</published>
    <updated>2018-10-31T15:25:34.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-xml出现的位置"><a href="#web-xml出现的位置" class="headerlink" title="web.xml出现的位置"></a>web.xml出现的位置</h2><p>　　tomcat中有两处使用到web.xml配置，一个是$HOME/conf/web.xml，另一个是$HOME/webapps/myapps/WEB-INF/web.xml。tomcat启动时，首先读取全局的$HOME/conf/web.xml，再读取/WEB-INF/web.xml。前者是全局性的，会在所有webapps中生效，后者只在本webapps中有效。</p><h2 id="web-xml中元素配置的顺序要求"><a href="#web-xml中元素配置的顺序要求" class="headerlink" title="web.xml中元素配置的顺序要求"></a>web.xml中元素配置的顺序要求</h2><p>　　web.xml的root元素是web-app，除此之外，其他的内部元素都是非必须的。web-app下的子元素没有严格的顺序要求。但是，同一类型的配置是有顺序要求的，比如filter-mapping必须要跟在对应的filter之后，并且对隶属于同一个filter的filter-mapping，servlet在匹配时会先匹配前面的mapping的doFilter()方法。同样的道理servlet和servlet-mapping也是一样的处理。</p><h2 id="web-xml中元素的加载顺序"><a href="#web-xml中元素的加载顺序" class="headerlink" title="web.xml中元素的加载顺序"></a>web.xml中元素的加载顺序</h2><p>　　不论web-app中的子元素配置的顺序如何，servlet加载时会按照context-param -&gt; listener -&gt; filter -&gt; servlet的顺序进行加载。</p><h2 id="web-xml的配置说明"><a href="#web-xml的配置说明" class="headerlink" title="web.xml的配置说明"></a>web.xml的配置说明</h2><pre><code>下面这些配置仅仅包括常用配置&lt;web-app&gt;    &lt;icon&gt;&lt;/icon&gt;  应用图标，在GUI管理工具中使用    &lt;display-name&gt;&lt;/display-name&gt; Web应用名称    &lt;description&gt;&lt;/description&gt;  Web应用描述    &lt;context-param&gt;&lt;/context-param&gt;  声明应用范围内的初始化参数    &lt;filter&gt;&lt;/filter&gt;  过滤器配置：将一个名字与一个实现javaxs.servlet.Filter接口的类相关联    &lt;filter-mapping&gt;&lt;/filter-mapping&gt; 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联    &lt;servlet&gt;&lt;/servlet&gt;  在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。    &lt;servlet-mapping&gt;&lt;/servlet-mapping&gt;  为servlet指定非缺省的URL    &lt;session-config&gt;&lt;/session-config&gt; 指定session配置。如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。     &lt;listener&gt;&lt;/listener&gt; Context或会话监听器配置。事件监听程序在建立、修改和删除会话或servlet环境时得到通知    &lt;welcome-file-list&gt;&lt;/welcome-file-list&gt; 指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件。      &lt;taglib&gt;&lt;/taglib&gt;  用来设定JSP网页所用到的Tag Library路径    &lt;resource-ref&gt;&lt;/resource-ref&gt; 定义利用JNDI取得站台可利用的外部资源，比如JDBC    &lt;security-constraint&gt;&lt;/security-constraint&gt; 认证配置，与login-config元素联合使用    &lt;login-config&gt;&lt;/login-config&gt;  指定sercurity-constraint下使用怎样的登陆机制    &lt;security-role&gt;&lt;/security-role&gt;  安全角色的一个列表，与security-constraint配套使用    &lt;error-page&gt;&lt;/error-page&gt;  在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，映射到对应页面    &lt;env-entry&gt;&lt;/env-entry&gt;  声明Web应用的环境项    &lt;ejb-ref&gt;&lt;/ejb-ref&gt;  声明servlet使用的EJB    &lt;ejb-local-ref&gt;&lt;/ejb-local-ref&gt;  声明servlet使用的EJB的本地接口&lt;/web-app&gt;</code></pre><h3 id="display-name和description"><a href="#display-name和description" class="headerlink" title="display-name和description"></a>display-name和description</h3><p>这两个一般会配套使用，比如：</p><pre><code>&lt;display-name&gt;Tomcat Manager Application&lt;/display-name&gt;&lt;description&gt;A scriptable management web application for the Tomcat Web Server;    Manager lets you view, load/unload/etc particular web applications.&lt;/description&gt;</code></pre><h3 id="context-param"><a href="#context-param" class="headerlink" title="context-param"></a>context-param</h3><p>定义传递给servlet或JSP的参数。比如数据库连接参数、文件名或网站信息等。</p><pre><code>&lt;context-param&gt;        &lt;param-name&gt;ContextParameter&lt;/para-name&gt;        &lt;param-value&gt;test&lt;/param-value&gt;        &lt;description&gt;It is a test parameter.&lt;/description&gt;    &lt;/context-param&gt;</code></pre><p>上面的配置对webapp的所有servlet生效。也可以设置仅仅对某个servlet生效，但是此时context-param元素必须在servlet元素中，如下：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;mypack.SampleServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;initParam1&lt;/param-name&gt;        &lt;param-value&gt;2&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;</code></pre><h3 id="filter和filter-mapping"><a href="#filter和filter-mapping" class="headerlink" title="filter和filter-mapping"></a>filter和filter-mapping</h3><p>过滤器在指定的URL传递给servlet之前，或执行servlet之后执行。<br>filter的子元素包括：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt;  定义过滤器的名字。当有多个过滤器时，不能同名    &lt;filter-class&gt;org.apache.catalina.filters.SetCharacterEncodingFilter&lt;/filter-class&gt;  指定实现这一过滤的类，这个类负责具体的过滤事务    &lt;init-param&gt;  配置过滤器的初始化参数        &lt;param-name&gt;encoding&lt;/param-name&gt;  参数名        &lt;param-value&gt;UTF-8&lt;/param-value&gt;  参数值    &lt;/init-param&gt;&lt;/filter&gt;</code></pre><p>过滤器配置完成后，需要通过filter-mapping来配置过滤器生效的对象，生效对象可以是URL或servlet。</p><ul><li>对URL生效，使用url-pattern进行配置，所有符合模式的入向URL都会被过滤器处理。如：</li></ul><pre><code>&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt;  在filter中定义的过滤器名字    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  指定filter所对应的URL&lt;/filter-mapping&gt;</code></pre><p>在servlet 2.5之后，filter-mapping中可以使用多个url-pattern，进而把多个pattern映射为该过滤器。</p><ul><li>对servlet生效，使用servlet-name配置，会将过滤器的输出传给指定的servlet。如：</li></ul><pre><code>&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncoding&lt;/filter-name&gt; 过滤器名称    &lt;servlet-name&gt;HTMLManager&lt;/servlet-name&gt;  servlet名称。这个servlet必须在前面定义过。&lt;/filter-mapping&gt;</code></pre><h3 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h3><p>用来指定事件监听器。事件监听程序在建立、修改和删除会话或servlet环境时得到通知。</p><pre><code>&lt;listener&gt;    &lt;listener-class&gt;listeners.ContextListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;listener&gt;    &lt;listener-class&gt;listeners.SessionListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><h3 id="servlet和servlet-mapping"><a href="#servlet和servlet-mapping" class="headerlink" title="servlet和servlet-mapping"></a>servlet和servlet-mapping</h3><p>定义servlet，以用于servlet-mapping或者filter-mapping中。</p><pre><code>&lt;!-- 基本配置 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;snoopImpl&lt;/servlet-name&gt;  servlet名字    &lt;servlet-class&gt;com.SnoopImplServlet&lt;/servlet-class&gt;  servlet代表的类&lt;/servlet&gt;&lt;!-- 高级配置 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;snoop&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.SnoopServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;foo&lt;/param-name&gt;  servlet类的参数名        &lt;param-value&gt;bar&lt;/param-value&gt;  servlet类的参数值    &lt;/init-param&gt;    &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;  指定当Web应用启动时，装载Servlet的次序。当值为正数或零时：Servlet容器先加载数值小的servlet，再依次加载其他数值大的servlet。当值为负或未定义：Servlet容器将在Web客户首次访问这个servlet时加载它。    &lt;run-as&gt;        &lt;description&gt;Security role for anonymous access&lt;/description&gt;        &lt;role-name&gt;tomcat&lt;/role-name&gt;  执行此servlet的角色名称。    &lt;/run-as&gt;&lt;/servlet&gt;</code></pre><p>上述元素并不是servlet的全部子元素，除此之外还有jsp-file和security-role-ref。</p><p>默认情况下，web对servlet的请求必须包含servlet的完整类名。但这样使用起来极不方便，可读性不好，因此，常用servlet的别名代替，而servlet-mapping就是用来做servlet与别名映射的元素。</p><pre><code>&lt;servlet-mapping&gt;    &lt;servlet-name&gt;snoop&lt;/servlet-name&gt;  前面定义的servlet名称    &lt;url-pattern&gt;/snoop&lt;/url-pattern&gt;  指定servlet所对应的别名URL或别名&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;snoop&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>这样配置的servlet，web可以通过应用的Context路径拼接url-pattern来访问对应的servlet。上述配置中所有的以“.jsp”结尾的文件名都会由snoop来处理。</p><p>另外一种用法, 会将所有的请求都映射成指定的JSP文件，如下例中的redirector.jsp，这里与重定向不完全相同，因为它动态的计算用于新Context的精确链接。</p><pre><code>&lt;servlet-mapping&gt;    &lt;servlet-name&gt;snoop&lt;/servlet-name&gt;  前面定义的servlet名称    &lt;jsp-file&gt;/redirector.jsp&lt;/jsp-file&gt;  指定web站台中的某个JSP网页的完整路径&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;snoop&lt;/servlet-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h3 id="session-config"><a href="#session-config" class="headerlink" title="session-config"></a>session-config</h3><p>用于设置会话闲置时间。当用户访问的会话超过这个时间时，Tomcat将会丢弃该会话，并回收内存。</p><pre><code>&lt;session-config&gt;       &lt;session-timeout&gt;120&lt;/session-timeout&gt;  会话闲置120分钟后超时   &lt;/session-config&gt;</code></pre><h3 id="welcome-file-list"><a href="#welcome-file-list" class="headerlink" title="welcome-file-list"></a>welcome-file-list</h3><p>配置欢迎页面。假如用户输入了一个<a href="http://host/webAppPrefix/directoryName/这样的包含一个目录名但没有包含文件名的URL时，会发生什么呢？用户能得到一个目录表？一个错误？还是标准文件的内容？如果得到标准文件内容，是index.html、index.jsp、default.html、default.htm或别的什么东西呢？" target="_blank" rel="noopener">http://host/webAppPrefix/directoryName/这样的包含一个目录名但没有包含文件名的URL时，会发生什么呢？用户能得到一个目录表？一个错误？还是标准文件的内容？如果得到标准文件内容，是index.html、index.jsp、default.html、default.htm或别的什么东西呢？</a><br>Welcome-file-list 元素及其辅助的welcome-file元素解决了这个模糊的问题。例如，下面的web.xml项指出，如果一个URL给出一个目录名但未给出文件名，服务器应该首先试用index.jsp，然后再试用index.html。如果两者都没有找到，则结果有赖于所用的服务器（如一个目录列表）。</p><pre><code>&lt;welcome-file-list&gt;      &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;      &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;      &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;  </code></pre><p>可以通过将DefaultServlet参数设置为false,来关闭Tomcat全部的打印目录清单功能：</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlet.DefaultServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;debug&lt;/param-name&gt;        &lt;param-value&gt;0&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;listings&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;</code></pre><h3 id="jsp-config"><a href="#jsp-config" class="headerlink" title="jsp-config"></a>jsp-config</h3><p>jsp-config包括taglib和jsp-property-group两个子元素。</p><ul><li><p>JSP taglib元素具有一个必要的uri属性，它给出一个TLD（Tag Library Descriptor）文件相对于Web应用的根的位置。TLD文件的实际名称在发布新的标签库版本时可能会改变，但我们希望避免更改所有现有JSP页面。此外，可能还希望使用保持taglib元素的简练性的一个简短的uri。这就是部署描述符文件的taglib元素派用场的所在了。Taglib包含两个子元素：taglib-uri和taglib-location。 taglib-uri元素应该与用于JSP taglib元素的uri属性的东西相匹配。Taglib-location元素给出TLD文件的实际位置。例如，假如你将文件chart-tags-1.3beta.tld放在WebApp/WEB-INF/tlds中。现在，假如web.xml在webapp元素内包含下列内容。</p></li><li><p>jsp-property-group的作用是允许将Web应用程序的一组资源配置为不同于全局设置的JSP行为。<br>Scriptlet是个不乐意被见到的东西，因为它会使得HTML与Java程式码交相混杂，对于程式的维护来说相当的麻烦，必要的时候，可以在web.xml 中加上<script-invalid> 标签，设定所有的JSP 网页都不可以使用Scriptlet。 </script-invalid></p><p>  <jsp-config></jsp-config></p><pre><code>&lt;taglib&gt;     &lt;taglib-uri&gt;/charts.tld&lt;/taglib-uri&gt;     &lt;taglib-location&gt;/WEB-INF/tlds/chart-tags-1.3beta.tld&lt;/taglib-location&gt; &lt;/taglib&gt;&lt;taglib&gt;    &lt;taglib-uri&gt;http://tomcat.apache.org/example-taglib&lt;/taglib-uri&gt;    &lt;taglib-location&gt;/WEB-INF/jsp/example-taglib.tld&lt;/taglib-location&gt;&lt;/taglib&gt;&lt;jsp-property-group&gt;    &lt;description&gt;Special property group for JSP Configuration JSP example.&lt;/description&gt;    &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt;  设定名称    &lt;url-pattern&gt;/jsp/jsp2/misc/config.jsp&lt;/url-pattern&gt;  设定值所影响的范围，如： /CH2 或 /*.jsp    &lt;el-ignored&gt;true&lt;/el-ignored&gt;  若为 true，表示不支持 EL 语法    &lt;page-encoding&gt;ISO-8859-1&lt;/page-encoding&gt;  设定 JSP 网页的编码    &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt;  若为 true，表示不支持 &lt;% scripting %&gt;语法    &lt;include-prelude&gt;/jsp/jsp2/misc/prelude.jspf&lt;/include-prelude&gt; 设置 JSP 网页的抬头，扩展名为 .jspf    &lt;include-coda&gt;/jsp/jsp2/misc/coda.jspf&lt;/include-coda&gt; 设置 JSP 网页的结尾，扩展名为 .jspf&lt;/jsp-property-group&gt;</code></pre><p>   </p></li></ul><p>给出这个说明后，JSP页面可通过下面的简化形式使用标签库。</p><pre><code>&lt;%@ taglib uri=&quot;/charts.tld&quot; prefix=&quot;somePrefix&quot; %&gt; </code></pre><h3 id="security-constraint"><a href="#security-constraint" class="headerlink" title="security-constraint"></a>security-constraint</h3><p>用来指定访问设定的资源（目录/url）时所需要的身份验证。一般情况下，用来保护Web应用中的特殊目录。</p><pre><code>&lt;security-constraint&gt;  &lt;display-name&gt;Example Security Constraint - part 1&lt;/display-name&gt;  &lt;web-resource-collection&gt;  描述Web应用程序中的哪些web资源受到指定安全限制的保护     &lt;web-resource-name&gt;Protected Area - Allow methods&lt;/web-resource-name&gt;     &lt;url-pattern&gt;/jsp/security/protected/*&lt;/url-pattern&gt;     &lt;http-method&gt;DELETE&lt;/http-method&gt; 指定安全限制覆盖的HTTP方法     &lt;http-method&gt;GET&lt;/http-method&gt;     &lt;http-method&gt;POST&lt;/http-method&gt;     &lt;http-method&gt;PUT&lt;/http-method&gt;  &lt;/web-resource-collection&gt;  &lt;auth-constraint&gt;  描述允许访问Web组件的安全角色     &lt;role-name&gt;tomcat&lt;/role-name&gt;     &lt;role-name&gt;role1&lt;/role-name&gt;  &lt;/auth-constraint&gt;&lt;/security-constraint&gt;</code></pre><h3 id="login-config"><a href="#login-config" class="headerlink" title="login-config"></a>login-config</h3><p>登录验证设置。Web应用程序通过login-config元素来认证用户，并确认该用户是否为正确的角色。<br>longin-config包含的auth-method子元素用来指定认证方法，BASIC是一种常见的Web认证方式，浏览器给用户提示一个对话框，要求输入用户名和密码，随后Tomcat将给出的用户名和密码与tomcat-users.xml中的用户名和密码进行比较，然后使用前面的security-constraint配置来确定用户是否可访问受保护的servlet。</p><p><strong>这种认证方法实际上有两个步骤：</strong><br>1、检查提供的用户名和密码是否正确。<br>2、判断用户是否映射到特定的安全角色。例如，用户可能提供了正确的用户名和密码，但没有映射到特定的安全角色，也将被禁止访问特定的Web资源。</p><pre><code>&lt;login-config&gt;  &lt;auth-method&gt;FORM&lt;/auth-method&gt;  指定验证方法，它有四个可选值：BASIC(基本验证)、DIGEST(摘要验证)、FORM(表单验证)、CLIENT-CERT  &lt;realm-name&gt;Example Form-Based Authentication Area&lt;/realm-name&gt; 设定当客户端访问受保护区域时，浏览器在其登录对话窗中显示的名称  &lt;form-login-config&gt; 当验证方法为FORM时，配置验证网页和出错网页    &lt;form-login-page&gt;/jsp/security/protected/login.jsp&lt;/form-login-page&gt; 当验证方法为FORM时，设定验证网页    &lt;form-error-page&gt;/jsp/security/protected/error.jsp&lt;/form-error-page&gt; 当验证方法为FORM时，设定出错网页  &lt;/form-login-config&gt;&lt;/login-config&gt;</code></pre><p>login-conf通常会紧跟在security-constraint元素之后，表示要使用哪种安全防护方法来访问受保护的区域。</p><h3 id="security-role"><a href="#security-role" class="headerlink" title="security-role"></a>security-role</h3><p>安全角色：security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。<br>分别地声明角色可使高级IDE处理安全信息更为容易。</p><pre><code>&lt;security-role&gt;        &lt;role-name&gt;tomcat&lt;/role-name&gt;    &lt;/security-role&gt; </code></pre><h3 id="error-page"><a href="#error-page" class="headerlink" title="error-page"></a>error-page</h3><p>用来配置HTTP状态代码或Java的异常类型来指定自定义的错误提示页面。错误提示页面必须是Context内的绝对路径。</p><pre><code>&lt;error-page&gt;  通过错误码来配置error-page。当系统发生404错误时，跳转到错误处理页面。    &lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/NotFound.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;  通过异常的类型配置error-page。当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面。    &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt;    &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><h3 id="env-entry"><a href="#env-entry" class="headerlink" title="env-entry"></a>env-entry</h3><p>Web环境参数：env-entry元素声明Web应用的环境变量。是将参数传递给Web应用程序的Java代码的集中方式之一，应用程序代码会使用JNDI来查询这些参数。</p><pre><code>&lt;env-entry&gt;  &lt;env-entry-name&gt;minExemptions&lt;/env-entry-name&gt;  &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt; 参数类型，就是java的参数类型，必须用全限定类名  &lt;env-entry-value&gt;1&lt;/env-entry-value&gt;  参数值&lt;/env-entry&gt;&lt;env-entry&gt;  &lt;env-entry-name&gt;foo/name1&lt;/env-entry-name&gt;  &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;  &lt;env-entry-value&gt;value1&lt;/env-entry-value&gt;&lt;/env-entry&gt;&lt;env-entry&gt;  &lt;env-entry-name&gt;foo/bar/name2&lt;/env-entry-name&gt;  &lt;env-entry-type&gt;java.lang.Boolean&lt;/env-entry-type&gt;  &lt;env-entry-value&gt;true&lt;/env-entry-value&gt;&lt;/env-entry&gt;&lt;env-entry&gt;  &lt;env-entry-name&gt;name3&lt;/env-entry-name&gt;  &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;  &lt;env-entry-value&gt;1&lt;/env-entry-value&gt;&lt;/env-entry&gt;</code></pre><h3 id="Spring如何配置"><a href="#Spring如何配置" class="headerlink" title="Spring如何配置"></a>Spring如何配置</h3><pre><code>&lt;!-- 指定spring配置文件位置 --&gt;    &lt;context-param&gt;       &lt;display-name&gt;myApp&lt;/display-name&gt;     &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;        &lt;!--加载多个spring配置文件 --&gt;        /WEB-INF/applicationContext.xml, /WEB-INF/action-servlet.xml，classpath*:/spring/spring_dependence.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!-- 定义SPRING监听器，加载spring --&gt;    &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;listener&gt;        &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;    &lt;/listener&gt;&lt;!--单点登出监听器--&gt;&lt;listener&gt;        &lt;listener-class&gt; org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt;    &lt;/listener&gt;&lt;!--登陆认证, 使用CAS server认证--&gt;&lt;filter&gt;    &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt;    &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--自定义应用servlet启动配置--&gt;&lt;servlet&gt;    &lt;servlet-name&gt;myAppServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.mudaoren.test.web.StartServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;100&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet&gt;    &lt;servlet-name&gt;Spring MVC DispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath*:/spring/spring_mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;Spring MVC DispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h3 id="Mapping规则"><a href="#Mapping规则" class="headerlink" title="Mapping规则"></a>Mapping规则</h3><p>当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是<a href="http://localhost/test/aaa.html" target="_blank" rel="noopener">http://localhost/test/aaa.html</a> ，我的应用上下文是test，容器会将<a href="http://localhost/test" target="_blank" rel="noopener">http://localhost/test</a> 去掉，剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下的servlet了。</p><p><strong>　　其匹配规则和顺序如下：</strong></p><ul><li><p>精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /*，这个时候，如果我访问的url为<a href="http://localhost/test" target="_blank" rel="noopener">http://localhost/test</a> ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了。</p></li><li><p>最长路径匹配。例子：servletA的url-pattern为/test/*，而servletB的url-pattern为/test/a/*，此时访问<a href="http://localhost/test/a" target="_blank" rel="noopener">http://localhost/test/a</a> 时，容器会选择路径最长的servlet来匹配，也就是这里的servletB。</p></li><li><p>扩展匹配。如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet。例子：servletA的url-pattern：*.action 以”/’开头和以”/*”结尾的是用来做路径映射的。以前缀”*.”开头的是用来做扩展映射的。所以，为什么定义”/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法识别。</p></li></ul><p>参考：</p><blockquote><p>《Tomcat权威指南》<br>《深入剖析Tomcat》<br><a href="http://www.cnblogs.com/cljdream/archive/2013/11/29/3449308.html" target="_blank" rel="noopener">http://www.cnblogs.com/cljdream/archive/2013/11/29/3449308.html</a><br><a href="https://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-xml出现的位置&quot;&gt;&lt;a href=&quot;#web-xml出现的位置&quot; class=&quot;headerlink&quot; title=&quot;web.xml出现的位置&quot;&gt;&lt;/a&gt;web.xml出现的位置&lt;/h2&gt;&lt;p&gt;　　tomcat中有两处使用到web.xml配置，一个是$H
      
    
    </summary>
    
      <category term="tomcat" scheme="http://yoursite.com/categories/tomcat/"/>
    
    
      <category term="tomcat，web.xml" scheme="http://yoursite.com/tags/tomcat%EF%BC%8Cweb-xml/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC请求处理流程</title>
    <link href="http://yoursite.com/2018/10/29/Spring%20MVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/29/Spring MVC请求处理流程/</id>
    <published>2018-10-28T23:47:55.305Z</published>
    <updated>2018-10-29T00:03:44.100Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/LnG9M8k.png" alt=""></p><p>① 请求离开浏览器，并携带用户的请求信息。首先到达一个单例的前端控制器DispatcherServlet。</p><p>② DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，查询一个或多个处理映射器（handler mapping），获得下一步的Handler（Controller)。</p><p>③ DispatcherServlet 根据上一步获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p><p>④ 提取Request中的请求消息，转换成Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><ul><li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li><li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li></ul><p>⑤ 控制器执行完成后，产生一些信息，这些信息保存在模型（model）中。但是这些信息不可能直接展示，必须以一个友好的界面（html/jsp）来承载，这个界面就是视图（view）表示的界面。然后将模型和视图名返回给DispatcherServlet。</p><p>⑥ 上一步的视图名标示了一个界面，需要通过视图解析器（ViewResoler）来为view找到对应的视图实现（界面，比如JSP）。</p><p>⑦ 视图使用模型数据进行渲染。</p><p>⑧ 将渲染结果返回给用户。</p><blockquote><p>参考：<br>《Spring In Action》<br><a href="https://www.cnblogs.com/dreamworlds/p/5396112.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamworlds/p/5396112.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/LnG9M8k.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;① 请求离开浏览器，并携带用户的请求信息。首先到达一个单例的前端控制器DispatcherServlet。&lt;/p&gt;
&lt;p&gt;② DispatcherServle
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC，请求处理" scheme="http://yoursite.com/tags/Spring-MVC%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC如何接收请求参数</title>
    <link href="http://yoursite.com/2018/10/27/Spring%20MVC%E5%A6%82%E4%BD%95%E6%8E%A5%E5%8F%97%E5%8F%82%E6%95%B0%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2018/10/27/Spring MVC如何接受参数请求/</id>
    <published>2018-10-26T23:32:35.027Z</published>
    <updated>2018-10-27T22:54:27.242Z</updated>
    
    <content type="html"><![CDATA[<p>　　当用户与服务器交互时，需要将用户的输入传递到服务端。这时就涉及到Spring MVC控制器接收客户端请求参数。<br>控制器接收客户端请求参数的方式主要包括：</p><ul><li>查询参数</li><li>表单参数</li><li>路径参数</li></ul><hr><h1 id="方式一：查询参数。"><a href="#方式一：查询参数。" class="headerlink" title="方式一：查询参数。"></a>方式一：查询参数。</h1><p>请求中的查询参数作为Controller的方法参数。<br>请求 url：<code>http://localhost:8080/spittles?max=10&amp;count=2</code></p><h2 id="△-利用函数注解-RequestParam接收参数。"><a href="#△-利用函数注解-RequestParam接收参数。" class="headerlink" title="△ 利用函数注解@RequestParam接收参数。"></a>△ 利用函数注解@RequestParam接收参数。</h2><p><strong>后台代码：</strong></p><pre><code>@Controller@RequestMapping(&quot;/spittles&quot;)public class SpittleController{    private static final String MAX_LONG_AS_STRING = &quot;9223372036854775807&quot;;    @Autowired    private SpittleRepository spittleRepository;    @RequestMapping(method = RequestMethod.GET)    public List&lt;Spittle&gt; spittles(            @RequestParam(value = &quot;max&quot;, defaultValue = MAX_LONG_AS_STRING) long max,            @RequestParam(defaultValue = &quot;20&quot;) int count)    {        return spittleRepository.findSpittles(max, count);    }}</code></pre><p>　　上述片段中的@RequestParam如果有value属性，则value值必须与前台的入参名称一致，如果@RequestParam没有value属性，那其后的方法形参必须与前台的入参名称一致。</p><h2 id="△-通过HttpServletRequest来传递参数"><a href="#△-通过HttpServletRequest来传递参数" class="headerlink" title="△ 通过HttpServletRequest来传递参数"></a>△ 通过HttpServletRequest来传递参数</h2><p><strong>后台代码：</strong></p><pre><code>@Controller@RequestMapping(&quot;/spittles&quot;)public class SpittleController{        @Autowired    private SpittleRepository spittleRepository;    @RequestMapping(method = RequestMethod.GET)    public List&lt;Spittle&gt; spittles(HttpServletRequest request)    {        long max = request.getParameter(&quot;max&quot;);        long count = request.getParameter(&quot;count&quot;);        return spittleRepository.findSpittles(max, count);    }}</code></pre><hr><h1 id="方式二：路径变量。"><a href="#方式二：路径变量。" class="headerlink" title="方式二：路径变量。"></a>方式二：路径变量。</h1><p>请求路径中的一部分作为查询参数。<br>请求 url：<code>http://localhost:8080/spittles/1845647</code></p><p>尽管，这个也可以使用如<code>http://localhost:8080/spittles？spittleId=1845647</code>这样的rul来请求，但是一般在使用GET方法获取资源时，最合适的方式是通过路径，而不是参数。如果这里改成第二种url，则本质上是通过HTTP发起的RPC。</p><pre><code>@Controller@RequestMapping(&quot;/spittles&quot;)public class SpittleController{        @Autowired    private SpittleRepository spittleRepository;    @RequestMapping(value = &quot;/{spittleId}&quot;, method = RequestMethod.GET)    public String spittle(@PathVariable(&quot;spittleId&quot;) long spittleId, Model model)    {        model.addAttribute(spittleRepository.findOne(spittleId));        return &quot;spittle&quot;;    }}</code></pre><p>@RequestMapping(value = “/{spittleId}”, method = RequestMethod.GET)中的spittleId是一个占位符，这个占位符的名字可以随意取，但是这个占位符在url路径中的位置必须与请求url中的位置保持一致，占位符必须使用大括号“{}”表示。另外，这个占位符的名字与注解PathVariable的值spittleId是一致的，如果注解PathVariable不带参数，那么spittle方法的一个参数spittleId必须与占位符的名字一致。</p><hr><h1 id="方式三：表单参数。"><a href="#方式三：表单参数。" class="headerlink" title="方式三：表单参数。"></a>方式三：表单参数。</h1><p>表单参数用于接收大量的用户输入参数，以对输入参数完成处理。</p><h2 id="△-使用对象传递参数"><a href="#△-使用对象传递参数" class="headerlink" title="△ 使用对象传递参数"></a>△ 使用对象传递参数</h2><pre><code>@Controller@RequestMapping(&quot;/spittles&quot;)public class SpittleController{    @Autowired    private SpittleRepository spittleRepository;    @RequestMapping(value = &quot;/register&quot;, method = GET)    public String showRegistrationForm()    {        return &quot;registerForm&quot;;    }    @RequestMapping(value = &quot;/register&quot;, method = POST)    public String processRegistration(@Valid Spitter spitter, Errors errors)    {        if (errors.hasErrors())        {            return &quot;registerForm&quot;;        }        spitterRepository.save(spitter);        return &quot;redirect:/spitter/&quot; + spitter.getUsername();    }    @RequestMapping(value = &quot;/{username}&quot;, method = GET)    public String showSpitterProfile(@PathVariable String username, Model model)    {        Spitter spitter = spitterRepository.findByUsername(username);        model.addAttribute(spitter);        return &quot;profile&quot;;    }}</code></pre><p>　　方法showRegistrationForm()和processRegistration(@Valid Spitter spitter, Errors errors)所接收的url都是<strong>“/spittles/register”</strong>，<strong>前者用于接收GET查询</strong>，并返回一个“registerForm”视图，<strong>后者用于接收POST提交的表单</strong>，并重定向到”/spitter/“ + spitter.getUsername()视图。</p><p>　　也就是重定向（redirect）到showSpitterProfile(@PathVariable String username, Model model)方法所表示的视图，这里的Model中保存的GET请求获取到的结果参数集。</p><p>　　本例中的接收用户提交表单的方法processRegistration(@Valid Spitter spitter, Errors errors)，形参包含一个<strong>Spitter对象</strong>，这个对象中的属性字段与用户HTML中填写的参数名是对应的，如下：</p><pre><code>public class Spitter {  private Long id;  @NotNull  @Size(min=5, max=16)  private String username;  @NotNull  @Size(min=5, max=25)  private String password;  @NotNull  @Size(min=2, max=30)  private String firstName;  @NotNull  @Size(min=2, max=30)  private String lastName;  @NotNull  @Email  private String email;  //setter&amp;getter方法  ... ...}</code></pre><p><strong>前台代码form中submit后没有action属性，所以submit请求的url跟上一步GET到这个HTML页面的url是一致的，即“/spittles/register”。</strong></p><pre><code>&lt;html&gt;      &lt;head&gt;        &lt;title&gt;Spitter&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;               href=&quot;&lt;c:url value=&quot;/resources/style.css&quot; /&gt;&quot; &gt;      &lt;/head&gt;     &lt;body&gt;        &lt;h1&gt;Register&lt;/h1&gt;        &lt;form method=&quot;POST&quot;&gt;          First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot; /&gt;&lt;br/&gt;          Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; /&gt;&lt;br/&gt;          Email: &lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;br/&gt;          Username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;          Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;          &lt;input type=&quot;submit&quot; value=&quot;Register&quot; /&gt;        &lt;/form&gt;     &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="△-直接传递参数"><a href="#△-直接传递参数" class="headerlink" title="△ 直接传递参数"></a>△ 直接传递参数</h2><p>字段作为参数进行传递。以方法processRegistration为例<br><strong>后台代码：</strong></p><pre><code>@Controller@RequestMapping(&quot;/spittles&quot;)public class SpittleController{    @Autowired    private SpittleRepository spittleRepository;    @RequestMapping(value = &quot;/register&quot;, method = POST)    public String processRegistration(HttpServletRequest request,ModelMap map,String username,String password,String firstName,String lastName, String email)    {        Spitter spitter = new Spitter();        spitter.setUsername(username);        spitter.setPassword(password);        spitterRepository.save(spitter);        return &quot;redirect:/spitter/&quot; + spitter.getUsername();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　当用户与服务器交互时，需要将用户的输入传递到服务端。这时就涉及到Spring MVC控制器接收客户端请求参数。&lt;br&gt;控制器接收客户端请求参数的方式主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询参数&lt;/li&gt;
&lt;li&gt;表单参数&lt;/li&gt;
&lt;li&gt;路径参数&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>基于dubbo的微服务部分容器化部署</title>
    <link href="http://yoursite.com/2018/10/22/%E5%9F%BA%E4%BA%8Edubbo%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E5%88%86%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/10/22/基于dubbo的微服务部分容器化部署/</id>
    <published>2018-10-22T15:20:07.273Z</published>
    <updated>2018-11-01T23:44:57.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vmall微服务特点"><a href="#Vmall微服务特点" class="headerlink" title="Vmall微服务特点"></a><table><tr><td bgcolor="#54FF9F"><strong>Vmall微服务特点</strong></td></tr></table></h2><ul><li>Vmall采用基于dubbo+zookeeper的RPC微服务化架构方案，划分40多个微服务。缓存层采用redis、memcache，持久层采用mysql，消息框架使用rocketMQ。</li><li>微服务间即存在RPC调用，又包含部分http调用。</li><li>生产环境同时部署在华为公有云的北京、廊坊和广州三地，三地间通过专线建立连接。</li></ul><h2 id="容器化策略"><a href="#容器化策略" class="headerlink" title="容器化策略"></a><table><tr><td bgcolor="#54FF9F"><strong>容器化策略</strong></td></tr></table></h2><ul><li>将服务分成有状态服务和无状态服务，因对数据要求较高，所以数据库等有状态服务暂时保持部署在ECS，仅对无状态服务实行容器化。</li><li>分步骤实施，初始阶段选取两个微服务进行容器化灰度试点，保证容器化的风险可控。</li><li>对docker swarm、k8s、mesos+Marathon、华为公有云CCE和华为IT平台的HIC的对比，鉴于成本、可靠性、稳定性等因素，决定采用华为公有云CCE。</li></ul><h2 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a><table><tr><td bgcolor="#54FF9F"><strong>面临的问题</strong></td></tr></table></h2><p>因为华为云的CCE是基于K8s的云服务引擎，很好的保证了高可用、弹性伸缩、监控告警、滚动升级、镜像管理等功能，所以我们只需要应对一下几个关键问题：</p><ul><li>统一配置中心，容器化需要统一配置中心的支持。</li><li>日志采集，需要解决日志的集中采集和处理问题。</li><li>部分服务的容器化，需要解决容器服务的dubbo注册问题和容器服务与非容器服务之间的网络通信问题。</li></ul><h2 id="实施过程"><a href="#实施过程" class="headerlink" title="实施过程"></a><table><tr><td bgcolor="#54FF9F"><strong>实施过程</strong></td></tr></table></h2><p>1.统一配置中心。选用携程的apollo开源组件。<br>2.日志采集与处理。将应用日志输出到宿主机目录，通过统一开源组件收集。<br>3.容器部署：<br>　步骤一 镜像制作</p><p>开机启动脚本</p><pre><code>#!/bin/bashif [[&quot;${ELB_IP}&quot;x!=&quot;&quot;x]]&amp;&amp;[SERVICE_NAME] ; then    cp /etc/hosts /etc/hosts.temp    sed -i &apos;s/^.*$&apos;{SERVICE_NAME}&apos;/&apos;${ELB_IP}&apos; $&apos;{SERVICE_NAME}&apos;/g&apos; /etc/hosts.temp    cat /etc/hosts.temp &gt; /etc/hostselse    echo &quot;Please set env SERVICE_NAME and ELB_IP&quot;    return1fisource /etc/profilebash /root/myApp/bin/start.sh run</code></pre><p>　步骤二 镜像上传<br>　步骤三 创建cce集群<br>　步骤四 创建工作负载<br>　步骤五 创建负载均衡<br>　步骤六 为工作负载创建访问方式<br>  步骤七 域名访问方式<br>　　　　四层负载均衡和七层负载均衡</p><p>遇到的问题？<br><strong>1）跨k8s集群的docker与zookeeper间的通信问题！</strong><br><strong>dubbo注册原理：</strong><br>dubbo服务提供者在注册服务到zookeeper时，如果dubbo:protocol中配置了本机IP和port会使用配置的参数到zookeeper注册，本机则会监听该port，如果服务的dubbo:protocol没有配置过本机IP和port时，dubbo服务提供者将通过网卡自己获取本机IP，同时port默认取20880，docker中的dubbo服务会获取到docker的私有ip。<br><strong>问题：</strong><br>实际试点时，dubbo和zookeeper是在单独的虚拟机上，并不属于k8s集群，而服务提供者在docker中，此时服务提供者将docker私有IP注册到zookeeper上，服务提供者定时向zookeeper发送TCP心跳保持连接，当消费者查找到这个docker的Ip，并去连接时就会出现找不到IP的问题，因为docker的私有Ip不能暴露到pod外。<br><strong>解决方法：</strong><br>方法一 通过iptables路由规则，通过多层桥接配置实现网络连通。<br>方法二 通过配置私网四层负载均衡，将负载均衡和docker做IP端口映射，并将负载均衡IP配置到dubbo:protocol中。消费者会访问负载均衡IP和端口，进而找到docker中的应用。在公有云上四层负载均衡是免费的，建议每个服务申请一个负载均衡，这样端口配置会更灵活。这里需要配套修改镜像，使用环境变量的方式将负载均衡IP替换docker的hosts文件中的私有IP，并在k8s的工作负载上配置环境变量。这个方法还存在一个缺点，相同负载均衡对应的相同服务注册到zookeeper上时，显示是完全相同的两条，无法区分。<br>方法三 升级dubbo到最新的2.6.4版本，该版本增加了对容器化的支持，它将注册IP、port与监听IP、port做了区分，向zookeeper注册时可以使用负载均衡的参数，docker服务本地监听仍然使用本地私有IP和port。</p><p>日志输出问题<br>配置中心问题<br><a href="https://blog.csdn.net/liu306487103/article/details/52221986" target="_blank" rel="noopener">https://blog.csdn.net/liu306487103/article/details/52221986</a><br><a href="https://www.kancloud.cn/good-rain/micro-services/248954" target="_blank" rel="noopener">https://www.kancloud.cn/good-rain/micro-services/248954</a><br><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D</a></p><p>VPC与子网<br>k8s<br>docker</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vmall微服务特点&quot;&gt;&lt;a href=&quot;#Vmall微服务特点&quot; class=&quot;headerlink&quot; title=&quot;Vmall微服务特点&quot;&gt;&lt;/a&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#54FF9F&quot;&gt;&lt;strong&gt;Vmall微服务特点&lt;/str
      
    
    </summary>
    
      <category term="容器化" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
      <category term="容器化" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Paxos</title>
    <link href="http://yoursite.com/2018/10/12/Paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/12/Paxos算法/</id>
    <published>2018-10-11T23:28:05.438Z</published>
    <updated>2018-11-01T15:24:52.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拜占庭将军问题"><a href="#1-拜占庭将军问题" class="headerlink" title="1. 拜占庭将军问题"></a>1. 拜占庭将军问题</h2><p>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。【百度百科】</p><p>拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。</p><p>拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。拜占庭容错协议必须处理这些失效，并且这些协议还要满足所要解决的问题要求的规范。这些算法通常以其弹性t作为特征，t表示算法可以应付的错误进程数。</p><p>因为存在错误进程，因此拜占庭将军问题只有在n ≥ 3t+1时才有解，其中n是系统中进程的总数。</p><h2 id="2-希腊议会制度"><a href="#2-希腊议会制度" class="headerlink" title="2. 希腊议会制度"></a>2. 希腊议会制度</h2><p>在古希腊一个叫Paxos的小岛，岛上采用议会的形式通过法令，议会中的议员通过信使进行消息的传递。议员和信使都是兼职的，他们随时可能会离开议会，并且信使可能会重复传递消息，也可能一去不复返。因此，议会协议要保证在这种情况下法令仍然能够正确的产生，并且不会出现冲突。</p><p>Paxos是一种为提高分布式系统容错的一致性算法，意在解决拜占庭将军问题。</p><h2 id="3-Paxos算法详解"><a href="#3-Paxos算法详解" class="headerlink" title="3. Paxos算法详解"></a>3. Paxos算法详解</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：</p><ul><li>在这些被提出的提案中，只有一个会被选定。</li><li>如果提案没有被提出，就不会有被选定的提案。</li><li>当一个提案被选定后，进程应该可以获取被选定的提案信息。</li></ul><p>一致性的安全需求有以下几点：</p><ul><li>只有被提出的提案才能被选定。</li><li>只能有一个值被选定。</li><li>如果某个进程认为某提案被选定了，那么这个提案必须是真的被选定的那个。</li></ul><h3 id="3-2-算法陈述"><a href="#3-2-算法陈述" class="headerlink" title="3.2 算法陈述"></a>3.2 算法陈述</h3><p>算法的推导过程比较复杂，这里不做解释。通过算法的推导，我们直接看结论。</p><ul><li><p><strong>算法的两阶段提交过程</strong><br><strong>阶段一</strong><br>  1）Proposer选择一个提案编号M，然后向Acceptor的某个超过半数的子集成员发送编号为M的Prepare请求。 </p><p>  2）Proposer选择一个提案编号为M的Prepare请求，且编号M大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M的提案。</p><p>  <strong>阶段二</strong><br>  1）如果Proposer收到来自半数以上的Acceptor对于其发出的编号为M的Prepare请求的响应，那么它就会发送一个针对[M,V]提案的Accept请求给Acceptor。注意，V的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。</p><p>  2）如果Acceptor收到这个针对[M,V]提案的Accept请求，只要该Acceptor尚未对编号大于M的Prepare请求作出响应，他就可以通过这个提案。</p></li><li><p><strong>算法的提案获取过程</strong><br>如何让Learner获取提案？</p><p>  <strong>方案一</strong><br>  Learner获取一个已经被选定的提案的前提是，该提案已经被半数以上的Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有Learner。</p><p>  这个方案需要让每个Acceptor与所有Learner逐个进行一次通信，通信次数至少为二者个数的乘积。</p><p>  <strong>方案二</strong><br>  所有的Acceptor将它们对提案的批准情况,统一发送给一个特定的Learner(主Learner)。主Learner负责通知其他Learner。</p><p>  这个方案的缺点是，主Learner故障时会出现问题。</p><p>  <strong>方案三</strong><br>  对方案二进行改进，主Learner是一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他Learner。</p></li></ul><ul><li><strong>如何保持算法的活性</strong><br>  为保证Paxos算法流程的可持续性，避免陷入死循环，必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这个主Proposer提出的最高编号的提案时会被通过。如果这个Proposer发现当前算法流程中已经有一个编号更大的天被提出或正在接受批准，那么它会丢弃当前编号较小的提案，并最终选出一个编号足够大的提案。</li></ul><p>Paxos引入了“少数服从多数”的概念，解决了单点故障、脑裂和无限期等待问题，并且支持分布式节点角色之间的轮换，是目前最优秀的分布式一致性算法之一。<br>目前，分布式锁服务Google Chubby，数据库Hypertable和zookeeper中都使用了Paxos来解决分布式一致性问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-拜占庭将军问题&quot;&gt;&lt;a href=&quot;#1-拜占庭将军问题&quot; class=&quot;headerlink&quot; title=&quot;1. 拜占庭将军问题&quot;&gt;&lt;/a&gt;1. 拜占庭将军问题&lt;/h2&gt;&lt;p&gt;拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分布式一致性算法" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="拜占庭将军问题，希腊议会制度" scheme="http://yoursite.com/tags/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B8%8C%E8%85%8A%E8%AE%AE%E4%BC%9A%E5%88%B6%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>BASE理论</title>
    <link href="http://yoursite.com/2018/10/11/BASE%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/10/11/BASE理论/</id>
    <published>2018-10-11T15:27:43.197Z</published>
    <updated>2018-10-14T05:37:42.776Z</updated>
    
    <content type="html"><![CDATA[<p>BASE理论是基本可用（Basically Available）、软状态（Soft state）、最终一致性（Eventually），是eBay架构师Dan Pritchett提出的。它是基于CAP理论发展而来，主要是针对大规模互联网系统分布式实践的总结。基本思想史即使无法做到强一致性，也要达到最终一致性。</p><ul><li>基本可用<br>系统在出现不可预知故障时，允许损失部分可用性，以保证整体可用性。比如损失响应时间换取最终结果，或是出现流量高峰时引导用户到降级页面。</li><li>弱状态<br>允许系统中的数据存在中间状态，而这种中间状态不会影响整体可用性。比如数据在不同系统节点间同步时存在延时的情况。</li><li>最终一致性<br>系统中所有数据副本，经过一段时间同步后，最终能达到一个一致状态。</li></ul><p>最终一致性的几种变种：</p><ul><li>因果一致性（Causal consistency）<br>进程A更新数据后通知进程B，则B访问该数据时，获取的都是被A更新后的数据。与A无因果关心的C访问数据时，则没有限制。</li><li>读己之所写（Read you write）<br>进程A更新一个数据项之后，它自己总能访问更新过的最新值，看不到旧值。</li><li>会话一致性（Session consistency）<br>将系统数据的访问过程限定在一个会话当中，保证同一个有效会话中实现“读己之所写”的一致性。</li><li>单调读一致性（Monotonic read consistency）<br>如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li><li>单调写一致性（Monotonic write consistency）<br>保证来自同一个进程的写操作被顺序地执行。</li></ul><p>想一想数据库的主从模式属于哪一种类型？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BASE理论是基本可用（Basically Available）、软状态（Soft state）、最终一致性（Eventually），是eBay架构师Dan Pritchett提出的。它是基于CAP理论发展而来，主要是针对大规模互联网系统分布式实践的总结。基本思想史即使无法
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分布式算法" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2PC与3PC</title>
    <link href="http://yoursite.com/2018/10/11/2PC%E5%92%8C3PC/"/>
    <id>http://yoursite.com/2018/10/11/2PC和3PC/</id>
    <published>2018-10-10T23:39:52.378Z</published>
    <updated>2018-11-01T15:17:48.414Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，当一个事务操作需要跨越多个分布式节点时，为了保证事务处理的ACID特性，需要引入一个“协调者”的组件来统一调度所有分布式节点的执行逻辑，被调度的分布式节点称为“参与者”。<br>协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。这个思想衍生出二阶段提交和三阶段提交两种协议。</p><h2 id="2PC（Two-Phase-Commit）"><a href="#2PC（Two-Phase-Commit）" class="headerlink" title="2PC（Two-Phase Commit）"></a>2PC（Two-Phase Commit）</h2><p>目的是为了保证分布式系统架构下所有节点在进行事务处理过程中能够保持原子性和一致性而设计的算法。绝大部分关系型数据库采用的都是二阶段提交协议来完成分布式事务的处理。</p><p><strong>协议说明</strong></p><ul><li>阶段一：提交事务请求<ol><li>事务询问。<br>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</li><li>执行事务。<br>各参与者执行事务操作，并将Undo和Redo信息记入事务日志中。</li><li>各参与者向协调者反馈事务询问的响应。<br>如果参与者成功执行了事务操作，则反馈给协调者Yes响应，表示事务可执行；否则就给协调者反馈NO响应，表示事务不可以执行。</li></ol></li></ul><p>这个阶段通常也称为“投票阶段”。</p><ul><li><p>阶段二：执行事务提交<br>协调者根据各参与者的反馈情况决定是否进行事务提交操作。包含两种可能：</p><p><strong>执行事务提交</strong><br>当所有参与者都反馈Yes响应时，协调者就会执行事务提交。执行过程如下</p><ol><li>发送提交请求<br>协调者向所有参与者发送Commit请求。</li><li>事务提交<br>参与者收到Commit请求后正式执行事务提交操作，在完成提交后释放整个事务执行期间占用的事务资源。</li><li>返回事务提交结果<br>向协调者发送Ack消息。</li><li>完成事务<br>协调者接收到所有参与者反馈的Ack消息后，完成事务。</li></ol><p><strong>中断事务</strong><br>当任何一个参与者向协调者反馈NO，或超时后协调者仍未收到某些参与者的响应，就会中断事务。</p><ol><li>发送事务回滚请求。<br>协调者向所有参与者发送Rollback请求。</li><li>事务回滚。<br>参与者接收到Rollback后，会利用其在阶段一种记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果。<br>参与者在完成事务回滚之后，向协调者发送Ack消息。</li><li><p>中断事务。<br>协调者收到所有参与者的Ack消息后，完成事务中断。</p><p><img src="https://i.imgur.com/uVAXMiZ.png" alt=""></p><p><img src="https://i.imgur.com/WYubkPJ.png" alt=""></p></li></ol></li></ul><p><strong>优缺点</strong><br>优点：原理简单，实现方便<br>缺点：同步阻塞、单点问题、脑裂、保守</p><ul><li><p>同步阻塞<br>提交的执行过程中，所以参与者都需要等待其他参与者的响应，无法执行其他任何操作。限制性能。这是最大的问题。</p></li><li><p>单点问题<br>协调者如果出现问题，整个系统提交流程将无法进行，如果恰好在阶段二故障，则参与者将一直锁定事务资源状态，无法继续工作。</p></li><li><p>数据不一致（脑裂）<br>阶段二时，若协调者已向参与者发送Commit，此时发生局部网络异常或协调者只发送了部分Commit后自身崩溃，则只有部分参与者接收到Commit请求。就会出现部分参与者提交，部分未提交，导致数据不一致现象。</p></li><li><p>保守<br>协调者指示参与者进行事务提交询问的过程中，参与值故障无法响应时，协调者只能通过超时判断是否中断。缺少一个完善的容错机制，任意一个节点失败都会导致整个事务的失败。</p></li></ul><p>2PC协议因为其阻塞的特性，在执行过程中需要锁住其他更新，且容错不够好，所以对其支持的成本较高。分布式系统用2PC协议更多的是处理多个数据分片操作的原子性。而同一个数据分片的多个副本之间的数据一致性则更多的使用Paxos来实现。</p><h2 id="3PC-Three-Phase-Commit"><a href="#3PC-Three-Phase-Commit" class="headerlink" title="3PC(Three-Phase Commit)"></a>3PC(Three-Phase Commit)</h2><p>三阶段提交协议，对二阶段提交协议的不足进行了改进。</p><p><strong>协议说明</strong></p><p>其将二阶段提交的“提交事务请求”过程一分为二，形成了由CanCommit、PreCommit、do Commit三个阶段组成的事务处理协议。<br><img src="https://i.imgur.com/oaKJeoh.png" alt=""></p><ul><li><p>阶段一：CanCommit</p><ol><li><p>事务询问<br>协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待参与者响应。</p></li><li><p>各参与者向协议者反馈事务询问响应<br>参与者受到canCommit请求后，正常情况下，如果认为可以执行事务，则返回Yes响应，并进入预备状态，否则反馈No响应。</p></li></ol></li><li><p>阶段二：PreCommit<br>两种可能的操作：</p><p><strong>执行事务预提交</strong><br>假如协调者收到所有的响应Yes，则会执行事务预提交。</p><ol><li>发送预提交请求<br>协调者向所有参与者发出preCommit请求，并进入Prepared阶段。</li><li>事务预提交<br>参与者收到preCommit后，执行事务操作，并将Undo和Redo信息记录到事务日志中。</li><li>各参与值向协调者反馈事务执行的响应<br>如果参与者执行了事务操作，就会给协调者反馈Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。</li></ol><p><strong>中断事务</strong><br>假如任何一个参与者反馈的是No响应，或者超时未响应，那么协调者就会中断事务。</p><ol><li>发送中断请求<br>协调者向所有参与者发送abort请求。</li><li>中断事务<br>无论收到来自协调者的abort请求，或是等待协调者请求过程中出现超时，参与者都会中断事务。</li></ol></li><li><p>阶段三：doCommit<br>进行真正的事务提交操作，存在两种情况：</p><p>  <strong>执行提交</strong></p><ol><li>发送提交请求<br>协调者收到所有响应者的Ack响应，他将从“预提交”状态转化到“提交”状态，并向所有参与者发送doCommit请求。</li><li>执行事务提交<br>参与者收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li>反馈事务提交结果<br>参与者在完成事务提交之后，向协调者发送Ack消息。</li><li>完成事务<br>协调者接收到所有参与者的Ack消息后，完成事务。</li></ol><p><strong>中断事务</strong><br>任意一个参与者反馈No响应，或协调者等待超时后，协调者就会中断事务。</p><ol><li>发送中断请求<br>协调者向所有参与者节点发送abort请求。</li><li>事务回滚<br>参与者接收到abort请求后利用在阶段二中的Undo信息来执行回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果<br>参与者完成事务回滚后，向协调者发送Ack消息。</li><li>中断事务<br>协调者接收到所有参与者反馈的Ack消息后，中断事务。</li></ol></li></ul><p>在阶段三中可能存在两种故障：</p><ul><li>协调者出现问题。</li><li>协调者和参与者之间的网络出现故障。</li></ul><p>无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或abort请求，针对这样的异常情况，参与者都会在等待超时后，继续进行事务提交。</p><p><strong>优缺点</strong><br>优点：解决了二阶段提交参与者无限期阻塞的问题，并且在出现单点故障后能继续达成一致。<br>缺点：在第三阶段，如果参与者没有接收到协调者发出的abort请求，那超时后依然会自动完成事务提交，必然出现一致性问题。另外，3PC增加了交互的次数，降低了性能。</p><p>3PC保证了CAP理论中的C和A，但是无法保证P——分区容错性，在实际操作中极少使用3PC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分布式系统中，当一个事务操作需要跨越多个分布式节点时，为了保证事务处理的ACID特性，需要引入一个“协调者”的组件来统一调度所有分布式节点的执行逻辑，被调度的分布式节点称为“参与者”。&lt;br&gt;协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。这个思
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分布式算法" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ACID理论</title>
    <link href="http://yoursite.com/2018/10/10/ACID/"/>
    <id>http://yoursite.com/2018/10/10/ACID/</id>
    <published>2018-10-09T23:38:41.033Z</published>
    <updated>2018-10-14T05:44:49.999Z</updated>
    
    <content type="html"><![CDATA[<p>ACID是事务的四个特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><ul><li>原子性（Atomicity）<br>事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态：全部执行成功、全部不执行。</li><li>一致性（Consistency）<br>事务的执行不能破坏数据的完整性和一致性。数据在所有应用、服务和数据库中的状态必须是一致的，并且是无缺失的。</li><li><p>隔离性（Isolation）<br>并发环境中，不同事务之间是隔离的，相互独立，无干扰。SQL规范中隔离性有4中级别：未授权读取、授权读取、可重复读取、串行化。<br><img src="https://i.imgur.com/CLMAV6s.png" alt=""></p></li><li><p>持久性（Durability）<br>事务一旦提交，其变更的数据的状态就会永久保存。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ACID是事务的四个特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）&lt;br&gt;事务必须是一个原子的操作序列单元。事务中包含的各项操
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分布式算法" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CAP理论</title>
    <link href="http://yoursite.com/2018/09/12/CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/09/12/CAP理论/</id>
    <published>2018-09-12T15:36:58.684Z</published>
    <updated>2018-10-14T05:37:50.622Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition rolerance）这三项基本需求，最多只能同时满足两种。</p><ul><li>一致性：分布式环境中，数据在多个副本间保持一致。数据在两个节点上存在副本，数据在一个节点上更新后，在另一个节点上能马上读取到新的值（强一致性或严格一致性）。</li><li>可用性：对于用户的操作，总能在有限时间内返回结果。</li><li>分区容错性：分布式系统在遇到任何网络分区发生故障时，仍然能保证对外提供满足一致性和可用性的服务，除非是整个网络故障。</li></ul><p><strong>CAP理论示意图</strong><br><img src="https://i.imgur.com/Hujjfja.png" alt=""></p><p><strong>CAP理论应用</strong><br><img src="https://i.imgur.com/3wlzQjE.png" alt=""></p><p>既然是分布式系统，肯定是能满足分区容错性的，特别是现在的微服务系统。所以设计师往往会在一致性（Consistency）和可用性（Availability）之间抉择。</p><p><em>参考《从PAXOS到ZOOKEEPER分布式一致性原理与实践》</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition rolerance）这三项基本需求，最多只能同时满足两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性：分布式环境中，数据在多个副本间保持一致。数据在两个节点
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分布式算法" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://yoursite.com/2018/09/12/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/09/12/索引分类/</id>
    <published>2018-09-11T16:03:58.217Z</published>
    <updated>2018-10-14T05:38:49.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul><li>按照字段个数划分：单列索引、组合索引</li><li>按照唯一性划分：普通索引、唯一索引</li><li>MyISAM特殊索引：全文索引（char、varchar、text类型的列，不支持多列，用于全文搜索）、空间索引（非空字段）</li></ul><h2 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h2><p>方法一：创建表时创建</p><pre><code>CREATE TABLE &lt;table_name&gt; [col_name data_type][UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length],...)[ASC|DESC]</code></pre><ul><li>UNIQUE|FULLTEXT|SPATIAL 均为可选，分别表示唯一索引、全文索引、空间索引。</li><li>INDEX|KEY 含义相同均指创建索引。</li><li>index_name为索引名，不指定时与列名相同。</li><li>col_name要创建索引的列名。</li><li>length可选，表示索引长度，只有字符串类型的字段才可以指定。</li><li>ASC|DESC可选，表示升序还是降序。</li></ul><p>方法二：已存在的表上创建索引</p><pre><code>ALTER TABLE &lt;table_name&gt; ADD [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length],...)[ASC|DESC]CREATE [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name] ON &lt;table_name&gt;(col_name[length],...)[ASC|DESC]</code></pre><h2 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h2><p>方法一：ALTER语句删除</p><pre><code>ALTER TABLE DROP INDEX &lt;index_name&gt;</code></pre><p>方法二：DROP语句删除</p><pre><code>DROP INDEX &lt;index_name&gt; ON &lt;table_name&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引分类&quot;&gt;&lt;a href=&quot;#索引分类&quot; class=&quot;headerlink&quot; title=&quot;索引分类&quot;&gt;&lt;/a&gt;索引分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按照字段个数划分：单列索引、组合索引&lt;/li&gt;
&lt;li&gt;按照唯一性划分：普通索引、唯一索引&lt;/li&gt;
&lt;li&gt;M
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql基础" scheme="http://yoursite.com/tags/mysql%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SQL性能优化一——减少数据库交互次数</title>
    <link href="http://yoursite.com/2018/09/12/SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80%E2%80%94%E2%80%94%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2018/09/12/SQL性能优化一——减少数据库交互次数/</id>
    <published>2018-09-11T16:00:27.655Z</published>
    <updated>2018-10-14T05:38:26.775Z</updated>
    
    <content type="html"><![CDATA[<p>把多条SQL语句合并为一条，可减少数据库交互次数，提高性能，这是一种简单的优化改进。</p><p><strong>创建表t_user</strong></p><pre><code>CREATE TABLE `t_user` (　　`id` tinyint(10) UNSIGNED AUTO_INCREMENT NOT NULL,　　`name` varchar(255) DEFAULT NULL,　　`age` int(10) DEFAULT NULL,　　`updatetime` datetime DEFAULT NULL,　　INDEX index_name(name),) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><h2 id="1-整合DDL语句"><a href="#1-整合DDL语句" class="headerlink" title="1 整合DDL语句"></a>1 整合DDL语句</h2><p>多条的写法：</p><pre><code>ALTER table t_user ADD COLUMN uid TINYINT UNSIGNED;ALTER table t_user ADD UNIQUE INDEX (uid); ALTER table t_user DROP INDEX index_name, ADD INDEX index_name_age (name, age);ALTER TABLE t_user ADD PRIMARY KEY (id);</code></pre><p>合并为一条：</p><pre><code>ALTER TABLE t_user ADD COLUMN uid TINYINT UNSIGNED,　ADD UNIQUE INDEX (uid),　DROP INDEX index_name,　ADD INDEX index_name_age (NAME, age),　ADD PRIMARY KEY (id);</code></pre><h2 id="2-整合DML语句"><a href="#2-整合DML语句" class="headerlink" title="2 整合DML语句"></a>2 整合DML语句</h2><h3 id="2-1-INSERT的整合"><a href="#2-1-INSERT的整合" class="headerlink" title="2.1 INSERT的整合"></a>2.1 INSERT的整合</h3><pre><code>INSERT INTO &lt; table_name &gt; (　　　　columnname1,　　　　columnname2 ,...)VALUES(    　　columnvalue1,    　　columnvalue2 ,...) ,    ..., (        columnvalue1,        columnvalue2 ,...);</code></pre><p><strong>整合前：</strong></p><pre><code>INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200);INSERT INTO t_user (id, name, age) VALUES  (2, &apos;张无忌&apos;, 50) ;</code></pre><p><strong>整合后</strong></p><pre><code>INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200), (2, &apos;张无忌&apos;, 50) ;</code></pre><h3 id="2-2-UPDATE的整合"><a href="#2-2-UPDATE的整合" class="headerlink" title="2.2 UPDATE的整合"></a>2.2 UPDATE的整合</h3><p>在更新目标一致的情况下可使用下面语句整合。</p><pre><code>UPDATE &lt;table_name&gt; set &lt;columnname&gt;=&lt;columnvalue&gt;, ... where &lt;columnnamen&gt; in (value1, value2,...);</code></pre><h3 id="2-3-INSERT和UPDATE的整合"><a href="#2-3-INSERT和UPDATE的整合" class="headerlink" title="2.3 INSERT和UPDATE的整合"></a>2.3 INSERT和UPDATE的整合</h3><p>当在满足条件时，可合并：先检查要插入的主键是否存在，如果不存在就插入行，如果存在就执行update操作。</p><pre><code>INSERT ... ON DUPLICATE KEY UPDATE</code></pre><p>举例： id是主键，当不存在id=1的数据是，插入一行；若存在，则将id=1的那行数据的age更新为201。</p><pre><code>INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200) ON DUPLICATE KEY UPDATE age = 201;</code></pre><p>注意：该语句存在死锁风险，请在满足以下两条件时使用（1、尽量不对存在多个唯一键的table使用该语句；2、在有可能有并发事务执行的insert 的内容一样情况下不使用该语句）<a href="https://blog.csdn.net/pml18710973036/article/details/78452688" target="_blank" rel="noopener">bug</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把多条SQL语句合并为一条，可减少数据库交互次数，提高性能，这是一种简单的优化改进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建表t_user&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `t_user` (
　　`id` tinyint(10) UN
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql性能优化" scheme="http://yoursite.com/tags/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL唯一性约束</title>
    <link href="http://yoursite.com/2018/09/11/MySQL%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2018/09/11/MySQL唯一性约束/</id>
    <published>2018-09-11T15:50:38.572Z</published>
    <updated>2018-10-14T05:38:14.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>一个表只能存在一个，且不允许空值 </p><ul><li>定义列时指定：</li></ul><p>　　<code>&lt;col_name&gt; &lt;data_type&gt; PRIMARY KEY [DEFAULT &lt;value&gt;]</code> </p><ul><li>定义完列后指定：</li></ul><p>　　<code>[CONSTANT&lt;key_name&gt;] PRIMARY KEY(&lt;col_name1&gt;,...)</code></p><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><p>一个表允许有多个，且允许列上存在一个空值   </p><ul><li><p>定义列时指定：</p><p>  <code>&lt;col_name&gt; &lt;data_type&gt; UNIQUE</code></p></li><li><p>定义完列后指定：</p></li></ul><p>　　<code>[CONSTANT&lt;key_name&gt;] UNIQUE(&lt;col_name1&gt;,...)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主键&quot;&gt;&lt;a href=&quot;#主键&quot; class=&quot;headerlink&quot; title=&quot;主键&quot;&gt;&lt;/a&gt;主键&lt;/h2&gt;&lt;p&gt;一个表只能存在一个，且不允许空值 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义列时指定：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;code&gt;&amp;lt;col_n
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql基础" scheme="http://yoursite.com/tags/mysql%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>AUTO_INCREMENT</title>
    <link href="http://yoursite.com/2018/09/11/AUTO_INCREMENT/"/>
    <id>http://yoursite.com/2018/09/11/AUTO_INCREMENT/</id>
    <published>2018-09-11T15:44:32.540Z</published>
    <updated>2018-10-14T05:37:36.910Z</updated>
    
    <content type="html"><![CDATA[<p>一个表只能有一个字段使用自增约束，且字段必须是主键的一部分。其约束的字段可以是任何整型类型（TINYINT、INT、SMALLIN、BIGINT）。默认从1开始，每增加一行自动加1。</p><p>设置语法：</p><pre><code>&lt;col_name&gt; &lt;data_type&gt; AUTO_INCREMENT</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个表只能有一个字段使用自增约束，且字段必须是主键的一部分。其约束的字段可以是任何整型类型（TINYINT、INT、SMALLIN、BIGINT）。默认从1开始，每增加一行自动加1。&lt;/p&gt;
&lt;p&gt;设置语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;col_name&amp;gt; 
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql基础" scheme="http://yoursite.com/tags/mysql%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>电商库存</title>
    <link href="http://yoursite.com/2018/09/11/%E5%BA%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/09/11/库存/</id>
    <published>2018-09-11T15:18:19.975Z</published>
    <updated>2018-10-14T05:38:41.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　库存是一个复杂度很高的核心系统，提供前端实时查询的能力和后端的商品扣减，还要处理订单取消问题。这对库存系统的准确性和可靠性提出了很高的要求，在各种场景下能保证数据的准确，在遇到突发流量时能保证高可用，除此之外，还需要提供熔断和降级的能力，保证在极端情况下不拖垮主站。</p><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p><img src="https://i.imgur.com/B9MdgH1.gif" alt=""></p><ul><li>DUBBO是一款非常优秀的 RPC 层框架，提供高性能和透明化的RPC远程服务调用方案,以及SOA服务治理方案。</li><li>RocketMQ是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。</li><li>Redisson是架设在Redis基础上的一个Java驻内存数据网格。</li><li>Redis单线程的高速缓存数据库，支持持久化、事务，通过哨兵和自动分区提供高可用。</li><li>Druid阿里的开源软件，专为监控而生的数据库连接池。</li><li>Mybatis是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</li><li>MySQL关系型数据库系统。</li></ul><h2 id="库存扣减"><a href="#库存扣减" class="headerlink" title="库存扣减"></a>库存扣减</h2><p>　　为简化库存系统，库存系统之上建立交易系统和订单管理系统，库存只负责管理商品扣减。</p><h3 id="1-何时扣减"><a href="#1-何时扣减" class="headerlink" title="1. 何时扣减"></a>1. 何时扣减</h3><p>　　库存扣减一般有三个时机：</p><ul><li>加购物车时扣减。商品加入购物车，并不能说明用户确实要购买，实际转化率并不高，假如此时扣库存，会导致库存被占用而无法释放，影响正常销售。</li><li>提交订单时扣减。用户下单后还有一个支付操作，如果用户仅仅下单而不进行支付，这部分库存将会被无效占用，影响正常销售。这里可以做一个支付时限，如果超过时限未支付，订单将被取消，预占得库存被返还。</li><li>支付时扣减。用户进行支付，说明交易即将完成，这部分是必须要留住的订单和用户，如果此时扣库存，出现库存不足导致用户支付失败会严重影响用户体验。</li></ul><p>　　目前为提高库存效率和用户体验，系统采用提交订单扣库存的策略。这也是大部分电商平台采用的扣减策略。</p><h3 id="2-如何扣减"><a href="#2-如何扣减" class="headerlink" title="2. 如何扣减"></a>2. 如何扣减</h3><p>　　库存扣减需要应对主要问题是高并发问题、重复扣减问题（超卖）。　　<br>　　上游系统需要配合库存系统做好扩容、限流保护、隔离（业务隔离、数据隔离，以及系统隔离）、动静分离、localCache等措施，通过漏斗模型逐层减少用户流量，避免流量高峰对库存系统的冲击，必要时采用熔断进行降级（比如查询库存时直接返回有库存）。<br>　　系统采用Redission+Redis解决高并发问题，Redis是内存数据库性能相对较高，本身支持事务操作,使用Redisson的Rbatch保证事务性，扣减操作包含query和done，两个动作属于一个事务，且done操作保证幂等。<br>　  重复扣刷减最常出现的包括用户误操作、黄牛绕过前端进行单、交易系统重试操作：  </p><ul><li>用户误操作，前端购物车在用户提交订单后将购物车数据删除，无法继续提交。</li><li>黄牛绕过前段刷单，前端必须经过交易系统通过RPC调用库存系统，在交易系统中通过风控、调用次数限制、订单令牌等方法限制重复提交订单。</li><li>交易系统重试问题，库存系统通过限制一个订单只能进行一次事务性的库存扣减操作，防止交易系统重试导致的饭后服扣减。<br>　　还有重要的一点是记录库存扣减日志，在库存回滚时使用。</li></ul><h3 id="3-如何回滚"><a href="#3-如何回滚" class="headerlink" title="3. 如何回滚"></a>3. 如何回滚</h3><p>　　用户取消订单、用户退货、异常订单流程都会触发库存回滚操作。<br>　　为每一个订单设定一个唯一编号，并且按照编号记录库存操作流日志，在需要做库存回滚时依据唯一编号进行库存的返还，回滚操作需要根据编号保证事务性和幂等性。<br>　　库存的返还采用同步回滚+异步重试机制，用户取消订单和异常订单的回滚操作首先进行订单的同步逆向操作，在库存返还时如果失败，将唯一编号记录下来，通过异步定时任务进行返还。<br>　　用户退货往往涉及到实物商品的退库，因此发起方是订单管理系统，当实物商品完成退库后，订单管理系统将发送MQ消息，库存系统通过订阅消息进行库存返还。<br>　　尽管同步回滚+异步重试已经足够保证库存的正确回滚，但是为万无一失，还需要增加一个数据健康度的自我检查能力，超时超次未完成回滚的库存数据需要人工干预。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h3><p>　　由于Redis的读写能力远胜于任何关系型数据库，因此在Redis中保存商品库存数据并完成扣减操作。<br>　　使用Redis的以下特性保证库存系统的高并发和高可用：</p><ul><li>分库分表，因垂直电商业务特点且主站秒杀和抢购并不在主站中，因此为简化逻辑按照SKU维度采用HASH算法进行分库的策略。当然在极端情况下可以对每个SKU继续进行库存拆分，拆分成二级SKU，目前秒杀业务就是采用这种策略。</li><li>读写分离，采用Master/Slave模式，其中Master提供写操作，Slave提供读操作，降低Master的压力，提供高速读写操作。</li><li>主从+哨兵模式，为保证Redis的可靠性，启用Redis的主从模式和哨兵模式。部署Sentinel集群+Master/Slave集群，实现Master故障的自动发现和切换。</li><li>持久化，启用AOF实时持久化功能，保障数据的秒级备份。</li></ul><h3 id="2-MySQL"><a href="#2-MySQL" class="headerlink" title="2.MySQL"></a>2.MySQL</h3><p>　　用于记录操作日志和扣减日志。<br>　　为提高读写性能采用主从模式和读写分离模式，最初MySQL还承担着库存数据的批量落盘功能，随着Redis库存方式的长时间稳定运行，库存逐渐完全转移到Redis上，MySQL仅仅承担着记录操作日志和扣减日志的功能。</p><p><a href="http://www.iteye.com/news/32768" target="_blank" rel="noopener">http://www.iteye.com/news/32768</a><br><a href="https://mp.weixin.qq.com/s/aIzdMG1y0a5cWOS4lx6IuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aIzdMG1y0a5cWOS4lx6IuQ</a><br><a href="https://www.cnblogs.com/liuchuanfeng/p/7190654.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuchuanfeng/p/7190654.html</a><br>Redis开发与运维</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;　　库存是一个复杂度很高的核心系统，提供前端实时查询的能力和后端的商品扣减，还要处理订单取消问题。这对库存系统的准确性和可靠性提出了很高的要
      
    
    </summary>
    
      <category term="电商" scheme="http://yoursite.com/categories/%E7%94%B5%E5%95%86/"/>
    
    
      <category term="库存管理，电商架构" scheme="http://yoursite.com/tags/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%8C%E7%94%B5%E5%95%86%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线程上下文类加载器的初始化</title>
    <link href="http://yoursite.com/2018/09/11/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/09/11/线程上下文类加载器的初始化/</id>
    <published>2018-09-11T15:17:59.437Z</published>
    <updated>2018-10-14T05:52:31.055Z</updated>
    
    <content type="html"><![CDATA[<p>　　线程上线文类加载器是JVM类加载模型中的一个特殊存在，在使用时，只需要执行Thread.currentThread().getContextClassLoader()就可以获取线程上线文类加载器，即当前线程的类加载器。但是这个类加载器是什么时候设置的呢？ 我们执行下面代码</p><pre><code>public static void main(String[] args) throws ClassNotFoundException,        SQLException{    System.out.println(Thread.currentThread().getContextClassLoader());}</code></pre><p>　　输出结果是</p><pre><code>sun.misc.Launcher$AppClassLoader@c387f44</code></pre><p>　　即使用的是AppClassLoader类加载器，但是这个上下文中的加载器是什么时候设置进去的？<br>　　我们都知道，在调用类的静态方法时，类及其父类都会被初始化，初始化过程中最重要的部分就是执行类中的静态代码块、及初始化成员变量。但Thread的静态代码块中只是注册了一个本地方法而已。</p><pre><code>static {    registerNatives();}</code></pre><p>　　我们看看Thread对象被初始化时做了什么？</p><pre><code>public Thread() {    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);}private void init(ThreadGroup g, Runnable target, String name,                  long stackSize) {    init(g, target, name, stackSize, null);}private void init(ThreadGroup g, Runnable target, String name,                  long stackSize, AccessControlContext acc) {    if (name == null) {        throw new NullPointerException(&quot;name cannot be null&quot;);    }    this.name = name.toCharArray();    Thread parent = currentThread();    SecurityManager security = System.getSecurityManager();    if (g == null) {        /* Determine if it&apos;s an applet or not */        /* If there is a security manager, ask the security manager           what to do. */        if (security != null) {            g = security.getThreadGroup();        }        /* If the security doesn&apos;t have a strong opinion of the matter           use the parent thread group. */        if (g == null) {            g = parent.getThreadGroup();        }    }    /* checkAccess regardless of whether or not threadgroup is       explicitly passed in. */    g.checkAccess();    /*     * Do we have the required permissions?     */    if (security != null) {        if (isCCLOverridden(getClass())) {            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);        }    }    g.addUnstarted();    this.group = g;    this.daemon = parent.isDaemon();    this.priority = parent.getPriority();    // 这里在做线程上下文类加载器的赋值操作，如果系统没有设置安全管理器，则会调用Thread的getContextClassLoader()方法获取类加载器。而parent是currentThread()即启动本线程的线程。把父线程的上下文类加载器给继承过来。这里的父子关系是指谁启动谁的关系，比如在线程A里面启动了线程B，那B线程的父线程就是A。    if (security == null || isCCLOverridden(parent.getClass()))        this.contextClassLoader = parent.getContextClassLoader();    else        this.contextClassLoader = parent.contextClassLoader;    this.inheritedAccessControlContext =            acc != null ? acc : AccessController.getContext();    this.target = target;    setPriority(priority);    if (parent.inheritableThreadLocals != null)        this.inheritableThreadLocals =            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);    /* Stash the specified stack size in case the VM cares */    this.stackSize = stackSize;    /* Set thread ID */    tid = nextThreadID();}@CallerSensitivepublic ClassLoader getContextClassLoader() {    if (contextClassLoader == null)        return null;    SecurityManager sm = System.getSecurityManager();    if (sm != null) {        ClassLoader.checkClassLoaderPermission(contextClassLoader,                                               Reflection.getCallerClass());    }    return contextClassLoader;}</code></pre><p>第一个被启动的线程是哪个？那第一个启动的线程（包含main方法的那个线程）里面的contextClassLoader是谁设置的呢？不要忘记，Main本身就启动了一个线程。<br>这要看 sun.misc.Launcher 这个类的源码。Launcher是JRE中用于启动程序入口main()的类。</p><pre><code>loader = AppClassLoader.getAppClassLoader(extcl);Thread.currentThread().setContextClassLoader(loader);</code></pre><p>这里截取的两行代码出自 Launcher 的构造方法。第一行用一个扩展类加载器extcl构造了一个系统类加载器loader，第二行把loader设置为当前线程（包含main方法）的类加载器。所以，我们启动一个线程的时候，如果之前都没有调用 setContextClassLoader 方法明确指定的话，默认的就是系统类加载器。</p><p>参考<br><a href="https://www.cnblogs.com/cz123/p/6867345.html" target="_blank" rel="noopener">https://www.cnblogs.com/cz123/p/6867345.html</a><br><a href="https://blog.csdn.net/gabele/article/details/71250108" target="_blank" rel="noopener">https://blog.csdn.net/gabele/article/details/71250108</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　线程上线文类加载器是JVM类加载模型中的一个特殊存在，在使用时，只需要执行Thread.currentThread().getContextClassLoader()就可以获取线程上线文类加载器，即当前线程的类加载器。但是这个类加载器是什么时候设置的呢？ 我们执行下面代
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="类加载" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://yoursite.com/2018/09/07/CAS/"/>
    <id>http://yoursite.com/2018/09/07/CAS/</id>
    <published>2018-09-06T23:37:51.865Z</published>
    <updated>2018-10-14T05:37:56.412Z</updated>
    
    <content type="html"><![CDATA[<p>　　CAS保证了并发时，操作和冲突检查的原子性。<br>　　CAS最初用到硬件指令上，是一条硬件指令，包括3个操作数：内存位置（地址）用V表示、旧的预期值用A表示、新值用B表示，在执行时，仅当V符合旧的预期值A时，处理器才会用新值B更新V的值，否则不执行更新，但无论是否更新了V，都会返回V的旧值，这个过程是一个原子操作。<br>　　jdk1.5后，java开始使用CAS操作，该操作由sun.misc.Unsafe类中的compareAndSweepInt()和compareAndSweepLong()等几个方法包装提供。在虚拟机即时编译出的结果就是一条平台相关的CAS指令，没有JAVA方法的调用过程。（即过程是原子性的）。这个功能在JDK1.8又做了增强，重试的过程也是在机器的指令集上执行的。<br>　　CAS的ABA问题，如果V的初始值是A，在第一次读取时也是A，但是在读取后——赋值前这期间V被改为B，然后又被改回到A，此时，CAS操作会认为V没有被改变过。这个就是著名的ABA问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　CAS保证了并发时，操作和冲突检查的原子性。&lt;br&gt;　　CAS最初用到硬件指令上，是一条硬件指令，包括3个操作数：内存位置（地址）用V表示、旧的预期值用A表示、新值用B表示，在执行时，仅当V符合旧的预期值A时，处理器才会用新值B更新V的值，否则不执行更新，但无论是否更新
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="并发理论" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>mysql驱动的类加载过程</title>
    <link href="http://yoursite.com/2018/09/03/JDBC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/03/JDBC类加载过程分析/</id>
    <published>2018-09-03T14:05:09.918Z</published>
    <updated>2018-10-14T05:38:05.701Z</updated>
    
    <content type="html"><![CDATA[<p>　　JDBC是开发中常用的驱动程序，但一直没有深入了解过其加载过程。JDBC驱动的加载也是线程上下文类加载器使用的经典案例。最近有时间研究一下源码，结合JVM线程上下文类加载器的知识做个总结。</p><pre><code>public static void main(String[] args) throws ClassNotFoundException,        SQLException{    // 加载mysql驱动    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);    Connection connection = DriverManager.getConnection(            &quot;jdbc://localhost:3306/mysql&quot;, &quot;username&quot;, &quot;password&quot;);}</code></pre><p>#1. Class.forName完成JDBC驱动的加载，底层是如何实现的？ #<br>    @CallerSensitive<br>    public static Class&lt;?&gt; forName(String className)<br>                throws ClassNotFoundException {<br>        Class&lt;?&gt; caller = Reflection.getCallerClass();<br>        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);<br>    }</p><p>　　forName继续调用forName0方法，但是forName0方法是个Native方法，看不到源码了，如下：</p><pre><code>/** Called after security check for system loader access checks have been made. */private static native Class&lt;?&gt; forName0(String name, boolean initialize,                                        ClassLoader loader,                                        Class&lt;?&gt; caller)    throws ClassNotFoundException;</code></pre><p>　　通过查询oracle的技术文档，这个方法返回的是一个由字符串className相同类限定名的Class对象<br>“Returns the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to:<br>　　<code>Class.forName(className, true, currentLoader)</code><br>where currentLoader denotes the defining class loader of the current class.”</p><p>　　再来看Class.forName(className, true, currentLoader)方法的技术文档，如下：</p><p>“Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.</p><p>If name denotes an array class, the component type of the array class is loaded but not initialized.<br>For example, in an instance method the expression:<br>    <code>Class.forName(&quot;Foo&quot;)</code><br>is equivalent to:<br><code>Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())</code>”。</p><p>　　forName方法返回的是一个指定全限定类（接口）名的对象，使用的是指定的类加载器进行加载，如果指定的类加载器为空并且initialize传入true，则使用bootstrapClassLoader进行加载。同时，如果加载器中没有该类的初始化信息，则会对类（接口）进行初始化。<br>　　这里就是类（接口）的初始化过程，将字节码信息转化成方法区（元数据区）的数据，并返回一个Class对象到堆内存中，作为调用的入口。</p><p>　　因为我们传入的是<code>com.mysql.cj.jdbc.Driver</code>，因此这个过程就是类<code>Driver</code>被初始化的过程。JVM虚拟机在类初始化过程中最重要的两个动作就是初始化本类和父类的成员变量和执行静态代码块。我们来看看<code>Driver</code>类中的成员变量和静态代码块，如下：</p><pre><code>public class Driver extends com.mysql.cj.jdbc.Driver {    public Driver() throws SQLException {        super();    }    static {        System.err.println(&quot;Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. &quot;                + &quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;);    }}</code></pre><p>代码中static块中只是打印了一个日志，没有其他动作。类加载时如果还会加载父类的信息，来看看<code>com.mysql.cj.jdbc.Driver</code>中是否有静态代码块。</p><pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {    //    // Register ourselves with the DriverManager    //    static {        try {            // 实际加载的驱动，这里调用了DriverManager的静态方法，会触发该类的初始化动作            java.sql.DriverManager.registerDriver(new Driver());        } catch (SQLException E) {            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);        }    }    /**     * Construct a new driver and register it with DriverManager     *      * @throws SQLException     *             if a database error occurs.     */    public Driver() throws SQLException {        // Required for Class.forName().newInstance()    }}</code></pre><p>代码中看到<code>com.mysql.cj.jdbc.Driver</code>中静态块执行了这段代码<code>java.sql.DriverManager.registerDriver(new Driver())</code>，实际上是将自己作为参数传递给了jdk的<code>DriverManager.registerDriver</code>方法，而这个方法是将MySQL的Drive对象包装成jdk的DriverInfo对象后保存到成员变量DriverManager.registeredDrivers的数组中（如果已经存在就什么都不做）。<br>　　我们还遗漏了什么？<br>　　<code>com.mysql.cj.jdbc.Driver</code>还继承了<code>NonRegisteringDriver</code>，在Driver初始化前会先初始化<code>NonRegisteringDriver</code>中的静态成员变量和代码块，来看下代码：</p><pre><code>static {    try {        Class.forName(AbandonedConnectionCleanupThread.class.getName());    } catch (ClassNotFoundException e) {        // ignore    }}</code></pre><p>　　这里又加载了一个类AbandonedConnectionCleanupThread，这个类什么作用呢？ 再来看一下他的代码：</p><pre><code>/**This class implements a thread that is responsible for closing abandoned MySQL connections, i.e., connections that are not explicitly closed.There is only one instance of this class and there is a single thread to do this task. This thread&apos;s executor is statically referenced in this same class.**/public class AbandonedConnectionCleanupThread implements Runnable {    private static final ExecutorService cleanupThreadExcecutorService;    static Thread threadRef = null;    static {        cleanupThreadExcecutorService = Executors.newSingleThreadExecutor(new ThreadFactory() {            public Thread newThread(Runnable r) {                Thread t = new Thread(r, &quot;Abandoned connection cleanup thread&quot;);                t.setDaemon(true);                // Tie the thread&apos;s context ClassLoader to the ClassLoader that loaded the class instead of inheriting the context ClassLoader from the current                // thread, which would happen by default.                // Application servers may use this information if they attempt to shutdown this thread. By leaving the default context ClassLoader this thread                // could end up being shut down even when it is shared by other applications and, being it statically initialized, thus, never restarted again.                t.setContextClassLoader(AbandonedConnectionCleanupThread.class.getClassLoader());                return threadRef = t;            }        });        cleanupThreadExcecutorService.execute(new AbandonedConnectionCleanupThread());    }    ....}</code></pre><p>　　很明显，这里启动了一个守护线程，这个线程用来关闭没有被正确关闭的MySQL链接。</p><h1 id="2-DriverManager-getConnection做了什么事情？"><a href="#2-DriverManager-getConnection做了什么事情？" class="headerlink" title="2.DriverManager.getConnection做了什么事情？"></a>2.DriverManager.getConnection做了什么事情？</h1><p>　　继续看一下文章开头的第二行代码<code>DriverManager.getConnection()</code>做了什么。</p><pre><code>@CallerSensitivepublic static Connection getConnection(String url,    String user, String password) throws SQLException {    java.util.Properties info = new java.util.Properties();    if (user != null) {        info.put(&quot;user&quot;, user);    }    if (password != null) {        info.put(&quot;password&quot;, password);    }    return (getConnection(url, info, Reflection.getCallerClass()));}</code></pre><p>　　将mysql的用户名密码设置到Properties中，连同url、调用类（Reflection.getCallerClass获取）传递给getConnection方法，重点来了：</p><pre><code>//  Worker method called by the public getConnection() methods.private static Connection getConnection(    String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {    /*     *  当传入的caller不为空时，使用传入对象的类加载器，否则就进入到同步块中获取当前线程的上下文中的类加载器。而这类传入的caller不为空，是在DriverManager中调用了Reflection.getCallerClass()获取了DriverManager的Class,因此这里的ClassLoader应该是BootstrapClassLoader，然而系统类加载器是不能被程序获取的（JVM虚拟机限制）。所以callerCL获取了线程上下文类加载器，这里使用了currentThread()，实际上是获取了main方法的类加载器即appClassLoader。     */    ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;    synchronized(DriverManager.class) {        // synchronize loading of the correct classloader.        if (callerCL == null) {            callerCL = Thread.currentThread().getContextClassLoader();        }    }    if(url == null) {        throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);    }    println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);    // Walk through the loaded registeredDrivers attempting to make a connection.    // Remember the first exception that gets raised so we can reraise it.    SQLException reason = null;    //轮训成员变量registeredDrivers中的DriverInfo,并创建连接。如果创建连接发生异常则将最近一次异常记录下来，后面会打日志并抛出这个异常。    for(DriverInfo aDriver : registeredDrivers) {        // If the caller does not have permission to load the driver then        // skip it.        if(isDriverAllowed(aDriver.driver, callerCL)) {            try {                println(&quot;    trying &quot; + aDriver.driver.getClass().getName());                Connection con = aDriver.driver.connect(url, info);                if (con != null) {                    // Success!                    println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());                    return (con);                }            } catch (SQLException ex) {                if (reason == null) {                    reason = ex;                }            }        } else {            println(&quot;    skipping: &quot; + aDriver.getClass().getName());        }    }    // if we got here nobody could connect.    if (reason != null)    {        println(&quot;getConnection failed: &quot; + reason);        throw reason;    }    println(&quot;getConnection: no suitable driver found for &quot;+ url);    throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);}</code></pre><p>　　还有一个重要的点被我们忽略了！初始化一个对象、调用类的静态方法、读取或者设置一个类的静态变量、使用反射调用一个类、子类被初始化。了解了这些，我们再来看DriverManager.getConnection是不是调用了DriverManager的静态方法？是不是触发了DriverManager的初始化过程？ 这里执行了静态代码块：</p><pre><code>/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */static {    loadInitialDrivers();    println(&quot;JDBC DriverManager initialized&quot;);}</code></pre><p>　　继续看loadInitialDrivers方法干了什么？</p><pre><code>private static void loadInitialDrivers() {    String drivers;    try {        // 通过权限控制器获取系统配置jdbc.drivers，这里我们没有设置系统，因此这里返回空        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {            public String run() {                return System.getProperty(&quot;jdbc.drivers&quot;);            }        });    } catch (Exception ex) {        drivers = null;    }    // If the driver is packaged as a Service Provider, load it.    // Get all the drivers through the classloader    // exposed as a java.sql.Driver.class service.    // ServiceLoader.load() replaces the sun.misc.Providers()    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {        public Void run() {            // 重点在这里            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); //记住这里，后面会用到            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();            /* Load these drivers, so that they can be instantiated.             * It may be the case that the driver class may not be there             * i.e. there may be a packaged driver with the service class             * as implementation of java.sql.Driver but the actual class             * may be missing. In that case a java.util.ServiceConfigurationError             * will be thrown at runtime by the VM trying to locate             * and load the service.             *             * Adding a try catch block to catch those runtime errors             * if driver not available in classpath but it&apos;s             * packaged as service and that service is there in classpath.             */            try{                while(driversIterator.hasNext()) {                    driversIterator.next();                }            } catch(Throwable t) {            // Do nothing            }            return null;        }    });    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);    if (drivers == null || drivers.equals(&quot;&quot;)) {        return;    }    String[] driversList = drivers.split(&quot;:&quot;);    println(&quot;number of Drivers:&quot; + driversList.length);    for (String aDriver : driversList) {        try {            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);            Class.forName(aDriver, true,                    ClassLoader.getSystemClassLoader());        } catch (Exception ex) {            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);        }    }}</code></pre><p>　　上面这段代码因为drivers变量值为空，所以实际起作用的是中间的代码块。先来看代码<code>ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class)</code>传入的参数是<code>java.sql.Driver.class</code>，这里面做了什么：</p><pre><code>/** * Creates a new service loader for the given service type, using the * current thread&apos;s {@linkplain java.lang.Thread#getContextClassLoader * context class loader}. */public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {    ClassLoader cl = Thread.currentThread().getContextClassLoader();    return ServiceLoader.load(service, cl);}</code></pre><p>　　注释写的很清楚，返回一个server loader，使用的是线程上下文类加载器,currentThread()即当前main线程的类加载器。继续到<code>ServiceLoader.load(service, cl)</code>中看一看：</p><pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,                                        ClassLoader loader){    // 返回了一个ServiceLoader对象。service和loader是两个构造参数，实际上赋值给成员变量了。    return new ServiceLoader&lt;&gt;(service, loader);}</code></pre><p>　　继续看ServiceLoader是如何构造新对象的，将参数传给了两个成员变量。这里要注意ClassLoader.getSystemClassLoader()获取的并不是boot类加载器，而是本线程的类加载器，即MAIN线程的类加载器appClassLoader。</p><pre><code>private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;    reload();}</code></pre><p>　　回到上面，来看一下loadInitialDrivers方法的while循环中的内容，ServiceLoader的iterator()方法返回了一个Iterator类型的对象，ServiceLoader实现了几个方法，看代码</p><pre><code>public Iterator&lt;S&gt; iterator() {    return new Iterator&lt;S&gt;() {        ／／　因为providers中并没有添加元素，因此元素数必定是０        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders            = providers.entrySet().iterator();        public boolean hasNext() {            ／／loadInitialDrivers方法的while循环在执行hasNext时，因为knownProviders没有元素，所必定走到了lookupIterator.hasNext()，这个里边有个关键的信息。            if (knownProviders.hasNext())                return true;            return lookupIterator.hasNext();        }        public S next() {            if (knownProviders.hasNext())                return knownProviders.next().getValue();            return lookupIterator.next();        }        public void remove() {            throw new UnsupportedOperationException();        }    };}</code></pre><p>　　上面的过程看注释。</p><pre><code>public boolean hasNext() {        if (acc == null) {            return hasNextService();        } else {            PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() {                // 注意这行，重点在hasNextService()中。                public Boolean run() { return hasNextService(); }            };            return AccessController.doPrivileged(action, acc);        }    }private boolean hasNextService() {        if (nextName != null) {            return true;        }        if (configs == null) {            try {                // PREFIX = &quot;META-INF/services/&quot;，而这里的service在前面ServiceLoader.load(Driver.class)传入的是java.sql.Driver.class, 完成的fullname就是&quot;META-INF/services/java.sql.Driver&quot;                String fullName = PREFIX + service.getName();                if (loader == null)                    configs = ClassLoader.getSystemResources(fullName);                else                    configs = loader.getResources(fullName);            } catch (IOException x) {                fail(service, &quot;Error locating configuration files&quot;, x);            }        }        while ((pending == null) || !pending.hasNext()) {            if (!configs.hasMoreElements()) {                return false;            }            pending = parse(service, configs.nextElement());        }        nextName = pending.next();        return true;    }</code></pre><p>上面的”META-INF/services/java.sql.Driver”是哪里来的？ 来看看我们的驱动包<br><img src="https://i.imgur.com/yseBq0f.png" alt=""><br>驱动包的这个路径下有个java.sql.Driver命名的文件，而文件中的内容只有一行<code>com.mysql.cj.jdbc.Driver</code>，就是mysql的驱动类名。也就是JDK会查找驱动包中META-INF/services/java.sql.Driver，找到文件中列出的驱动类。 后面不再深入，有兴趣的自己看下。loadInitialDrivers方法的while循环driversIterator.next()方法就是用最初传入的类加载器加载了JDBC的驱动。</p><p>PS：</p><ul><li>关于Reflection类的使用，可参考博文<a href="https://blog.csdn.net/aguda_king/article/details/72355807" title="JDK8的@CallerSensitive" target="_blank" rel="noopener">https://blog.csdn.net/aguda_king/article/details/72355807</a> </li><li>关于线程上下文类加载器的理解可以参考博文<a href="https://blog.csdn.net/yangcheng33/article/details/52631940" title="真正理解线程上下文类加载器（多案例分析）" target="_blank" rel="noopener">https://blog.csdn.net/yangcheng33/article/details/52631940</a>和<a href="https://blog.csdn.net/gabele/article/details/71250108" title="深入理解Java类加载器：线程上下文类加载器" target="_blank" rel="noopener">https://blog.csdn.net/gabele/article/details/71250108</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　JDBC是开发中常用的驱动程序，但一直没有深入了解过其加载过程。JDBC驱动的加载也是线程上下文类加载器使用的经典案例。最近有时间研究一下源码，结合JVM线程上下文类加载器的知识做个总结。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(S
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
