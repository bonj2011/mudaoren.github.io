<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木道人</title>
  
  <subtitle>看风的必不撒种；望云的必不收割。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-11T15:21:43.646Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mudaoren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/11/2PC%E5%92%8C3PC/"/>
    <id>http://yoursite.com/2018/10/11/2PC和3PC/</id>
    <published>2018-10-10T23:39:52.378Z</published>
    <updated>2018-10-11T15:21:43.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h1><p>标签（空格分隔）： 分布式协议</p><hr><h1 id="2PC与3PC-1"><a href="#2PC与3PC-1" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h1><p>在分布式系统中，当一个事务操作需要跨越多个分布式节点时，为了保证事务处理的ACID特性，需要引入一个“协调者”的组件来统一调度所有分布式节点的执行逻辑，被调度的分布式节点称为“参与者”。<br>协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。这个思想衍生出二阶段提交和三阶段提交两种协议。</p><h2 id="2PC（Two-Phase-Commit）"><a href="#2PC（Two-Phase-Commit）" class="headerlink" title="2PC（Two-Phase Commit）"></a>2PC（Two-Phase Commit）</h2><p>目的是为了保证分布式系统架构下所有节点在进行事务处理过程中能够保持原子性和一致性而设计的算法。绝大部分关系型数据库采用的都是二阶段提交协议来完成分布式事务的处理。</p><p><strong>协议说明</strong></p><ul><li>阶段一：提交事务请求<ol><li>事务询问。<br>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</li><li>执行事务。<br>各参与者执行事务操作，并将Undo和Redo信息记入事务日志中。</li><li>各参与者向协调者反馈事务询问的响应。<br>如果参与者成功执行了事务操作，则反馈给协调者Yes响应，表示事务可执行；否则就给协调者反馈NO响应，表示事务不可以执行。</li></ol></li></ul><p>这个阶段通常也称为“投票阶段”。</p><ul><li><p>阶段二：执行事务提交<br>协调者根据各参与者的反馈情况决定是否进行事务提交操作。包含两种可能：</p><p><strong>执行事务提交</strong><br>当所有参与者都反馈Yes响应时，协调者就会执行事务提交。执行过程如下</p><ol><li>发送提交请求<br>协调者向所有参与者发送Commit请求。</li><li>事务提交<br>参与者收到Commit请求后正式执行事务提交操作，在完成提交后释放整个事务执行期间占用的事务资源。</li><li>返回事务提交结果<br>向协调者发送Ack消息。</li><li>完成事务<br>协调者接收到所有参与者反馈的Ack消息后，完成事务。</li></ol><p><strong>中断事务</strong><br>当任何一个参与者向协调者反馈NO，或超时后协调者仍未收到某些参与者的响应，就会中断事务。</p><ol><li>发送事务回滚请求。<br>协调者向所有参与者发送Rollback请求。</li><li>事务回滚。<br>参与者接收到Rollback后，会利用其在阶段一种记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果。<br>参与者在完成事务回滚之后，向协调者发送Ack消息。</li><li><p>中断事务。<br>协调者收到所有参与者的Ack消息后，完成事务中断。</p><p><img src="https://i.imgur.com/uVAXMiZ.png" alt=""></p><p><img src="https://i.imgur.com/WYubkPJ.png" alt=""></p></li></ol></li></ul><p><strong>优缺点</strong><br>优点：原理简单，实现方便<br>缺点：同步阻塞、单点问题、脑裂、保守</p><ul><li><p>同步阻塞<br>提交的执行过程中，所以参与者都需要等待其他参与者的响应，无法执行其他任何操作。限制性能。这是最大的问题。</p></li><li><p>单点问题<br>协调者如果出现问题，整个系统提交流程将无法进行，如果恰好在阶段二故障，则参与者将一直锁定事务资源状态，无法继续工作。</p></li><li><p>数据不一致<br>阶段二时，若协调者已向参与者发送Commit，此时发生局部网络异常或协调者只发送了部分Commit后自身崩溃，则只有部分参与者接收到Commit请求。就会出现部分参与者提交，部分未提交，导致数据不一致现象。</p></li><li><p>保守<br>协调者指示参与者进行事务提交询问的过程中，参与值故障无法响应时，协调者只能通过超时判断是否中断。缺少一个完善的容错机制，任意一个节点失败都会导致整个事务的失败。</p></li></ul><p>2PC协议因为其阻塞的特性，在执行过程中需要锁住其他更新，且容错不够好，所以对其支持的成本较高。分布式系统用2PC协议更多的是处理多个数据分片操作的原子性。而同一个数据分片的多个副本之间的数据一致性则更多的使用Paxos来实现。</p><h2 id="3PC-Three-Phase-Commit"><a href="#3PC-Three-Phase-Commit" class="headerlink" title="3PC(Three-Phase Commit)"></a>3PC(Three-Phase Commit)</h2><p>三阶段提交协议，对二阶段提交协议的不足进行了改进。</p><p><strong>协议说明</strong></p><p>其将二阶段提交的“提交事务请求”过程一分为二，形成了由CanCommit、PreCommit、do Commit三个阶段组成的事务处理协议。<br><img src="https://i.imgur.com/oaKJeoh.png" alt=""></p><ul><li><p>阶段一：CanCommit</p><ol><li><p>事务询问<br>协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待参与者响应。</p></li><li><p>各参与者向协议者反馈事务询问响应<br>参与者受到canCommit请求后，正常情况下，如果认为可以执行事务，则返回Yes响应，并进入预备状态，否则反馈No响应。</p></li></ol></li><li><p>阶段二：PreCommit<br>两种可能的操作：</p><p><strong>执行事务预提交</strong><br>假如协调者收到所有的响应Yes，则会执行事务预提交。</p><ol><li>发送预提交请求<br>协调者向所有参与者发出preCommit请求，并进入Prepared阶段。</li><li>事务预提交<br>参与者收到preCommit后，执行事务操作，并将Undo和Redo信息记录到事务日志中。</li><li>各参与值向协调者反馈事务执行的响应<br>如果参与者执行了事务操作，就会给协调者反馈Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。</li></ol><p><strong>中断事务</strong><br>假如任何一个参与者反馈的是No响应，或者超时未响应，那么协调者就会中断事务。</p><ol><li>发送中断请求<br>协调者向所有参与者发送abort请求。</li><li>中断事务<br>无论收到来自协调者的abort请求，或是等待协调者请求过程中出现超时，参与者都会中断事务。</li></ol></li><li><p>阶段三：doCommit<br>进行真正的事务提交操作，存在两种情况：</p><p>  <strong>执行提交</strong></p><ol><li>发送提交请求<br>协调者收到所有响应者的Ack响应，他将从“预提交”状态转化到“提交”状态，并向所有参与者发送doCommit请求。</li><li>执行事务提交<br>参与者收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li>反馈事务提交结果<br>参与者在完成事务提交之后，向协调者发送Ack消息。</li><li>完成事务<br>协调者接收到所有参与者的Ack消息后，完成事务。</li></ol><p><strong>中断事务</strong><br>任意一个参与者反馈No响应，或协调者等待超时后，协调者就会中断事务。</p><ol><li>发送中断请求<br>协调者向所有参与者节点发送abort请求。</li><li>事务回滚<br>参与者接收到abort请求后利用在阶段二中的Undo信息来执行回滚操作，并在完成回滚后释放在整个事务执行期间占用的资源。</li><li>反馈事务回滚结果<br>参与者完成事务回滚后，向协调者发送Ack消息。</li><li>中断事务<br>协调者接收到所有参与者反馈的Ack消息后，中断事务。</li></ol></li></ul><p>在阶段三中可能存在两种故障：</p><ul><li>协调者出现问题。</li><li>协调者和参与者之间的网络出现故障。</li></ul><p>无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或abort请求，针对这样的异常情况，参与者都会在等待超时后，继续进行事务提交。</p><p><strong>优缺点</strong><br>优点：解决了二阶段提交参与者无限期阻塞的问题，并且在出现单点故障后能继续达成一致。<br>缺点：在第三阶段，如果参与者没有接收到协调者发出的abort请求，那超时后依然会自动完成事务提交，必然出现一致性问题。另外，3PC增加了交互的次数，降低了性能。</p><p>3PC保证了CAP理论中的C和A，但是无法保证P——分区容错性，在实际操作中极少使用3PC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2PC与3PC&quot;&gt;&lt;a href=&quot;#2PC与3PC&quot; class=&quot;headerlink&quot; title=&quot;2PC与3PC&quot;&gt;&lt;/a&gt;2PC与3PC&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： 分布式协议&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;2PC与3PC-1&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/11/BASE%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/10/11/BASE理论/</id>
    <published>2018-10-10T23:39:52.356Z</published>
    <updated>2018-10-10T14:51:08.606Z</updated>
    
    <content type="html"><![CDATA[<p>BASE理论<br>BASE理论是基本可用（Basically Available）、软状态（Soft state）、最终一致性（Eventually），是eBay架构师Dan Pritchett提出的。它是基于CAP理论发展而来，主要是针对大规模互联网系统分布式实践的总结。基本思想史即使无法做到强一致性，也要达到最终一致性。</p><ul><li>基本可用<br>系统在出现不可预知故障时，允许损失部分可用性，以保证整体可用性。比如损失响应时间换取最终结果，或是出现流量高峰时引导用户到降级页面。</li><li>弱状态<br>允许系统中的数据存在中间状态，而这种中间状态不会影响整体可用性。比如数据在不同系统节点间同步时存在延时的情况。</li><li>最终一致性<br>系统中所有数据副本，经过一段时间同步后，最终能达到一个一致状态。</li></ul><p>最终一致性的几种变种：</p><ul><li>因果一致性（Causal consistency）<br>进程A更新数据后通知进程B，则B访问该数据时，获取的都是被A更新后的数据。与A无因果关心的C访问数据时，则没有限制。</li><li>读己之所写（Read you write）<br>进程A更新一个数据项之后，它自己总能访问更新过的最新值，看不到旧值。</li><li>会话一致性（Session consistency）<br>将系统数据的访问过程限定在一个会话当中，保证同一个有效会话中实现“读己之所写”的一致性。</li><li>单调读一致性（Monotonic read consistency）<br>如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li><li>单调写一致性（Monotonic write consistency）<br>保证来自同一个进程的写操作被顺序地执行。</li></ul><p>想一想数据库的主从模式属于哪一种类型？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BASE理论&lt;br&gt;BASE理论是基本可用（Basically Available）、软状态（Soft state）、最终一致性（Eventually），是eBay架构师Dan Pritchett提出的。它是基于CAP理论发展而来，主要是针对大规模互联网系统分布式实践的总结
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/10/10/ACID/"/>
    <id>http://yoursite.com/2018/10/10/ACID/</id>
    <published>2018-10-09T23:38:41.033Z</published>
    <updated>2018-10-09T23:36:46.926Z</updated>
    
    <content type="html"><![CDATA[<p>ACID是事务的四个特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><ul><li>原子性（Atomicity）<br>事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态：全部执行成功、全部不执行。</li><li>一致性（Consistency）<br>事务的执行不能破坏数据的完整性和一致性。数据在所有应用、服务和数据库中的状态必须是一致的，并且是无缺失的。</li><li><p>隔离性（Isolation）<br>并发环境中，不同事务之间是隔离的，相互独立，无干扰。SQL规范中隔离性有4中级别：未授权读取、授权读取、可重复读取、串行化。<br><img src="https://i.imgur.com/CLMAV6s.png" alt=""></p></li><li><p>持久性（Durability）<br>事务一旦提交，其变更的数据的状态就会永久保存。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ACID是事务的四个特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）&lt;br&gt;事务必须是一个原子的操作序列单元。事务中包含的各项操
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/12/CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/09/12/CAP理论/</id>
    <published>2018-09-12T15:36:58.684Z</published>
    <updated>2018-09-12T15:44:33.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition rolerance）这三项基本需求，最多只能同时满足两种。</p><ul><li>一致性：分布式环境中，数据在多个副本间保持一致。数据在两个节点上存在副本，数据在一个节点上更新后，在另一个节点上能马上读取到新的值（强一致性或严格一致性）。</li><li>可用性：对于用户的操作，总能在有限时间内返回结果。</li><li>分区容错性：分布式系统在遇到任何网络分区发生故障时，仍然能保证对外提供满足一致性和可用性的服务，除非是整个网络故障。</li></ul><p><strong>CAP理论示意图</strong><br><img src="https://i.imgur.com/Hujjfja.png" alt=""></p><p><strong>CAP理论应用</strong><br><img src="https://i.imgur.com/3wlzQjE.png" alt=""></p><p>既然是分布式系统，肯定是能满足分区容错性的，特别是现在的微服务系统。所以设计师往往会在一致性（Consistency）和可用性（Availability）之间抉择。</p><p><em>参考《从PAXOS到ZOOKEEPER分布式一致性原理与实践》</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h1&gt;&lt;p&gt;分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Parti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/12/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/09/12/索引分类/</id>
    <published>2018-09-11T16:03:58.217Z</published>
    <updated>2018-09-11T16:03:49.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ul><li>按照字段个数划分：单列索引、组合索引</li><li>按照唯一性划分：普通索引、唯一索引</li><li>MyISAM特殊索引：全文索引（char、varchar、text类型的列，不支持多列，用于全文搜索）、空间索引（非空字段）</li></ul><h2 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h2><p>方法一：创建表时创建</p><pre><code>CREATE TABLE &lt;table_name&gt; [col_name data_type][UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length],...)[ASC|DESC]</code></pre><ul><li>UNIQUE|FULLTEXT|SPATIAL 均为可选，分别表示唯一索引、全文索引、空间索引。</li><li>INDEX|KEY 含义相同均指创建索引。</li><li>index_name为索引名，不指定时与列名相同。</li><li>col_name要创建索引的列名。</li><li>length可选，表示索引长度，只有字符串类型的字段才可以指定。</li><li>ASC|DESC可选，表示升序还是降序。</li></ul><p>方法二：已存在的表上创建索引</p><pre><code>ALTER TABLE &lt;table_name&gt; ADD [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length],...)[ASC|DESC]CREATE [UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name] ON &lt;table_name&gt;(col_name[length],...)[ASC|DESC]</code></pre><h2 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h2><p>方法一：ALTER语句删除</p><pre><code>ALTER TABLE DROP INDEX &lt;index_name&gt;</code></pre><p>方法二：DROP语句删除</p><pre><code>DROP INDEX &lt;index_name&gt; ON &lt;table_name&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;h2 id=&quot;索引分类&quot;&gt;&lt;a href=&quot;#索引分类&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/12/SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80%E2%80%94%E2%80%94%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2018/09/12/SQL性能优化一——减少数据库交互次数/</id>
    <published>2018-09-11T16:00:27.655Z</published>
    <updated>2018-09-11T16:05:52.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL性能优化一——减少数据库交互次数"><a href="#SQL性能优化一——减少数据库交互次数" class="headerlink" title="SQL性能优化一——减少数据库交互次数"></a>SQL性能优化一——减少数据库交互次数</h1><p>把多条SQL语句合并为一条，可减少数据库交互次数，提高性能，这是一种简单的优化改进。</p><p><strong>创建表t_user</strong></p><pre><code>CREATE TABLE `t_user` (　　`id` tinyint(10) UNSIGNED AUTO_INCREMENT NOT NULL,　　`name` varchar(255) DEFAULT NULL,　　`age` int(10) DEFAULT NULL,　　`updatetime` datetime DEFAULT NULL,　　INDEX index_name(name),) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><h2 id="1-整合DDL语句"><a href="#1-整合DDL语句" class="headerlink" title="1 整合DDL语句"></a>1 整合DDL语句</h2><p>多条的写法：</p><pre><code>ALTER table t_user ADD COLUMN uid TINYINT UNSIGNED;ALTER table t_user ADD UNIQUE INDEX (uid); ALTER table t_user DROP INDEX index_name, ADD INDEX index_name_age (name, age);ALTER TABLE t_user ADD PRIMARY KEY (id);</code></pre><p>合并为一条：</p><pre><code>ALTER TABLE t_user ADD COLUMN uid TINYINT UNSIGNED,　ADD UNIQUE INDEX (uid),　DROP INDEX index_name,　ADD INDEX index_name_age (NAME, age),　ADD PRIMARY KEY (id);</code></pre><h2 id="2-整合DML语句"><a href="#2-整合DML语句" class="headerlink" title="2 整合DML语句"></a>2 整合DML语句</h2><h3 id="2-1-INSERT的整合"><a href="#2-1-INSERT的整合" class="headerlink" title="2.1 INSERT的整合"></a>2.1 INSERT的整合</h3><pre><code>INSERT INTO &lt; table_name &gt; (　　　　columnname1,　　　　columnname2 ,...)VALUES(    　　columnvalue1,    　　columnvalue2 ,...) ,    ..., (        columnvalue1,        columnvalue2 ,...);</code></pre><p><strong>整合前：</strong></p><pre><code>INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200);INSERT INTO t_user (id, name, age) VALUES  (2, &apos;张无忌&apos;, 50) ;</code></pre><p><strong>整合后</strong></p><pre><code>INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200), (2, &apos;张无忌&apos;, 50) ;</code></pre><h3 id="2-2-UPDATE的整合"><a href="#2-2-UPDATE的整合" class="headerlink" title="2.2 UPDATE的整合"></a>2.2 UPDATE的整合</h3><p>在更新目标一致的情况下可使用下面语句整合。</p><pre><code>UPDATE &lt;table_name&gt; set &lt;columnname&gt;=&lt;columnvalue&gt;, ... where &lt;columnnamen&gt; in (value1, value2,...);</code></pre><h3 id="2-3-INSERT和UPDATE的整合"><a href="#2-3-INSERT和UPDATE的整合" class="headerlink" title="2.3 INSERT和UPDATE的整合"></a>2.3 INSERT和UPDATE的整合</h3><p>当在满足条件时，可合并：先检查要插入的主键是否存在，如果不存在就插入行，如果存在就执行update操作。</p><pre><code>INSERT ... ON DUPLICATE KEY UPDATE</code></pre><p>举例： id是主键，当不存在id=1的数据是，插入一行；若存在，则将id=1的那行数据的age更新为201。</p><pre><code>INSERT INTO t_user (id, name, age) VALUES (1, &apos;张三丰&apos;, 200) ON DUPLICATE KEY UPDATE age = 201;</code></pre><p>注意：该语句存在死锁风险，请在满足以下两条件时使用（1、尽量不对存在多个唯一键的table使用该语句；2、在有可能有并发事务执行的insert 的内容一样情况下不使用该语句）<a href="https://blog.csdn.net/pml18710973036/article/details/78452688" target="_blank" rel="noopener">bug</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL性能优化一——减少数据库交互次数&quot;&gt;&lt;a href=&quot;#SQL性能优化一——减少数据库交互次数&quot; class=&quot;headerlink&quot; title=&quot;SQL性能优化一——减少数据库交互次数&quot;&gt;&lt;/a&gt;SQL性能优化一——减少数据库交互次数&lt;/h1&gt;&lt;p&gt;把多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/11/MySQL%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2018/09/11/MySQL唯一性约束/</id>
    <published>2018-09-11T15:50:38.572Z</published>
    <updated>2018-09-11T15:50:28.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL唯一性约束"><a href="#MySQL唯一性约束" class="headerlink" title="MySQL唯一性约束"></a>MySQL唯一性约束</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>一个表只能存在一个，且不允许空值 </p><ul><li>定义列时指定：</li></ul><p>　　<code>&lt;col_name&gt; &lt;data_type&gt; PRIMARY KEY [DEFAULT &lt;value&gt;]</code> </p><ul><li>定义完列后指定：</li></ul><p>　　<code>[CONSTANT&lt;key_name&gt;] PRIMARY KEY(&lt;col_name1&gt;,...)</code></p><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><p>一个表允许有多个，且允许列上存在一个空值   </p><ul><li><p>定义列时指定：</p><p>  <code>&lt;col_name&gt; &lt;data_type&gt; UNIQUE</code></p></li><li><p>定义完列后指定：</p></li></ul><p>　　<code>[CONSTANT&lt;key_name&gt;] UNIQUE(&lt;col_name1&gt;,...)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL唯一性约束&quot;&gt;&lt;a href=&quot;#MySQL唯一性约束&quot; class=&quot;headerlink&quot; title=&quot;MySQL唯一性约束&quot;&gt;&lt;/a&gt;MySQL唯一性约束&lt;/h1&gt;&lt;h2 id=&quot;主键&quot;&gt;&lt;a href=&quot;#主键&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/11/AUTO_INCREMENT/"/>
    <id>http://yoursite.com/2018/09/11/AUTO_INCREMENT/</id>
    <published>2018-09-11T15:44:32.540Z</published>
    <updated>2018-09-11T15:44:07.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h1><p>一个表只能有一个字段使用自增约束，且字段必须是主键的一部分。其约束的字段可以是任何整型类型（TINYINT、INT、SMALLIN、BIGINT）。默认从1开始，每增加一行自动加1。</p><p>设置语法：</p><pre><code>&lt;col_name&gt; &lt;data_type&gt; AUTO_INCREMENT</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AUTO-INCREMENT&quot;&gt;&lt;a href=&quot;#AUTO-INCREMENT&quot; class=&quot;headerlink&quot; title=&quot;AUTO_INCREMENT&quot;&gt;&lt;/a&gt;AUTO_INCREMENT&lt;/h1&gt;&lt;p&gt;一个表只能有一个字段使用自增约束，且字段必须
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/11/%E5%BA%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/09/11/库存/</id>
    <published>2018-09-11T15:18:19.975Z</published>
    <updated>2018-08-19T15:12:00.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　库存是一个复杂度很高的核心系统，提供前端实时查询的能力和后端的商品扣减，还要处理订单取消问题。这对库存系统的准确性和可靠性提出了很高的要求，在各种场景下能保证数据的准确，在遇到突发流量时能保证高可用，除此之外，还需要提供熔断和降级的能力，保证在极端情况下不拖垮主站。</p><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p><img src="https://i.imgur.com/B9MdgH1.gif" alt=""></p><ul><li>DUBBO是一款非常优秀的 RPC 层框架，提供高性能和透明化的RPC远程服务调用方案,以及SOA服务治理方案。</li><li>RocketMQ是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。</li><li>Redisson是架设在Redis基础上的一个Java驻内存数据网格。</li><li>Redis单线程的高速缓存数据库，支持持久化、事务，通过哨兵和自动分区提供高可用。</li><li>Druid阿里的开源软件，专为监控而生的数据库连接池。</li><li>Mybatis是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</li><li>MySQL关系型数据库系统。</li></ul><h2 id="库存扣减"><a href="#库存扣减" class="headerlink" title="库存扣减"></a>库存扣减</h2><p>　　为简化库存系统，库存系统之上建立交易系统和订单管理系统，库存只负责管理商品扣减。</p><h3 id="1-何时扣减"><a href="#1-何时扣减" class="headerlink" title="1. 何时扣减"></a>1. 何时扣减</h3><p>　　库存扣减一般有三个时机：</p><ul><li>加购物车时扣减。商品加入购物车，并不能说明用户确实要购买，实际转化率并不高，假如此时扣库存，会导致库存被占用而无法释放，影响正常销售。</li><li>提交订单时扣减。用户下单后还有一个支付操作，如果用户仅仅下单而不进行支付，这部分库存将会被无效占用，影响正常销售。这里可以做一个支付时限，如果超过时限未支付，订单将被取消，预占得库存被返还。</li><li>支付时扣减。用户进行支付，说明交易即将完成，这部分是必须要留住的订单和用户，如果此时扣库存，出现库存不足导致用户支付失败会严重影响用户体验。</li></ul><p>　　目前为提高库存效率和用户体验，系统采用提交订单扣库存的策略。这也是大部分电商平台采用的扣减策略。</p><h3 id="2-如何扣减"><a href="#2-如何扣减" class="headerlink" title="2. 如何扣减"></a>2. 如何扣减</h3><p>　　库存扣减需要应对主要问题是高并发问题、重复扣减问题（超卖）。　　<br>　　上游系统需要配合库存系统做好扩容、限流保护、隔离（业务隔离、数据隔离，以及系统隔离）、动静分离、localCache等措施，通过漏斗模型逐层减少用户流量，避免流量高峰对库存系统的冲击，必要时采用熔断进行降级（比如查询库存时直接返回有库存）。<br>　　系统采用Redission+Redis解决高并发问题，Redis是内存数据库性能相对较高，本身支持事务操作,使用Redisson的Rbatch保证事务性，扣减操作包含query和done，两个动作属于一个事务，且done操作保证幂等。<br>　  重复扣刷减最常出现的包括用户误操作、黄牛绕过前端进行单、交易系统重试操作：  </p><ul><li>用户误操作，前端购物车在用户提交订单后将购物车数据删除，无法继续提交。</li><li>黄牛绕过前段刷单，前端必须经过交易系统通过RPC调用库存系统，在交易系统中通过风控、调用次数限制、订单令牌等方法限制重复提交订单。</li><li>交易系统重试问题，库存系统通过限制一个订单只能进行一次事务性的库存扣减操作，防止交易系统重试导致的饭后服扣减。<br>　　还有重要的一点是记录库存扣减日志，在库存回滚时使用。</li></ul><h3 id="3-如何回滚"><a href="#3-如何回滚" class="headerlink" title="3. 如何回滚"></a>3. 如何回滚</h3><p>　　用户取消订单、用户退货、异常订单流程都会触发库存回滚操作。<br>　　为每一个订单设定一个唯一编号，并且按照编号记录库存操作流日志，在需要做库存回滚时依据唯一编号进行库存的返还，回滚操作需要根据编号保证事务性和幂等性。<br>　　库存的返还采用同步回滚+异步重试机制，用户取消订单和异常订单的回滚操作首先进行订单的同步逆向操作，在库存返还时如果失败，将唯一编号记录下来，通过异步定时任务进行返还。<br>　　用户退货往往涉及到实物商品的退库，因此发起方是订单管理系统，当实物商品完成退库后，订单管理系统将发送MQ消息，库存系统通过订阅消息进行库存返还。<br>　　尽管同步回滚+异步重试已经足够保证库存的正确回滚，但是为万无一失，还需要增加一个数据健康度的自我检查能力，超时超次未完成回滚的库存数据需要人工干预。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h3><p>　　由于Redis的读写能力远胜于任何关系型数据库，因此在Redis中保存商品库存数据并完成扣减操作。<br>　　使用Redis的以下特性保证库存系统的高并发和高可用：</p><ul><li>分库分表，因垂直电商业务特点且主站秒杀和抢购并不在主站中，因此为简化逻辑按照SKU维度采用HASH算法进行分库的策略。当然在极端情况下可以对每个SKU继续进行库存拆分，拆分成二级SKU，目前秒杀业务就是采用这种策略。</li><li>读写分离，采用Master/Slave模式，其中Master提供写操作，Slave提供读操作，降低Master的压力，提供高速读写操作。</li><li>主从+哨兵模式，为保证Redis的可靠性，启用Redis的主从模式和哨兵模式。部署Sentinel集群+Master/Slave集群，实现Master故障的自动发现和切换。</li><li>持久化，启用AOF实时持久化功能，保障数据的秒级备份。</li></ul><h3 id="2-MySQL"><a href="#2-MySQL" class="headerlink" title="2.MySQL"></a>2.MySQL</h3><p>　　用于记录操作日志和扣减日志。<br>　　为提高读写性能采用主从模式和读写分离模式，最初MySQL还承担着库存数据的批量落盘功能，随着Redis库存方式的长时间稳定运行，库存逐渐完全转移到Redis上，MySQL仅仅承担着记录操作日志和扣减日志的功能。</p><p><a href="http://www.iteye.com/news/32768" target="_blank" rel="noopener">http://www.iteye.com/news/32768</a><br><a href="https://mp.weixin.qq.com/s/aIzdMG1y0a5cWOS4lx6IuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aIzdMG1y0a5cWOS4lx6IuQ</a><br><a href="https://www.cnblogs.com/liuchuanfeng/p/7190654.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuchuanfeng/p/7190654.html</a><br>Redis开发与运维</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;　　库存是一个复杂度很高的核心系统，提供前端实时查询的能力和后端的商品扣减，还要处理订单取消问题。这对库存系统的准确性和可靠性提出了很高的要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/11/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2018/09/11/线程上下文类加载器的初始化/</id>
    <published>2018-09-11T15:17:59.437Z</published>
    <updated>2018-09-02T15:12:04.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程上下文类加载器的初始化"><a href="#线程上下文类加载器的初始化" class="headerlink" title="线程上下文类加载器的初始化"></a><center>线程上下文类加载器的初始化</center></h1><hr><p>　　线程上线文类加载器是JVM类加载模型中的一个特殊存在，在使用时，只需要执行Thread.currentThread().getContextClassLoader()就可以获取线程上线文类加载器，即当前线程的类加载器。但是这个类加载器是什么时候设置的呢？ 我们执行下面代码</p><pre><code>public static void main(String[] args) throws ClassNotFoundException,        SQLException{    System.out.println(Thread.currentThread().getContextClassLoader());}</code></pre><p>　　输出结果是</p><pre><code>sun.misc.Launcher$AppClassLoader@c387f44</code></pre><p>　　即使用的是AppClassLoader类加载器，但是这个上下文中的加载器是什么时候设置进去的？<br>　　我们都知道，在调用类的静态方法时，类及其父类都会被初始化，初始化过程中最重要的部分就是执行类中的静态代码块、及初始化成员变量。但Thread的静态代码块中只是注册了一个本地方法而已。</p><pre><code>static {    registerNatives();}</code></pre><p>　　我们看看Thread对象被初始化时做了什么？</p><pre><code>public Thread() {    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);}private void init(ThreadGroup g, Runnable target, String name,                  long stackSize) {    init(g, target, name, stackSize, null);}private void init(ThreadGroup g, Runnable target, String name,                  long stackSize, AccessControlContext acc) {    if (name == null) {        throw new NullPointerException(&quot;name cannot be null&quot;);    }    this.name = name.toCharArray();    Thread parent = currentThread();    SecurityManager security = System.getSecurityManager();    if (g == null) {        /* Determine if it&apos;s an applet or not */        /* If there is a security manager, ask the security manager           what to do. */        if (security != null) {            g = security.getThreadGroup();        }        /* If the security doesn&apos;t have a strong opinion of the matter           use the parent thread group. */        if (g == null) {            g = parent.getThreadGroup();        }    }    /* checkAccess regardless of whether or not threadgroup is       explicitly passed in. */    g.checkAccess();    /*     * Do we have the required permissions?     */    if (security != null) {        if (isCCLOverridden(getClass())) {            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);        }    }    g.addUnstarted();    this.group = g;    this.daemon = parent.isDaemon();    this.priority = parent.getPriority();    // 这里在做线程上下文类加载器的赋值操作，如果系统没有设置安全管理器，则会调用Thread的getContextClassLoader()方法获取类加载器。而parent是currentThread()即启动本线程的线程。把父线程的上下文类加载器给继承过来。这里的父子关系是指谁启动谁的关系，比如在线程A里面启动了线程B，那B线程的父线程就是A。    if (security == null || isCCLOverridden(parent.getClass()))        this.contextClassLoader = parent.getContextClassLoader();    else        this.contextClassLoader = parent.contextClassLoader;    this.inheritedAccessControlContext =            acc != null ? acc : AccessController.getContext();    this.target = target;    setPriority(priority);    if (parent.inheritableThreadLocals != null)        this.inheritableThreadLocals =            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);    /* Stash the specified stack size in case the VM cares */    this.stackSize = stackSize;    /* Set thread ID */    tid = nextThreadID();}@CallerSensitivepublic ClassLoader getContextClassLoader() {    if (contextClassLoader == null)        return null;    SecurityManager sm = System.getSecurityManager();    if (sm != null) {        ClassLoader.checkClassLoaderPermission(contextClassLoader,                                               Reflection.getCallerClass());    }    return contextClassLoader;}</code></pre><p>第一个被启动的线程是哪个？那第一个启动的线程（包含main方法的那个线程）里面的contextClassLoader是谁设置的呢？不要忘记，Main本身就启动了一个线程。<br>这要看 sun.misc.Launcher 这个类的源码。Launcher是JRE中用于启动程序入口main()的类。</p><pre><code>loader = AppClassLoader.getAppClassLoader(extcl);Thread.currentThread().setContextClassLoader(loader);</code></pre><p>这里截取的两行代码出自 Launcher 的构造方法。第一行用一个扩展类加载器extcl构造了一个系统类加载器loader，第二行把loader设置为当前线程（包含main方法）的类加载器。所以，我们启动一个线程的时候，如果之前都没有调用 setContextClassLoader 方法明确指定的话，默认的就是系统类加载器。</p><p>参考<br><a href="https://www.cnblogs.com/cz123/p/6867345.html" target="_blank" rel="noopener">https://www.cnblogs.com/cz123/p/6867345.html</a><br><a href="https://blog.csdn.net/gabele/article/details/71250108" target="_blank" rel="noopener">https://blog.csdn.net/gabele/article/details/71250108</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程上下文类加载器的初始化&quot;&gt;&lt;a href=&quot;#线程上下文类加载器的初始化&quot; class=&quot;headerlink&quot; title=&quot;线程上下文类加载器的初始化&quot;&gt;&lt;/a&gt;&lt;center&gt;线程上下文类加载器的初始化&lt;/center&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;　　线程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/07/CAS/"/>
    <id>http://yoursite.com/2018/09/07/CAS/</id>
    <published>2018-09-06T23:37:51.865Z</published>
    <updated>2018-09-11T15:10:03.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAS（compare-and-sweep-与乐观并发策略"><a href="#CAS（compare-and-sweep-与乐观并发策略" class="headerlink" title="CAS（compare and sweep)与乐观并发策略"></a><font size="6">CAS（compare and sweep)与乐观并发策略</font></h2><p>　　CAS保证了并发时，操作和冲突检查的原子性。<br>　　CAS最初用到硬件指令上，是一条硬件指令，包括3个操作数：内存位置（地址）用V表示、旧的预期值用A表示、新值用B表示，在执行时，仅当V符合旧的预期值A时，处理器才会用新值B更新V的值，否则不执行更新，但无论是否更新了V，都会返回V的旧值，这个过程是一个原子操作。<br>　　jdk1.5后，java开始使用CAS操作，该操作由sun.misc.Unsafe类中的compareAndSweepInt()和compareAndSweepLong()等几个方法包装提供。在虚拟机即时编译出的结果就是一条平台相关的CAS指令，没有JAVA方法的调用过程。（即过程是原子性的）。这个功能在JDK1.8又做了增强，重试的过程也是在机器的指令集上执行的。<br>　　CAS的ABA问题，如果V的初始值是A，在第一次读取时也是A，但是在读取后——赋值前这期间V被改为B，然后又被改回到A，此时，CAS操作会认为V没有被改变过。这个就是著名的ABA问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CAS（compare-and-sweep-与乐观并发策略&quot;&gt;&lt;a href=&quot;#CAS（compare-and-sweep-与乐观并发策略&quot; class=&quot;headerlink&quot; title=&quot;CAS（compare and sweep)与乐观并发策略&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/03/JDBC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/03/JDBC类加载过程分析/</id>
    <published>2018-09-03T14:05:09.918Z</published>
    <updated>2018-09-11T15:09:32.345Z</updated>
    
    <content type="html"><![CDATA[<font size="6">mysql驱动的类加载过程</font><hr><p>　　JDBC是开发中常用的驱动程序，但一直没有深入了解过其加载过程。JDBC驱动的加载也是线程上下文类加载器使用的经典案例。最近有时间研究一下源码，结合JVM线程上下文类加载器的知识做个总结。</p><pre><code>public static void main(String[] args) throws ClassNotFoundException,        SQLException{    // 加载mysql驱动    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);    Connection connection = DriverManager.getConnection(            &quot;jdbc://localhost:3306/mysql&quot;, &quot;username&quot;, &quot;password&quot;);}</code></pre><p>#1. Class.forName完成JDBC驱动的加载，底层是如何实现的？ #<br>    @CallerSensitive<br>    public static Class&lt;?&gt; forName(String className)<br>                throws ClassNotFoundException {<br>        Class&lt;?&gt; caller = Reflection.getCallerClass();<br>        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);<br>    }</p><p>　　forName继续调用forName0方法，但是forName0方法是个Native方法，看不到源码了，如下：</p><pre><code>/** Called after security check for system loader access checks have been made. */private static native Class&lt;?&gt; forName0(String name, boolean initialize,                                        ClassLoader loader,                                        Class&lt;?&gt; caller)    throws ClassNotFoundException;</code></pre><p>　　通过查询oracle的技术文档，这个方法返回的是一个由字符串className相同类限定名的Class对象<br>“Returns the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to:<br>　　<code>Class.forName(className, true, currentLoader)</code><br>where currentLoader denotes the defining class loader of the current class.”</p><p>　　再来看Class.forName(className, true, currentLoader)方法的技术文档，如下：</p><p>“Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.</p><p>If name denotes an array class, the component type of the array class is loaded but not initialized.<br>For example, in an instance method the expression:<br>    <code>Class.forName(&quot;Foo&quot;)</code><br>is equivalent to:<br><code>Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())</code>”。</p><p>　　forName方法返回的是一个指定全限定类（接口）名的对象，使用的是指定的类加载器进行加载，如果指定的类加载器为空并且initialize传入true，则使用bootstrapClassLoader进行加载。同时，如果加载器中没有该类的初始化信息，则会对类（接口）进行初始化。<br>　　这里就是类（接口）的初始化过程，将字节码信息转化成方法区（元数据区）的数据，并返回一个Class对象到堆内存中，作为调用的入口。</p><p>　　因为我们传入的是<code>com.mysql.cj.jdbc.Driver</code>，因此这个过程就是类<code>Driver</code>被初始化的过程。JVM虚拟机在类初始化过程中最重要的两个动作就是初始化本类和父类的成员变量和执行静态代码块。我们来看看<code>Driver</code>类中的成员变量和静态代码块，如下：</p><pre><code>public class Driver extends com.mysql.cj.jdbc.Driver {    public Driver() throws SQLException {        super();    }    static {        System.err.println(&quot;Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. &quot;                + &quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;);    }}</code></pre><p>代码中static块中只是打印了一个日志，没有其他动作。类加载时如果还会加载父类的信息，来看看<code>com.mysql.cj.jdbc.Driver</code>中是否有静态代码块。</p><pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {    //    // Register ourselves with the DriverManager    //    static {        try {            // 实际加载的驱动，这里调用了DriverManager的静态方法，会触发该类的初始化动作            java.sql.DriverManager.registerDriver(new Driver());        } catch (SQLException E) {            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);        }    }    /**     * Construct a new driver and register it with DriverManager     *      * @throws SQLException     *             if a database error occurs.     */    public Driver() throws SQLException {        // Required for Class.forName().newInstance()    }}</code></pre><p>代码中看到<code>com.mysql.cj.jdbc.Driver</code>中静态块执行了这段代码<code>java.sql.DriverManager.registerDriver(new Driver())</code>，实际上是将自己作为参数传递给了jdk的<code>DriverManager.registerDriver</code>方法，而这个方法是将MySQL的Drive对象包装成jdk的DriverInfo对象后保存到成员变量DriverManager.registeredDrivers的数组中（如果已经存在就什么都不做）。<br>　　我们还遗漏了什么？<br>　　<code>com.mysql.cj.jdbc.Driver</code>还继承了<code>NonRegisteringDriver</code>，在Driver初始化前会先初始化<code>NonRegisteringDriver</code>中的静态成员变量和代码块，来看下代码：</p><pre><code>static {    try {        Class.forName(AbandonedConnectionCleanupThread.class.getName());    } catch (ClassNotFoundException e) {        // ignore    }}</code></pre><p>　　这里又加载了一个类AbandonedConnectionCleanupThread，这个类什么作用呢？ 再来看一下他的代码：</p><pre><code>/**This class implements a thread that is responsible for closing abandoned MySQL connections, i.e., connections that are not explicitly closed.There is only one instance of this class and there is a single thread to do this task. This thread&apos;s executor is statically referenced in this same class.**/public class AbandonedConnectionCleanupThread implements Runnable {    private static final ExecutorService cleanupThreadExcecutorService;    static Thread threadRef = null;    static {        cleanupThreadExcecutorService = Executors.newSingleThreadExecutor(new ThreadFactory() {            public Thread newThread(Runnable r) {                Thread t = new Thread(r, &quot;Abandoned connection cleanup thread&quot;);                t.setDaemon(true);                // Tie the thread&apos;s context ClassLoader to the ClassLoader that loaded the class instead of inheriting the context ClassLoader from the current                // thread, which would happen by default.                // Application servers may use this information if they attempt to shutdown this thread. By leaving the default context ClassLoader this thread                // could end up being shut down even when it is shared by other applications and, being it statically initialized, thus, never restarted again.                t.setContextClassLoader(AbandonedConnectionCleanupThread.class.getClassLoader());                return threadRef = t;            }        });        cleanupThreadExcecutorService.execute(new AbandonedConnectionCleanupThread());    }    ....}</code></pre><p>　　很明显，这里启动了一个守护线程，这个线程用来关闭没有被正确关闭的MySQL链接。</p><h1 id="2-DriverManager-getConnection做了什么事情？"><a href="#2-DriverManager-getConnection做了什么事情？" class="headerlink" title="2.DriverManager.getConnection做了什么事情？"></a>2.DriverManager.getConnection做了什么事情？</h1><p>　　继续看一下文章开头的第二行代码<code>DriverManager.getConnection()</code>做了什么。</p><pre><code>@CallerSensitivepublic static Connection getConnection(String url,    String user, String password) throws SQLException {    java.util.Properties info = new java.util.Properties();    if (user != null) {        info.put(&quot;user&quot;, user);    }    if (password != null) {        info.put(&quot;password&quot;, password);    }    return (getConnection(url, info, Reflection.getCallerClass()));}</code></pre><p>　　将mysql的用户名密码设置到Properties中，连同url、调用类（Reflection.getCallerClass获取）传递给getConnection方法，重点来了：</p><pre><code>//  Worker method called by the public getConnection() methods.private static Connection getConnection(    String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {    /*     *  当传入的caller不为空时，使用传入对象的类加载器，否则就进入到同步块中获取当前线程的上下文中的类加载器。而这类传入的caller不为空，是在DriverManager中调用了Reflection.getCallerClass()获取了DriverManager的Class,因此这里的ClassLoader应该是BootstrapClassLoader，然而系统类加载器是不能被程序获取的（JVM虚拟机限制）。所以callerCL获取了线程上下文类加载器，这里使用了currentThread()，实际上是获取了main方法的类加载器即appClassLoader。     */    ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;    synchronized(DriverManager.class) {        // synchronize loading of the correct classloader.        if (callerCL == null) {            callerCL = Thread.currentThread().getContextClassLoader();        }    }    if(url == null) {        throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);    }    println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);    // Walk through the loaded registeredDrivers attempting to make a connection.    // Remember the first exception that gets raised so we can reraise it.    SQLException reason = null;    //轮训成员变量registeredDrivers中的DriverInfo,并创建连接。如果创建连接发生异常则将最近一次异常记录下来，后面会打日志并抛出这个异常。    for(DriverInfo aDriver : registeredDrivers) {        // If the caller does not have permission to load the driver then        // skip it.        if(isDriverAllowed(aDriver.driver, callerCL)) {            try {                println(&quot;    trying &quot; + aDriver.driver.getClass().getName());                Connection con = aDriver.driver.connect(url, info);                if (con != null) {                    // Success!                    println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());                    return (con);                }            } catch (SQLException ex) {                if (reason == null) {                    reason = ex;                }            }        } else {            println(&quot;    skipping: &quot; + aDriver.getClass().getName());        }    }    // if we got here nobody could connect.    if (reason != null)    {        println(&quot;getConnection failed: &quot; + reason);        throw reason;    }    println(&quot;getConnection: no suitable driver found for &quot;+ url);    throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);}</code></pre><p>　　还有一个重要的点被我们忽略了！初始化一个对象、调用类的静态方法、读取或者设置一个类的静态变量、使用反射调用一个类、子类被初始化。了解了这些，我们再来看DriverManager.getConnection是不是调用了DriverManager的静态方法？是不是触发了DriverManager的初始化过程？ 这里执行了静态代码块：</p><pre><code>/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */static {    loadInitialDrivers();    println(&quot;JDBC DriverManager initialized&quot;);}</code></pre><p>　　继续看loadInitialDrivers方法干了什么？</p><pre><code>private static void loadInitialDrivers() {    String drivers;    try {        // 通过权限控制器获取系统配置jdbc.drivers，这里我们没有设置系统，因此这里返回空        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {            public String run() {                return System.getProperty(&quot;jdbc.drivers&quot;);            }        });    } catch (Exception ex) {        drivers = null;    }    // If the driver is packaged as a Service Provider, load it.    // Get all the drivers through the classloader    // exposed as a java.sql.Driver.class service.    // ServiceLoader.load() replaces the sun.misc.Providers()    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {        public Void run() {            // 重点在这里            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); //记住这里，后面会用到            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();            /* Load these drivers, so that they can be instantiated.             * It may be the case that the driver class may not be there             * i.e. there may be a packaged driver with the service class             * as implementation of java.sql.Driver but the actual class             * may be missing. In that case a java.util.ServiceConfigurationError             * will be thrown at runtime by the VM trying to locate             * and load the service.             *             * Adding a try catch block to catch those runtime errors             * if driver not available in classpath but it&apos;s             * packaged as service and that service is there in classpath.             */            try{                while(driversIterator.hasNext()) {                    driversIterator.next();                }            } catch(Throwable t) {            // Do nothing            }            return null;        }    });    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);    if (drivers == null || drivers.equals(&quot;&quot;)) {        return;    }    String[] driversList = drivers.split(&quot;:&quot;);    println(&quot;number of Drivers:&quot; + driversList.length);    for (String aDriver : driversList) {        try {            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);            Class.forName(aDriver, true,                    ClassLoader.getSystemClassLoader());        } catch (Exception ex) {            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);        }    }}</code></pre><p>　　上面这段代码因为drivers变量值为空，所以实际起作用的是中间的代码块。先来看代码<code>ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class)</code>传入的参数是<code>java.sql.Driver.class</code>，这里面做了什么：</p><pre><code>/** * Creates a new service loader for the given service type, using the * current thread&apos;s {@linkplain java.lang.Thread#getContextClassLoader * context class loader}. */public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {    ClassLoader cl = Thread.currentThread().getContextClassLoader();    return ServiceLoader.load(service, cl);}</code></pre><p>　　注释写的很清楚，返回一个server loader，使用的是线程上下文类加载器,currentThread()即当前main线程的类加载器。继续到<code>ServiceLoader.load(service, cl)</code>中看一看：</p><pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,                                        ClassLoader loader){    // 返回了一个ServiceLoader对象。service和loader是两个构造参数，实际上赋值给成员变量了。    return new ServiceLoader&lt;&gt;(service, loader);}</code></pre><p>　　继续看ServiceLoader是如何构造新对象的，将参数传给了两个成员变量。这里要注意ClassLoader.getSystemClassLoader()获取的并不是boot类加载器，而是本线程的类加载器，即MAIN线程的类加载器appClassLoader。</p><pre><code>private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;    reload();}</code></pre><p>　　回到上面，来看一下loadInitialDrivers方法的while循环中的内容，ServiceLoader的iterator()方法返回了一个Iterator类型的对象，ServiceLoader实现了几个方法，看代码</p><pre><code>public Iterator&lt;S&gt; iterator() {    return new Iterator&lt;S&gt;() {        ／／　因为providers中并没有添加元素，因此元素数必定是０        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders            = providers.entrySet().iterator();        public boolean hasNext() {            ／／loadInitialDrivers方法的while循环在执行hasNext时，因为knownProviders没有元素，所必定走到了lookupIterator.hasNext()，这个里边有个关键的信息。            if (knownProviders.hasNext())                return true;            return lookupIterator.hasNext();        }        public S next() {            if (knownProviders.hasNext())                return knownProviders.next().getValue();            return lookupIterator.next();        }        public void remove() {            throw new UnsupportedOperationException();        }    };}</code></pre><p>　　上面的过程看注释。</p><pre><code>public boolean hasNext() {        if (acc == null) {            return hasNextService();        } else {            PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() {                // 注意这行，重点在hasNextService()中。                public Boolean run() { return hasNextService(); }            };            return AccessController.doPrivileged(action, acc);        }    }private boolean hasNextService() {        if (nextName != null) {            return true;        }        if (configs == null) {            try {                // PREFIX = &quot;META-INF/services/&quot;，而这里的service在前面ServiceLoader.load(Driver.class)传入的是java.sql.Driver.class, 完成的fullname就是&quot;META-INF/services/java.sql.Driver&quot;                String fullName = PREFIX + service.getName();                if (loader == null)                    configs = ClassLoader.getSystemResources(fullName);                else                    configs = loader.getResources(fullName);            } catch (IOException x) {                fail(service, &quot;Error locating configuration files&quot;, x);            }        }        while ((pending == null) || !pending.hasNext()) {            if (!configs.hasMoreElements()) {                return false;            }            pending = parse(service, configs.nextElement());        }        nextName = pending.next();        return true;    }</code></pre><p>上面的”META-INF/services/java.sql.Driver”是哪里来的？ 来看看我们的驱动包<br><img src="https://i.imgur.com/yseBq0f.png" alt=""><br>驱动包的这个路径下有个java.sql.Driver命名的文件，而文件中的内容只有一行<code>com.mysql.cj.jdbc.Driver</code>，就是mysql的驱动类名。也就是JDK会查找驱动包中META-INF/services/java.sql.Driver，找到文件中列出的驱动类。 后面不再深入，有兴趣的自己看下。loadInitialDrivers方法的while循环driversIterator.next()方法就是用最初传入的类加载器加载了JDBC的驱动。</p><p>PS：</p><ul><li>关于Reflection类的使用，可参考博文<a href="https://blog.csdn.net/aguda_king/article/details/72355807" title="JDK8的@CallerSensitive" target="_blank" rel="noopener">https://blog.csdn.net/aguda_king/article/details/72355807</a> </li><li>关于线程上下文类加载器的理解可以参考博文<a href="https://blog.csdn.net/yangcheng33/article/details/52631940" title="真正理解线程上下文类加载器（多案例分析）" target="_blank" rel="noopener">https://blog.csdn.net/yangcheng33/article/details/52631940</a>和<a href="https://blog.csdn.net/gabele/article/details/71250108" title="深入理解Java类加载器：线程上下文类加载器" target="_blank" rel="noopener">https://blog.csdn.net/gabele/article/details/71250108</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;6&quot;&gt;mysql驱动的类加载过程&lt;/font&gt;

&lt;hr&gt;
&lt;p&gt;　　JDBC是开发中常用的驱动程序，但一直没有深入了解过其加载过程。JDBC驱动的加载也是线程上下文类加载器使用的经典案例。最近有时间研究一下源码，结合JVM线程上下文类加载器的知识做个总结
      
    
    </summary>
    
    
  </entry>
  
</feed>
